{"ast":null,"code":"import _createForOfIteratorHelper from \"D:/queen-supermarket/Biz1Market_EXE/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport _classCallCheck from \"D:/queen-supermarket/Biz1Market_EXE/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"D:/queen-supermarket/Biz1Market_EXE/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"D:/queen-supermarket/Biz1Market_EXE/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"D:/queen-supermarket/Biz1Market_EXE/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport _toConsumableArray from \"D:/queen-supermarket/Biz1Market_EXE/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport { compose, ScannedActionsSubject, Store, createAction, StoreRootModule, StoreFeatureModule } from '@ngrx/store';\nimport { merge, Observable, Subject, defer, Notification } from 'rxjs';\nimport { ignoreElements, materialize, map, catchError, filter, groupBy, mergeMap, exhaustMap, dematerialize, take, concatMap, finalize } from 'rxjs/operators';\nimport { Injectable, Inject, InjectionToken, ErrorHandler, NgModule, Optional, Injector, SkipSelf, Self } from '@angular/core';\n/**\n * @fileoverview added by tsickle\n * Generated from: src/models.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * Configures an effect created by `createEffect`.\n * @record\n */\n\nimport * as ɵngcc0 from '@angular/core';\nimport * as ɵngcc1 from 'rxjs';\nimport * as ɵngcc2 from '@ngrx/store';\n\nfunction EffectConfig() {}\n\nif (false) {\n  /**\n   * Determines if the action emitted by the effect is dispatched to the store.\n   * If false, effect does not need to return type `Observable<Action>`.\n   * @type {?|undefined}\n   */\n  EffectConfig.prototype.dispatch;\n  /**\n   * Determines if the effect will be resubscribed to if an error occurs in the main actions stream.\n   * @type {?|undefined}\n   */\n\n  EffectConfig.prototype.useEffectsErrorHandler;\n}\n/** @type {?} */\n\n\nvar DEFAULT_EFFECT_CONFIG = {\n  dispatch: true,\n  useEffectsErrorHandler: true\n};\n/** @type {?} */\n\nvar CREATE_EFFECT_METADATA_KEY = '__@ngrx/effects_create__';\n/**\n * @record\n */\n\nfunction CreateEffectMetadata() {}\n\nif (false) {\n  /* Skipping unnamed member:\n  [CREATE_EFFECT_METADATA_KEY]: EffectConfig;*/\n}\n/**\n * @record\n * @template T\n */\n\n\nfunction EffectMetadata() {}\n\nif (false) {\n  /** @type {?} */\n  EffectMetadata.prototype.propertyName;\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: src/effect_creator.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * \\@description\n * Creates an effect from an `Observable` and an `EffectConfig`.\n *\n * \\@usageNotes\n *\n * ** Mapping to a different action **\n * ```ts\n * effectName$ = createEffect(\n *   () => this.actions$.pipe(\n *     ofType(FeatureActions.actionOne),\n *     map(() => FeatureActions.actionTwo())\n *   )\n * );\n * ```\n *\n *  ** Non-dispatching effects **\n * ```ts\n * effectName$ = createEffect(\n *   () => this.actions$.pipe(\n *     ofType(FeatureActions.actionOne),\n *     tap(() => console.log('Action One Dispatched'))\n *   ),\n *   { dispatch: false }\n *   // FeatureActions.actionOne is not dispatched\n * );\n * ```\n * @template C, DT, OT, R\n * @param {?} source A function which returns an `Observable`.\n * @param {?=} config A `Partial<EffectConfig>` to configure the effect.  By default, `dispatch` is true and `useEffectsErrorHandler` is true.\n * @return {?} If `EffectConfig`#`dispatch` is true, returns `Observable<Action>`.  Else, returns `Observable<unknown>`.\n *\n */\n\n\nfunction createEffect(source, config) {\n  /** @type {?} */\n  var effect = source();\n  /** @type {?} */\n\n  var value = Object.assign(Object.assign({}, DEFAULT_EFFECT_CONFIG), config);\n  Object.defineProperty(effect, CREATE_EFFECT_METADATA_KEY, {\n    value: value\n  });\n  return (\n    /** @type {?} */\n    effect\n  );\n}\n/**\n * @template T\n * @param {?} instance\n * @return {?}\n */\n\n\nfunction getCreateEffectMetadata(instance) {\n  /** @type {?} */\n  var propertyNames =\n  /** @type {?} */\n  Object.getOwnPropertyNames(instance);\n  /** @type {?} */\n\n  var metadata = propertyNames.filter(\n  /**\n  * @param {?} propertyName\n  * @return {?}\n  */\n  function (propertyName) {\n    return instance[propertyName] && instance[propertyName].hasOwnProperty(CREATE_EFFECT_METADATA_KEY);\n  }).map(\n  /**\n  * @param {?} propertyName\n  * @return {?}\n  */\n  function (propertyName) {\n    /** @type {?} */\n    var metaData =\n    /** @type {?} */\n    instance[propertyName][CREATE_EFFECT_METADATA_KEY];\n    return Object.assign({\n      propertyName: propertyName\n    }, metaData);\n  });\n  return metadata;\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: src/utils.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @template T\n * @param {?} instance\n * @return {?}\n */\n\n\nfunction getSourceForInstance(instance) {\n  return Object.getPrototypeOf(instance);\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: src/effect_decorator.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/** @type {?} */\n\n\nvar METADATA_KEY = '__@ngrx/effects__';\n/**\n * @param {?=} config\n * @return {?}\n */\n\nfunction Effect() {\n  var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return (\n    /**\n    * @template T, K\n    * @param {?} target\n    * @param {?} propertyName\n    * @return {?}\n    */\n    function (target, propertyName) {\n      /** @type {?} */\n      var metadata = Object.assign(Object.assign(Object.assign({}, DEFAULT_EFFECT_CONFIG), config), {\n        // Overrides any defaults if values are provided\n        propertyName: propertyName\n      });\n      addEffectMetadataEntry(target, metadata);\n    }\n  );\n}\n/**\n * @template T\n * @param {?} instance\n * @return {?}\n */\n\n\nfunction getEffectDecoratorMetadata(instance) {\n  /** @type {?} */\n  var effectsDecorators = compose(getEffectMetadataEntries, getSourceForInstance)(instance);\n  return effectsDecorators;\n}\n/**\n * Type guard to detemine whether METADATA_KEY is already present on the Class\n * constructor\n * @template T\n * @param {?} sourceProto\n * @return {?}\n */\n\n\nfunction hasMetadataEntries(sourceProto) {\n  return sourceProto.constructor.hasOwnProperty(METADATA_KEY);\n}\n/**\n * Add Effect Metadata to the Effect Class constructor under specific key\n * @template T\n * @param {?} sourceProto\n * @param {?} metadata\n * @return {?}\n */\n\n\nfunction addEffectMetadataEntry(sourceProto, metadata) {\n  if (hasMetadataEntries(sourceProto)) {\n    sourceProto.constructor[METADATA_KEY].push(metadata);\n  } else {\n    Object.defineProperty(sourceProto.constructor, METADATA_KEY, {\n      value: [metadata]\n    });\n  }\n}\n/**\n * @template T\n * @param {?} sourceProto\n * @return {?}\n */\n\n\nfunction getEffectMetadataEntries(sourceProto) {\n  return hasMetadataEntries(sourceProto) ? sourceProto.constructor[METADATA_KEY] : [];\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: src/effects_metadata.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @template T\n * @param {?} instance\n * @return {?}\n */\n\n\nfunction getEffectsMetadata(instance) {\n  return getSourceMetadata(instance).reduce(\n  /**\n  * @param {?} acc\n  * @param {?} __1\n  * @return {?}\n  */\n  function (acc, _ref) {\n    var propertyName = _ref.propertyName,\n        dispatch = _ref.dispatch,\n        useEffectsErrorHandler = _ref.useEffectsErrorHandler;\n    acc[propertyName] = {\n      dispatch: dispatch,\n      useEffectsErrorHandler: useEffectsErrorHandler\n    };\n    return acc;\n  }, {});\n}\n/**\n * @template T\n * @param {?} instance\n * @return {?}\n */\n\n\nfunction getSourceMetadata(instance) {\n  /** @type {?} */\n  var effects = [getEffectDecoratorMetadata, getCreateEffectMetadata];\n  return effects.reduce(\n  /**\n  * @param {?} sources\n  * @param {?} source\n  * @return {?}\n  */\n  function (sources, source) {\n    return sources.concat(source(instance));\n  }, []);\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: src/effects_resolver.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @param {?} sourceInstance\n * @param {?} globalErrorHandler\n * @param {?} effectsErrorHandler\n * @return {?}\n */\n\n\nfunction mergeEffects(sourceInstance, globalErrorHandler, effectsErrorHandler) {\n  /** @type {?} */\n  var sourceName = getSourceForInstance(sourceInstance).constructor.name;\n  /** @type {?} */\n\n  var observables$ = getSourceMetadata(sourceInstance).map(\n  /**\n  * @param {?} __0\n  * @return {?}\n  */\n  function (_ref2) {\n    var propertyName = _ref2.propertyName,\n        dispatch = _ref2.dispatch,\n        useEffectsErrorHandler = _ref2.useEffectsErrorHandler;\n\n    /** @type {?} */\n    var observable$ = typeof sourceInstance[propertyName] === 'function' ? sourceInstance[propertyName]() : sourceInstance[propertyName];\n    /** @type {?} */\n\n    var effectAction$ = useEffectsErrorHandler ? effectsErrorHandler(observable$, globalErrorHandler) : observable$;\n\n    if (dispatch === false) {\n      return effectAction$.pipe(ignoreElements());\n    }\n    /** @type {?} */\n\n\n    var materialized$ = effectAction$.pipe(materialize());\n    return materialized$.pipe(map(\n    /**\n    * @param {?} notification\n    * @return {?}\n    */\n    function (notification) {\n      return {\n        effect: sourceInstance[propertyName],\n        notification: notification,\n        propertyName: propertyName,\n        sourceName: sourceName,\n        sourceInstance: sourceInstance\n      };\n    }));\n  });\n  return merge.apply(void 0, _toConsumableArray(observables$));\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: src/effects_error_handler.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/** @type {?} */\n\n\nvar MAX_NUMBER_OF_RETRY_ATTEMPTS = 10;\n/**\n * @template T\n * @param {?} observable$\n * @param {?} errorHandler\n * @param {?=} retryAttemptLeft\n * @return {?}\n */\n\nfunction defaultEffectsErrorHandler(observable$, errorHandler) {\n  var retryAttemptLeft = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : MAX_NUMBER_OF_RETRY_ATTEMPTS;\n  return observable$.pipe(catchError(\n  /**\n  * @param {?} error\n  * @return {?}\n  */\n  function (error) {\n    if (errorHandler) errorHandler.handleError(error);\n\n    if (retryAttemptLeft <= 1) {\n      return observable$; // last attempt\n    } // Return observable that produces this particular effect\n\n\n    return defaultEffectsErrorHandler(observable$, errorHandler, retryAttemptLeft - 1);\n  }));\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: src/actions.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @template V\n */\n\n\nvar Actions = /*#__PURE__*/function (_Observable) {\n  _inherits(Actions, _Observable);\n\n  var _super = _createSuper(Actions);\n\n  /**\n   * @param {?=} source\n   */\n  function Actions(source) {\n    var _this;\n\n    _classCallCheck(this, Actions);\n\n    _this = _super.call(this);\n\n    if (source) {\n      _this.source = source;\n    }\n\n    return _this;\n  }\n  /**\n   * @template R\n   * @param {?} operator\n   * @return {?}\n   */\n\n\n  _createClass(Actions, [{\n    key: \"lift\",\n    value: function lift(operator) {\n      /** @type {?} */\n      var observable = new Actions();\n      observable.source = this;\n      observable.operator = operator;\n      return observable;\n    }\n  }]);\n\n  return Actions;\n}(Observable);\n\nActions.ɵfac = function Actions_Factory(t) {\n  return new (t || Actions)(ɵngcc0.ɵɵinject(ScannedActionsSubject));\n};\n\nActions.ɵprov = ɵngcc0.ɵɵdefineInjectable({\n  token: Actions,\n  factory: Actions.ɵfac\n});\n/** @nocollapse */\n\nActions.ctorParameters = function () {\n  return [{\n    type: Observable,\n    decorators: [{\n      type: Inject,\n      args: [ScannedActionsSubject]\n    }]\n  }];\n};\n/*@__PURE__*/\n\n\n(function () {\n  ɵngcc0.ɵsetClassMetadata(Actions, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: ɵngcc1.Observable,\n      decorators: [{\n        type: Inject,\n        args: [ScannedActionsSubject]\n      }]\n    }];\n  }, null);\n})();\n/**\n * @param {...?} allowedTypes\n * @return {?}\n */\n\n\nfunction ofType() {\n  for (var _len = arguments.length, allowedTypes = new Array(_len), _key = 0; _key < _len; _key++) {\n    allowedTypes[_key] = arguments[_key];\n  }\n\n  return filter(\n  /**\n  * @param {?} action\n  * @return {?}\n  */\n  function (action) {\n    return allowedTypes.some(\n    /**\n    * @param {?} typeOrActionCreator\n    * @return {?}\n    */\n    function (typeOrActionCreator) {\n      if (typeof typeOrActionCreator === 'string') {\n        // Comparing the string to type\n        return typeOrActionCreator === action.type;\n      } // We are filtering by ActionCreator\n\n\n      return typeOrActionCreator.type === action.type;\n    });\n  });\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: src/effect_notification.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @record\n */\n\n\nfunction EffectNotification() {}\n\nif (false) {\n  /** @type {?} */\n  EffectNotification.prototype.effect;\n  /** @type {?} */\n\n  EffectNotification.prototype.propertyName;\n  /** @type {?} */\n\n  EffectNotification.prototype.sourceName;\n  /** @type {?} */\n\n  EffectNotification.prototype.sourceInstance;\n  /** @type {?} */\n\n  EffectNotification.prototype.notification;\n}\n/**\n * @param {?} output\n * @param {?} reporter\n * @return {?}\n */\n\n\nfunction reportInvalidActions(output, reporter) {\n  if (output.notification.kind === 'N') {\n    /** @type {?} */\n    var action = output.notification.value;\n    /** @type {?} */\n\n    var isInvalidAction = !isAction(action);\n\n    if (isInvalidAction) {\n      reporter.handleError(new Error(\"Effect \".concat(getEffectName(output), \" dispatched an invalid action: \").concat(stringify(action))));\n    }\n  }\n}\n/**\n * @param {?} action\n * @return {?}\n */\n\n\nfunction isAction(action) {\n  return typeof action !== 'function' && action && action.type && typeof action.type === 'string';\n}\n/**\n * @param {?} __0\n * @return {?}\n */\n\n\nfunction getEffectName(_ref3) {\n  var propertyName = _ref3.propertyName,\n      sourceInstance = _ref3.sourceInstance,\n      sourceName = _ref3.sourceName;\n\n  /** @type {?} */\n  var isMethod = typeof sourceInstance[propertyName] === 'function';\n  return \"\\\"\".concat(sourceName, \".\").concat(String(propertyName)).concat(isMethod ? '()' : '', \"\\\"\");\n}\n/**\n * @param {?} action\n * @return {?}\n */\n\n\nfunction stringify(action) {\n  try {\n    return JSON.stringify(action);\n  } catch (_a) {\n    return action;\n  }\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: src/lifecycle_hooks.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/** @type {?} */\n\n\nvar onIdentifyEffectsKey = 'ngrxOnIdentifyEffects';\n/**\n * @param {?} instance\n * @return {?}\n */\n\nfunction isOnIdentifyEffects(instance) {\n  return isFunction(instance, onIdentifyEffectsKey);\n}\n/** @type {?} */\n\n\nvar onRunEffectsKey = 'ngrxOnRunEffects';\n/**\n * @param {?} instance\n * @return {?}\n */\n\nfunction isOnRunEffects(instance) {\n  return isFunction(instance, onRunEffectsKey);\n}\n/** @type {?} */\n\n\nvar onInitEffects = 'ngrxOnInitEffects';\n/**\n * @param {?} instance\n * @return {?}\n */\n\nfunction isOnInitEffects(instance) {\n  return isFunction(instance, onInitEffects);\n}\n/**\n * @param {?} instance\n * @param {?} functionName\n * @return {?}\n */\n\n\nfunction isFunction(instance, functionName) {\n  return instance && functionName in instance && typeof instance[functionName] === 'function';\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: src/tokens.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/** @type {?} */\n\n\nvar _ROOT_EFFECTS_GUARD = new InjectionToken('@ngrx/effects Internal Root Guard');\n/** @type {?} */\n\n\nvar IMMEDIATE_EFFECTS = new InjectionToken('ngrx/effects: Immediate Effects');\n/** @type {?} */\n\nvar USER_PROVIDED_EFFECTS = new InjectionToken('ngrx/effects: User Provided Effects');\n/** @type {?} */\n\nvar _ROOT_EFFECTS = new InjectionToken('ngrx/effects: Internal Root Effects');\n/** @type {?} */\n\n\nvar ROOT_EFFECTS = new InjectionToken('ngrx/effects: Root Effects');\n/** @type {?} */\n\nvar _FEATURE_EFFECTS = new InjectionToken('ngrx/effects: Internal Feature Effects');\n/** @type {?} */\n\n\nvar FEATURE_EFFECTS = new InjectionToken('ngrx/effects: Feature Effects');\n/** @type {?} */\n\nvar EFFECTS_ERROR_HANDLER = new InjectionToken('ngrx/effects: Effects Error Handler');\n/**\n * @fileoverview added by tsickle\n * Generated from: src/effect_sources.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\nvar EffectSources = /*#__PURE__*/function (_Subject) {\n  _inherits(EffectSources, _Subject);\n\n  var _super2 = _createSuper(EffectSources);\n\n  /**\n   * @param {?} errorHandler\n   * @param {?} effectsErrorHandler\n   */\n  function EffectSources(errorHandler, effectsErrorHandler) {\n    var _this2;\n\n    _classCallCheck(this, EffectSources);\n\n    _this2 = _super2.call(this);\n    _this2.errorHandler = errorHandler;\n    _this2.effectsErrorHandler = effectsErrorHandler;\n    return _this2;\n  }\n  /**\n   * @param {?} effectSourceInstance\n   * @return {?}\n   */\n\n\n  _createClass(EffectSources, [{\n    key: \"addEffects\",\n    value: function addEffects(effectSourceInstance) {\n      this.next(effectSourceInstance);\n    }\n    /**\n     * \\@internal\n     * @return {?}\n     */\n\n  }, {\n    key: \"toActions\",\n    value: function toActions() {\n      var _this3 = this;\n\n      return this.pipe(groupBy(getSourceForInstance), mergeMap(\n      /**\n      * @param {?} source$\n      * @return {?}\n      */\n      function (source$) {\n        return source$.pipe(groupBy(effectsInstance));\n      }), mergeMap(\n      /**\n      * @param {?} source$\n      * @return {?}\n      */\n      function (source$) {\n        /** @type {?} */\n        var effect$ = source$.pipe(exhaustMap(\n        /**\n        * @param {?} sourceInstance\n        * @return {?}\n        */\n        function (sourceInstance) {\n          return resolveEffectSource(_this3.errorHandler, _this3.effectsErrorHandler)(sourceInstance);\n        }), map(\n        /**\n        * @param {?} output\n        * @return {?}\n        */\n        function (output) {\n          reportInvalidActions(output, _this3.errorHandler);\n          return output.notification;\n        }), filter(\n        /**\n        * @param {?} notification\n        * @return {?}\n        */\n        function (notification) {\n          return notification.kind === 'N';\n        }), dematerialize()); // start the stream with an INIT action\n        // do this only for the first Effect instance\n\n        /** @type {?} */\n\n        var init$ = source$.pipe(take(1), filter(isOnInitEffects), map(\n        /**\n        * @param {?} instance\n        * @return {?}\n        */\n        function (instance) {\n          return instance.ngrxOnInitEffects();\n        }));\n        return merge(effect$, init$);\n      }));\n    }\n  }]);\n\n  return EffectSources;\n}(Subject);\n\nEffectSources.ɵfac = function EffectSources_Factory(t) {\n  return new (t || EffectSources)(ɵngcc0.ɵɵinject(ɵngcc0.ErrorHandler), ɵngcc0.ɵɵinject(EFFECTS_ERROR_HANDLER));\n};\n\nEffectSources.ɵprov = ɵngcc0.ɵɵdefineInjectable({\n  token: EffectSources,\n  factory: EffectSources.ɵfac\n});\n/** @nocollapse */\n\nEffectSources.ctorParameters = function () {\n  return [{\n    type: ErrorHandler\n  }, {\n    type: undefined,\n    decorators: [{\n      type: Inject,\n      args: [EFFECTS_ERROR_HANDLER]\n    }]\n  }];\n};\n/*@__PURE__*/\n\n\n(function () {\n  ɵngcc0.ɵsetClassMetadata(EffectSources, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: ɵngcc0.ErrorHandler\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [EFFECTS_ERROR_HANDLER]\n      }]\n    }];\n  }, null);\n})();\n\nif (false) {\n  /**\n   * @type {?}\n   * @private\n   */\n  EffectSources.prototype.errorHandler;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  EffectSources.prototype.effectsErrorHandler;\n}\n/**\n * @param {?} sourceInstance\n * @return {?}\n */\n\n\nfunction effectsInstance(sourceInstance) {\n  if (isOnIdentifyEffects(sourceInstance)) {\n    return sourceInstance.ngrxOnIdentifyEffects();\n  }\n\n  return '';\n}\n/**\n * @param {?} errorHandler\n * @param {?} effectsErrorHandler\n * @return {?}\n */\n\n\nfunction resolveEffectSource(errorHandler, effectsErrorHandler) {\n  return (\n    /**\n    * @param {?} sourceInstance\n    * @return {?}\n    */\n    function (sourceInstance) {\n      /** @type {?} */\n      var mergedEffects$ = mergeEffects(sourceInstance, errorHandler, effectsErrorHandler);\n\n      if (isOnRunEffects(sourceInstance)) {\n        return sourceInstance.ngrxOnRunEffects(mergedEffects$);\n      }\n\n      return mergedEffects$;\n    }\n  );\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: src/effects_runner.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nvar EffectsRunner = /*#__PURE__*/function () {\n  /**\n   * @param {?} effectSources\n   * @param {?} store\n   */\n  function EffectsRunner(effectSources, store) {\n    _classCallCheck(this, EffectsRunner);\n\n    this.effectSources = effectSources;\n    this.store = store;\n    this.effectsSubscription = null;\n  }\n  /**\n   * @return {?}\n   */\n\n\n  _createClass(EffectsRunner, [{\n    key: \"start\",\n    value: function start() {\n      if (!this.effectsSubscription) {\n        this.effectsSubscription = this.effectSources.toActions().subscribe(this.store);\n      }\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"ngOnDestroy\",\n    value: function ngOnDestroy() {\n      if (this.effectsSubscription) {\n        this.effectsSubscription.unsubscribe();\n        this.effectsSubscription = null;\n      }\n    }\n  }]);\n\n  return EffectsRunner;\n}();\n\nEffectsRunner.ɵfac = function EffectsRunner_Factory(t) {\n  return new (t || EffectsRunner)(ɵngcc0.ɵɵinject(EffectSources), ɵngcc0.ɵɵinject(ɵngcc2.Store));\n};\n\nEffectsRunner.ɵprov = ɵngcc0.ɵɵdefineInjectable({\n  token: EffectsRunner,\n  factory: EffectsRunner.ɵfac\n});\n/** @nocollapse */\n\nEffectsRunner.ctorParameters = function () {\n  return [{\n    type: EffectSources\n  }, {\n    type: Store\n  }];\n};\n/*@__PURE__*/\n\n\n(function () {\n  ɵngcc0.ɵsetClassMetadata(EffectsRunner, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: EffectSources\n    }, {\n      type: ɵngcc2.Store\n    }];\n  }, null);\n})();\n\nif (false) {\n  /**\n   * @type {?}\n   * @private\n   */\n  EffectsRunner.prototype.effectsSubscription;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  EffectsRunner.prototype.effectSources;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  EffectsRunner.prototype.store;\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: src/effects_root_module.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/** @type {?} */\n\n\nvar ROOT_EFFECTS_INIT = '@ngrx/effects/init';\n/** @type {?} */\n\nvar rootEffectsInit = createAction(ROOT_EFFECTS_INIT);\n\nvar EffectsRootModule = /*#__PURE__*/function () {\n  /**\n   * @param {?} sources\n   * @param {?} runner\n   * @param {?} store\n   * @param {?} rootEffects\n   * @param {?} storeRootModule\n   * @param {?} storeFeatureModule\n   * @param {?} guard\n   */\n  function EffectsRootModule(sources, runner, store, rootEffects, storeRootModule, storeFeatureModule, guard) {\n    _classCallCheck(this, EffectsRootModule);\n\n    this.sources = sources;\n    runner.start();\n    rootEffects.forEach(\n    /**\n    * @param {?} effectSourceInstance\n    * @return {?}\n    */\n    function (effectSourceInstance) {\n      return sources.addEffects(effectSourceInstance);\n    });\n    store.dispatch({\n      type: ROOT_EFFECTS_INIT\n    });\n  }\n  /**\n   * @param {?} effectSourceInstance\n   * @return {?}\n   */\n\n\n  _createClass(EffectsRootModule, [{\n    key: \"addEffects\",\n    value: function addEffects(effectSourceInstance) {\n      this.sources.addEffects(effectSourceInstance);\n    }\n  }]);\n\n  return EffectsRootModule;\n}();\n\nEffectsRootModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({\n  type: EffectsRootModule\n});\nEffectsRootModule.ɵinj = ɵngcc0.ɵɵdefineInjector({\n  factory: function EffectsRootModule_Factory(t) {\n    return new (t || EffectsRootModule)(ɵngcc0.ɵɵinject(EffectSources), ɵngcc0.ɵɵinject(EffectsRunner), ɵngcc0.ɵɵinject(ɵngcc2.Store), ɵngcc0.ɵɵinject(ROOT_EFFECTS), ɵngcc0.ɵɵinject(ɵngcc2.StoreRootModule, 8), ɵngcc0.ɵɵinject(ɵngcc2.StoreFeatureModule, 8), ɵngcc0.ɵɵinject(_ROOT_EFFECTS_GUARD, 8));\n  }\n});\n/** @nocollapse */\n\nEffectsRootModule.ctorParameters = function () {\n  return [{\n    type: EffectSources\n  }, {\n    type: EffectsRunner\n  }, {\n    type: Store\n  }, {\n    type: Array,\n    decorators: [{\n      type: Inject,\n      args: [ROOT_EFFECTS]\n    }]\n  }, {\n    type: StoreRootModule,\n    decorators: [{\n      type: Optional\n    }]\n  }, {\n    type: StoreFeatureModule,\n    decorators: [{\n      type: Optional\n    }]\n  }, {\n    type: undefined,\n    decorators: [{\n      type: Optional\n    }, {\n      type: Inject,\n      args: [_ROOT_EFFECTS_GUARD]\n    }]\n  }];\n};\n/*@__PURE__*/\n\n\n(function () {\n  ɵngcc0.ɵsetClassMetadata(EffectsRootModule, [{\n    type: NgModule,\n    args: [{}]\n  }], function () {\n    return [{\n      type: EffectSources\n    }, {\n      type: EffectsRunner\n    }, {\n      type: ɵngcc2.Store\n    }, {\n      type: Array,\n      decorators: [{\n        type: Inject,\n        args: [ROOT_EFFECTS]\n      }]\n    }, {\n      type: ɵngcc2.StoreRootModule,\n      decorators: [{\n        type: Optional\n      }]\n    }, {\n      type: ɵngcc2.StoreFeatureModule,\n      decorators: [{\n        type: Optional\n      }]\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Optional\n      }, {\n        type: Inject,\n        args: [_ROOT_EFFECTS_GUARD]\n      }]\n    }];\n  }, null);\n})();\n\nif (false) {\n  /**\n   * @type {?}\n   * @private\n   */\n  EffectsRootModule.prototype.sources;\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: src/effects_feature_module.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nvar EffectsFeatureModule = /*#__PURE__*/_createClass(\n/**\n * @param {?} root\n * @param {?} effectSourceGroups\n * @param {?} storeRootModule\n * @param {?} storeFeatureModule\n */\nfunction EffectsFeatureModule(root, effectSourceGroups, storeRootModule, storeFeatureModule) {\n  _classCallCheck(this, EffectsFeatureModule);\n\n  effectSourceGroups.forEach(\n  /**\n  * @param {?} group\n  * @return {?}\n  */\n  function (group) {\n    return group.forEach(\n    /**\n    * @param {?} effectSourceInstance\n    * @return {?}\n    */\n    function (effectSourceInstance) {\n      return root.addEffects(effectSourceInstance);\n    });\n  });\n});\n\nEffectsFeatureModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({\n  type: EffectsFeatureModule\n});\nEffectsFeatureModule.ɵinj = ɵngcc0.ɵɵdefineInjector({\n  factory: function EffectsFeatureModule_Factory(t) {\n    return new (t || EffectsFeatureModule)(ɵngcc0.ɵɵinject(EffectsRootModule), ɵngcc0.ɵɵinject(FEATURE_EFFECTS), ɵngcc0.ɵɵinject(ɵngcc2.StoreRootModule, 8), ɵngcc0.ɵɵinject(ɵngcc2.StoreFeatureModule, 8));\n  }\n});\n/** @nocollapse */\n\nEffectsFeatureModule.ctorParameters = function () {\n  return [{\n    type: EffectsRootModule\n  }, {\n    type: Array,\n    decorators: [{\n      type: Inject,\n      args: [FEATURE_EFFECTS]\n    }]\n  }, {\n    type: StoreRootModule,\n    decorators: [{\n      type: Optional\n    }]\n  }, {\n    type: StoreFeatureModule,\n    decorators: [{\n      type: Optional\n    }]\n  }];\n};\n/*@__PURE__*/\n\n\n(function () {\n  ɵngcc0.ɵsetClassMetadata(EffectsFeatureModule, [{\n    type: NgModule,\n    args: [{}]\n  }], function () {\n    return [{\n      type: EffectsRootModule\n    }, {\n      type: Array,\n      decorators: [{\n        type: Inject,\n        args: [FEATURE_EFFECTS]\n      }]\n    }, {\n      type: ɵngcc2.StoreRootModule,\n      decorators: [{\n        type: Optional\n      }]\n    }, {\n      type: ɵngcc2.StoreFeatureModule,\n      decorators: [{\n        type: Optional\n      }]\n    }];\n  }, null);\n})();\n/**\n * @fileoverview added by tsickle\n * Generated from: src/effects_module.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nvar EffectsModule = /*#__PURE__*/function () {\n  function EffectsModule() {\n    _classCallCheck(this, EffectsModule);\n  }\n\n  _createClass(EffectsModule, null, [{\n    key: \"forFeature\",\n    value:\n    /**\n     * @param {?=} featureEffects\n     * @return {?}\n     */\n    function forFeature() {\n      var featureEffects = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n      return {\n        ngModule: EffectsFeatureModule,\n        providers: [featureEffects, {\n          provide: _FEATURE_EFFECTS,\n          multi: true,\n          useValue: featureEffects\n        }, {\n          provide: USER_PROVIDED_EFFECTS,\n          multi: true,\n          useValue: []\n        }, {\n          provide: FEATURE_EFFECTS,\n          multi: true,\n          useFactory: createEffects,\n          deps: [Injector, _FEATURE_EFFECTS, USER_PROVIDED_EFFECTS]\n        }]\n      };\n    }\n    /**\n     * @param {?=} rootEffects\n     * @return {?}\n     */\n\n  }, {\n    key: \"forRoot\",\n    value: function forRoot() {\n      var rootEffects = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n      return {\n        ngModule: EffectsRootModule,\n        providers: [{\n          provide: EFFECTS_ERROR_HANDLER,\n          useValue: defaultEffectsErrorHandler\n        }, EffectsRunner, EffectSources, Actions, rootEffects, {\n          provide: _ROOT_EFFECTS,\n          useValue: [rootEffects]\n        }, {\n          provide: _ROOT_EFFECTS_GUARD,\n          useFactory: _provideForRootGuard,\n          deps: [[EffectsRunner, new Optional(), new SkipSelf()], [_ROOT_EFFECTS, new Self()]]\n        }, {\n          provide: USER_PROVIDED_EFFECTS,\n          multi: true,\n          useValue: []\n        }, {\n          provide: ROOT_EFFECTS,\n          useFactory: createEffects,\n          deps: [Injector, _ROOT_EFFECTS, USER_PROVIDED_EFFECTS]\n        }]\n      };\n    }\n  }]);\n\n  return EffectsModule;\n}();\n\nEffectsModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({\n  type: EffectsModule\n});\nEffectsModule.ɵinj = ɵngcc0.ɵɵdefineInjector({\n  factory: function EffectsModule_Factory(t) {\n    return new (t || EffectsModule)();\n  }\n});\n/*@__PURE__*/\n\n(function () {\n  ɵngcc0.ɵsetClassMetadata(EffectsModule, [{\n    type: NgModule,\n    args: [{}]\n  }], null, null);\n})();\n/**\n * @param {?} injector\n * @param {?} effectGroups\n * @param {?} userProvidedEffectGroups\n * @return {?}\n */\n\n\nfunction createEffects(injector, effectGroups, userProvidedEffectGroups) {\n  /** @type {?} */\n  var mergedEffects = [];\n\n  var _iterator = _createForOfIteratorHelper(effectGroups),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var effectGroup = _step.value;\n      mergedEffects.push.apply(mergedEffects, _toConsumableArray(effectGroup));\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  var _iterator2 = _createForOfIteratorHelper(userProvidedEffectGroups),\n      _step2;\n\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var userProvidedEffectGroup = _step2.value;\n      mergedEffects.push.apply(mergedEffects, _toConsumableArray(userProvidedEffectGroup));\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n\n  return createEffectInstances(injector, mergedEffects);\n}\n/**\n * @param {?} injector\n * @param {?} effects\n * @return {?}\n */\n\n\nfunction createEffectInstances(injector, effects) {\n  return effects.map(\n  /**\n  * @param {?} effect\n  * @return {?}\n  */\n  function (effect) {\n    return injector.get(effect);\n  });\n}\n/**\n * @param {?} runner\n * @param {?} rootEffects\n * @return {?}\n */\n\n\nfunction _provideForRootGuard(runner, rootEffects) {\n  // check whether any effects are actually passed\n\n  /** @type {?} */\n  var hasEffects = !(rootEffects.length === 1 && rootEffects[0].length === 0);\n\n  if (hasEffects && runner) {\n    throw new TypeError(\"EffectsModule.forRoot() called twice. Feature modules should use EffectsModule.forFeature() instead.\");\n  }\n\n  return 'guarded';\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: src/act.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * Represents config with named paratemeters for act\n * @record\n * @template Input, OutputAction, ErrorAction, CompleteAction, UnsubscribeAction\n */\n\n\nfunction ActConfig() {}\n\nif (false) {\n  /** @type {?} */\n  ActConfig.prototype.project;\n  /** @type {?} */\n\n  ActConfig.prototype.error;\n  /** @type {?|undefined} */\n\n  ActConfig.prototype.complete;\n  /** @type {?|undefined} */\n\n  ActConfig.prototype.operator;\n  /** @type {?|undefined} */\n\n  ActConfig.prototype.unsubscribe;\n}\n/**\n * @template Input, OutputAction, ErrorAction, CompleteAction, UnsubscribeAction\n * @param {?} configOrProject\n * @param {?=} errorFn\n * @return {?}\n */\n\n\nfunction act(\n/** Allow to take either config object or project/error functions */\nconfigOrProject, errorFn) {\n  var _ref4 = typeof configOrProject === 'function' ? {\n    project: configOrProject,\n    error:\n    /** @type {?} */\n    errorFn,\n    operator: concatMap,\n    complete: undefined,\n    unsubscribe: undefined\n  } : Object.assign(Object.assign({}, configOrProject), {\n    operator: configOrProject.operator || concatMap\n  }),\n      project = _ref4.project,\n      error = _ref4.error,\n      complete = _ref4.complete,\n      operator = _ref4.operator,\n      unsubscribe = _ref4.unsubscribe;\n\n  return (\n    /**\n    * @param {?} source\n    * @return {?}\n    */\n    function (source) {\n      return defer(\n      /**\n      * @return {?}\n      */\n      function () {\n        /** @type {?} */\n        var subject = new Subject();\n        return merge(source.pipe(operator(\n        /**\n        * @param {?} input\n        * @param {?} index\n        * @return {?}\n        */\n        function (input, index) {\n          return defer(\n          /**\n          * @return {?}\n          */\n          function () {\n            /** @type {?} */\n            var completed = false;\n            /** @type {?} */\n\n            var errored = false;\n            /** @type {?} */\n\n            var projectedCount = 0;\n            return project(input, index).pipe(materialize(), map(\n            /**\n            * @param {?} notification\n            * @return {?}\n            */\n            function (notification) {\n              switch (notification.kind) {\n                case 'E':\n                  errored = true;\n                  return new Notification(\n                  /** @type {?} */\n                  // TODO: remove any in RxJS 6.5\n                  'N', error(notification.error, input));\n\n                case 'C':\n                  completed = true;\n                  return complete ? new Notification(\n                  /** @type {?} */\n                  // TODO: remove any in RxJS 6.5\n                  'N', complete(projectedCount, input)) : undefined;\n\n                default:\n                  ++projectedCount;\n                  return notification;\n              }\n            }), filter(\n            /**\n            * @param {?} n\n            * @return {?}\n            */\n            function (n) {\n              return n != null;\n            }), dematerialize(), finalize(\n            /**\n            * @return {?}\n            */\n            function () {\n              if (!completed && !errored && unsubscribe) {\n                subject.next(unsubscribe(projectedCount, input));\n              }\n            }));\n          });\n        })), subject);\n      });\n    }\n  );\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: src/index.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * Generated from: public_api.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * Generated from: index.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * Generated from: ngrx-effects.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nexport { Actions, EFFECTS_ERROR_HANDLER, Effect, EffectSources, EffectsFeatureModule, EffectsModule, EffectsRootModule, EffectsRunner, ROOT_EFFECTS_INIT, USER_PROVIDED_EFFECTS, act, createEffect, defaultEffectsErrorHandler, getEffectsMetadata, mergeEffects, ofType, rootEffectsInit, getSourceMetadata as ɵa, createEffects as ɵb, _provideForRootGuard as ɵc, _ROOT_EFFECTS_GUARD as ɵd, _ROOT_EFFECTS as ɵe, ROOT_EFFECTS as ɵf, _FEATURE_EFFECTS as ɵg, FEATURE_EFFECTS as ɵh };","map":{"version":3,"sources":["../../../../modules/effects/src/models.ts","../../../../modules/effects/src/effect_creator.ts","../../../../modules/effects/src/utils.ts","../../../../modules/effects/src/effect_decorator.ts","../../../../modules/effects/src/effects_metadata.ts","../../../../modules/effects/src/effects_resolver.ts","../../../../modules/effects/src/effects_error_handler.ts","../../../../modules/effects/src/actions.ts","../../../../modules/effects/src/effect_notification.ts","../../../../modules/effects/src/lifecycle_hooks.ts","../../../../modules/effects/src/tokens.ts","../../../../modules/effects/src/effect_sources.ts","../../../../modules/effects/src/effects_runner.ts","../../../../modules/effects/src/effects_root_module.ts","../../../../modules/effects/src/effects_feature_module.ts","../../../../modules/effects/src/effects_module.ts","../../../../modules/effects/src/act.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;yBAaC;;AACD,IAAA,KAAA,EAAA;AACY;AAAQ;AAET;AAGuC;AAE5C;AAdJ,EAAA,YAAA,CAAA,SAAA,CAAA,QAAA;AACF;AACE;AACE;AACqB;;AAAvB,EAAA,YAAA,CAAA,SAAA,CAAA,sBAAA;AACF;AACA;;;AACgB,IAAH,qBAAqB,GAAqC;AACrE,EAAA,QAAQ,EAAE,IAD2D;AAErE,EAAA,sBAAsB,EAAE;AAF6C,CAAvD;AAIhB;;AACgB,IAAH,0BAA0B,GAAG,0BAA1B;AAChB;AACG;AAAW;;AAAI,SAAA,oBAAA,GAAA,CAEjB;;AACD,IAAA,KAAA,EAAA;AACY;AAAgC;AAKvC;AAAE;AAAI;AAAW;AAAe;;;AAAI,SAAA,cAAA,GAAA,CAGxC;;AACD,IAAA,KAAA,EAAA;AACY;AAHV,EAAA,cAAA,CAAA,SAAA,CAAA,YAAA;AACF;AAEA;AAAI;AACD;AAAyC;AAEmF;;AAAI;AAAI;AAAiB;AAAiE;AAAG;AAAgB;AAAG;AAAuC;AAAS;AAA+B;AAA+B;AAAyC;AAA6C;AAAO;AAAM;AAAO;AAAG;AAAkC;AAAS;AAA+B;AAA+B;AAAyC;AAAuD;AAAQ;AAAyB;AAAmD;AAAM;AAAO;AAA0B;AAA+D;AAA+I;AAAyH;AAAG;;;AAAI,SCc5kC,YDd4kC,CCoB1lC,MDpB0lC,ECqB1lC,MDrB0lC,ECqBvkC;AAClB;AAAqB,MAChB,MAAM,GAAG,MAAM,EADC;AAExB;;AAAqB,MAAb,KAAK,GAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,EAAA,EACN,qBADM,CAAA,EAEN,MAFM,CAAQ;AAInB,EAAA,MAAM,CAAC,cAAP,CAAsB,MAAtB,EAA8B,0BAA9B,EAA0D;AACxD,IAAA,KAAK,EAAL;AADwD,GAA1D;AAGA;AAAA;AAAO,IAAA;AAAP;AACD;AACD;AACG;AAAe;AAClB;AAAe;;;AAAI,SADH,uBACG,CACjB,QADiB,EACN;AAAI;AACjB,MAAQ,aAAa;AAAA;AAAG,EAAA,MAAM,CAAC,mBAAP,CAA2B,QAA3B,CAAxB;AACA;;AACoB,MAAZ,QAAQ,GAAwB,aAAa,CAChD,MADmC;AAC7B;AACP;AACO;AAAmB;AADxB,YAAC,YAAD;AAAA,WACE,QAAQ,CAAC,YAAD,CAAR,IACA,QAAQ,CAAC,YAAD,CAAR,CAAuB,cAAvB,CAAsC,0BAAtC,CAFF;AAAA,GAFkC,EAMnC,GANmC;AAMhC;AAAM;AACE;AAAmB;AAD1B,YAAC,YAAD,EAAa;AACtB;AAAyB,QAAb,QAAQ;AAAG;AAAC,IAAA,QAAQ,CAAC,YAAD,CAAT,CACf,0BADe,CAAE;AAGnB,WAAA,MAAA,CAAA,MAAA,CAAA;AACE,MAAA,YAAY,EAAZ;AADF,KAAA,EAEK,QAFL,CAAA;AAID,GAdmC,CAApB;AAgBlB,SAAO,QAAP;AACF;AACC;AAAI;AAAkC;AAAgC;AAAsI;;AAAI;AAAI;AAAe;AAAuB;AAAe;;;AAAI,SChG9P,oBDgG8P,CChGtO,QDgGsO,EChG3N;AACjD,SAAO,MAAM,CAAC,cAAP,CAAsB,QAAtB,CAAP;AACF;AACC;AAAI;AAAkC;AAA2C;AAAsI;;AAAI;;;AAAiB,ICOvO,YAAY,GAAG,mBDPwN;ACQ7O;AACG;AAAsB;AAAe;;AAAI,SAA5B,MAA4B,GAAI;AAAA,MAAzB,MAAyB,uEAAF,EAAE;AAC9C;AAAA;AAAY;AAAsB;AAAyB;AAEtD;AAEP;AAJS,cACL,MADK,EAEL,YAFK,EAEU;AAChB;AACmB,UAAZ,QAAQ,GAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,EAAA,EACT,qBADS,CAAA,EAET,MAFS,CAAA,EAEH;AAAA;AACT,QAAA,YAAY,EAAZ;AADS,OAFG,CAAI;AAKlB,MAAA,sBAAsB,CAAI,MAAJ,EAAY,QAAZ,CAAtB;AACD;AAVD;AAWD;AACD;AACG;AAAe;AAAuB;AAChC;;;AAAI,SADG,0BACH,CAAX,QAAW,EAAA;AACV;AAAqB,MAChB,iBAAiB,GAAwB,OAAO,CACpD,wBADoD,EAEpD,oBAFoD,CAAP,CAG7C,QAH6C,CADzB;AAMtB,SAAO,iBAAP;AACD;AACD;AACG;AAC2E;AAChE;AAEJ;AAA0B;AAChC;;;AADJ,SAAS,kBAAT,CACE,WADF,EACgB;AAMd,SAAO,WAAW,CAAC,WAAZ,CAAwB,cAAxB,CAAuC,YAAvC,CAAP;AACD;AACD;AACG;AAA0E;AAC/D;AAA0B;AAC5B;AACH;;;AAFT,SAAS,sBAAT,CACE,WADF,EAEE,QAFF,EAE6B;AAE3B,MAAI,kBAAkB,CAAC,WAAD,CAAtB,EAAqC;AACnC,IAAA,WAAW,CAAC,WAAZ,CAAwB,YAAxB,EAAsC,IAAtC,CAA2C,QAA3C;AACD,GAFD,MAEO;AACL,IAAA,MAAM,CAAC,cAAP,CAAsB,WAAW,CAAC,WAAlC,EAA+C,YAA/C,EAA6D;AAC3D,MAAA,KAAK,EAAE,CAAC,QAAD;AADoD,KAA7D;AAGD;AACF;AACD;AACG;AAAe;AAA0B;AACtC;;;AADN,SAAS,wBAAT,CACE,WADF,EACgB;AAEd,SAAO,kBAAkB,CAAC,WAAD,CAAlB,GACH,WAAW,CAAC,WAAZ,CAAwB,YAAxB,CADG,GAEH,EAFJ;AAGF;AACC;AAAI;AAAkC;AAA2C;AAAsI;;AAAI;AAAI;AAAe;AAAuB;AAAe;;;AAAI,SCpEzQ,kBDoEyQ,CCpEnP,QDoEmP,ECpExO;AAC/C,SAAO,iBAAiB,CAAC,QAAD,CAAjB,CAA4B,MAA5B;AAAkC;AACvC;AACgB;AACT;AAAmB;AAF1B,YACE,GADF,QAEoD;AAAA,QAAhD,YAAgD,QAAhD,YAAgD;AAAA,QAAlC,QAAkC,QAAlC,QAAkC;AAAA,QAAxB,sBAAwB,QAAxB,sBAAwB;AAElD,IAAA,GAAG,CAAC,YAAD,CAAH,GAAoB;AAAE,MAAA,QAAQ,EAAR,QAAF;AAAY,MAAA,sBAAsB,EAAtB;AAAZ,KAApB;AACA,WAAO,GAAP;AACD,GAPI,EAQL,EARK,CAAP;AAUD;AACD;AACG;AAAe;AAAuB;AAAe;;;AAAI,SAA5C,iBAA4C,CAAvB,QAAuB,EAAZ;AAAI;AACpD,MAAQ,OAAO,GAAgD,CAC3D,0BAD2D,EAE3D,uBAF2D,CAA/D;AAKE,SAAO,OAAO,CAAC,MAAR;AAAc;AAAM;AACpB;AAAyB;AAAmB;AAAjD,YAAC,OAAD,EAAU,MAAV;AAAA,WAAqB,OAAO,CAAC,MAAR,CAAe,MAAM,CAAC,QAAD,CAArB,CAArB;AAAA,GADK,EAEL,EAFK,CAAP;AAIF;AACC;AAAI;AAAkC;AAA2C;AAAsI;;AAAI;AAAI;AAA6B;AAAiC;AAAkC;AAAe;;;AAAI,SClBnU,YDkBmU,CCjBjV,cDiBiV,EChBjV,kBDgBiV,ECfjV,mBDeiV,ECfzS;AACvC;AAAqB,MAChB,UAAU,GAAG,oBAAoB,CAAC,cAAD,CAApB,CAAqC,WAArC,CAAiD,IAD9C;AAExB;;AACoB,MAAZ,YAAY,GAAsB,iBAAiB,CAAC,cAAD,CAAjB,CAAkC,GAAlC;AAAqC;AAC3E;AACe;AAEjB;AAHE,mBAIC;AAAA,QAHC,YAGD,SAHC,YAGD;AAAA,QAFC,QAED,SAFC,QAED;AAAA,QADC,sBACD,SADC,sBACD;;AAAO;AAAyB,QACzB,WAAW,GACf,OAAO,cAAc,CAAC,YAAD,CAArB,KAAwC,UAAxC,GACI,cAAc,CAAC,YAAD,CAAd,EADJ,GAEI,cAAc,CAAC,YAAD,CAJW;AAKrC;;AACwB,QAAZ,aAAa,GAAG,sBAAsB,GACxC,mBAAmB,CAAC,WAAD,EAAc,kBAAd,CADqB,GAExC,WAFc;;AAIlB,QAAI,QAAQ,KAAK,KAAjB,EAAwB;AACtB,aAAO,aAAa,CAAC,IAAd,CAAmB,cAAc,EAAjC,CAAP;AACD;AACP;;;AACwB,QAAZ,aAAa,GAAG,aAAa,CAAC,IAAd,CAAmB,WAAW,EAA9B,CAAJ;AAElB,WAAO,aAAa,CAAC,IAAd,CACL,GAAG;AAAA;AACP;AAAmC;AAAuB;AAApD,cAAC,YAAD;AAAA,aAA6D;AAC3D,QAAA,MAAM,EAAE,cAAc,CAAC,YAAD,CADqC;AAE3D,QAAA,YAAY,EAAZ,YAF2D;AAG3D,QAAA,YAAY,EAAZ,YAH2D;AAI3D,QAAA,UAAU,EAAV,UAJ2D;AAK3D,QAAA,cAAc,EAAd;AAL2D,OAA7D;AAAA,KADC,CADE,CAAP;AAWD,GAhCqC,CAAtB;AAmClB,SAAO,KAAK,MAAL,4BAAS,YAAT,EAAP;AACF;AACC;AAAI;AAAkC;AAAgD;AAAsI;;AAAI;;;AAAiB,IC5C5O,4BAA4B,GAAG,ED4C6M;AC3ClP;AACG;AAAe;AAA0B;AACnC;AACE;AAAe;;AAC1B,SAHgB,0BAGhB,CAFE,WAEF,EADE,YACF,EAAyD;AAAA,MAAvD,gBAAuD,uEAA5B,4BAA4B;AAEvD,SAAO,WAAW,CAAC,IAAZ,CACL,UAAU;AAAA;AAAM;AACJ;AAAmB;AADpB,YAAC,KAAD,EAAM;AACf,QAAI,YAAJ,EAAkB,YAAY,CAAC,WAAb,CAAyB,KAAzB;;AAClB,QAAI,gBAAgB,IAAI,CAAxB,EAA2B;AACzB,aAAO,WAAP,CADyB,CACN;AACpB,KAJc,CAKrB;;;AACM,WAAO,0BAA0B,CAC/B,WAD+B,EAE/B,YAF+B,EAG/B,gBAAgB,GAAG,CAHY,CAAjC;AAKD,GAXS,CADL,CAAP;AAcF;AACC;AAAI;AAAkC;AAAkC;AAAsI;;AAAI;AAAI;AAAe;;;ICrBzN,O;;;;;AACb;AAAQ;AAA0B;AAAhC,mBAA2C,MAA3C,EAAiE;AAAA;;AAAA;;AAC/D;;AAEA,QAAI,MAAJ,EAAY;AACV,YAAK,MAAL,GAAc,MAAd;AACD;;AAL8D;AAMhE;AACH;AACO;AAAmB;AAC1B;AAAmB;;;;;WADjB,cAAQ,QAAR,EAAgC;AAAI;AAC5B,UAAA,UAAU,GAAG,IAAI,OAAJ,EAAb;AACN,MAAA,UAAU,CAAC,MAAX,GAAoB,IAApB;AACA,MAAA,UAAU,CAAC,QAAX,GAAsB,QAAtB;AACA,aAAO,UAAP;AACD;;;;EAdsC,U;;wBADxC,e,CAAA,C,EAAA;AAAU,SAAA,KAAA,CAAA,IAAA,OAAA,EAAA,MAAA,CAAA,QAAA,CAAA,qBAAA,CAAA,CAAA;AAAA,C;;;;mBACT;;AAAC;;AAAmB,OAAA,CAAA,cAAA,GAAA;AAAA,SAAA,CAAiC;AAAA,IAAA,IAAA,EAJ9C,UAI8C;AAJpC,IAAA,UAAA,EAAA,CAAA;AAAA,MAAA,IAAA,EAKJ,MALI;AAKE,MAAA,IAAA,EAAA,CAAC,qBAAD;AALF,KAAA;AAIoC,GAAjC,CAAA;AAAA,CAAA;;;;;;;;;;;;;;;;AAC+B,C;AAAC;AAAI;AAGvD;AACH;;;AAAI,SAsGY,MAtGZ,GAuG6D;AAAA,oCAA5D,YAA4D;AAA5D,IAAA,YAA4D;AAAA;;AAE/D,SAAO,MAAM;AAAA;AAAM;AACX;AAAmB;AADb,YAAC,MAAD;AAAA,WACZ,YAAY,CAAC,IAAb;AAAiB;AAAM;AACX;AAAmB;AADb,cAAC,mBAAD,EAAoB;AACpC,UAAI,OAAO,mBAAP,KAA+B,QAAnC,EAA6C;AACnD;AACQ,eAAO,mBAAmB,KAAK,MAAM,CAAC,IAAtC;AACD,OAJmC,CAK1C;;;AAEM,aAAO,mBAAmB,CAAC,IAApB,KAA6B,MAAM,CAAC,IAA3C;AACD,KARD,CADY;AAAA,GAAD,CAAb;AAWF;AACC;AAAI;AAAkC;AAA8C;AAAsI;;AAAI;AAAI;AAAW;;;AAAI,SAAA,kBAAA,GAAA,CC3HjP;;AACD,IAAA,KAAA,EAAA;AACY;AAPV,EAAA,kBAAA,CAAA,SAAA,CAAA,MAAA;AACF;;AAAE,EAAA,kBAAA,CAAA,SAAA,CAAA,YAAA;AACF;;AAAE,EAAA,kBAAA,CAAA,SAAA,CAAA,UAAA;AACF;;AAAE,EAAA,kBAAA,CAAA,SAAA,CAAA,cAAA;AACF;;AAAE,EAAA,kBAAA,CAAA,SAAA,CAAA,YAAA;AACF;AACA;AACG;AAAqB;AACf;AAAe;;;AAAI,SADZ,oBACY,CAA1B,MAA0B,EAC1B,QAD0B,EACJ;AAEtB,MAAI,MAAM,CAAC,YAAP,CAAoB,IAApB,KAA6B,GAAjC,EAAsC;AACxC;AAAyB,QAAf,MAAM,GAAG,MAAM,CAAC,YAAP,CAAoB,KAAd;AACzB;;AAAyB,QAAf,eAAe,GAAG,CAAC,QAAQ,CAAC,MAAD,CAAZ;;AAErB,QAAI,eAAJ,EAAqB;AACnB,MAAA,QAAQ,CAAC,WAAT,CACE,IAAI,KAAJ,kBACY,aAAa,CACrB,MADqB,CADzB,4CAGqC,SAAS,CAAC,MAAD,CAH9C,EADF;AAOD;AACF;AACF;AACD;AACG;AAAqB;AAAe;;;AAAvC,SAAS,QAAT,CAAkB,MAAlB,EAA6B;AAC3B,SACE,OAAO,MAAP,KAAkB,UAAlB,IACA,MADA,IAEA,MAAM,CAAC,IAFP,IAGA,OAAO,MAAM,CAAC,IAAd,KAAuB,QAJzB;AAMD;AACD;AACG;AAAkB;AACV;;;AADX,SAAS,aAAT,QAIqB;AAAA,MAHnB,YAGmB,SAHnB,YAGmB;AAAA,MAFnB,cAEmB,SAFnB,cAEmB;AAAA,MADnB,UACmB,SADnB,UACmB;;AACrB;AAAqB,MAAb,QAAQ,GAAG,OAAO,cAAc,CAAC,YAAD,CAArB,KAAwC,UAAtC;AAEnB,qBAAW,UAAX,cAAyB,MAAM,CAAC,YAAD,CAA/B,SAAgD,QAAQ,GAAG,IAAH,GAAU,EAAlE;AACD;AACD;AACG;AAAqB;AAAe;;;AAAvC,SAAS,SAAT,CAAmB,MAAnB,EAAoD;AAClD,MAAI;AACF,WAAO,IAAI,CAAC,SAAL,CAAe,MAAf,CAAP;AACD,GAFD,CAEE,OAAA,EAAA,EAAM;AACN,WAAO,MAAP;AACD;AACH;AACC;AAAI;AAAkC;AAA0C;AAAsI;;AAAI;;;AAAiB,ICtB/N,oBAAoB,GAC/B,uBDqB0O;ACpB5O;AACG;AAAuB;AACtB;;AAAI,SADQ,mBACR,CAAN,QAAM,EAAO;AAEb,SAAO,UAAU,CAAC,QAAD,EAAW,oBAAX,CAAjB;AACD;AACD;;;AAEY,IAoCC,eAAe,GAAuB,kBApCvC;AAqCZ;AACG;AAAuB;AAAe;;AAAI,SAA7B,cAA6B,CAAd,QAAc,EAAD;AAC1C,SAAO,UAAU,CAAC,QAAD,EAAW,eAAX,CAAjB;AACD;AACD;;;AAEY,IA2BC,aAAa,GAAwB,mBA3BtC;AA4BZ;AACG;AAAuB;AAAe;;AAAI,SAA7B,eAA6B,CAAb,QAAa,EAAA;AAC3C,SAAO,UAAU,CAAC,QAAD,EAAW,aAAX,CAAjB;AACD;AACD;AACG;AAAuB;AAA2B;AAC5C;;;AADT,SAAS,UAAT,CAAoB,QAApB,EAAmC,YAAnC,EAAuD;AACrD,SACE,QAAQ,IACR,YAAY,IAAI,QADhB,IAEA,OAAO,QAAQ,CAAC,YAAD,CAAf,KAAkC,UAHpC;AAKF;AACC;AAAI;AAAkC;AAAiC;AAAsI;;AAAI;;;AAAiB,IC9HtN,mBAAmB,GAAG,IAAI,cAAJ,CACjC,mCADiC,CD8HgM;AC5HjO;;;AACc,IAAH,iBAAiB,GAAG,IAAI,cAAJ,CAC/B,iCAD+B,CAAjB;AAGhB;;AAAiB,IAAJ,qBAAqB,GAAG,IAAI,cAAJ,CACnC,qCADmC,CAApB;AAEf;;AACc,IAAH,aAAa,GAAG,IAAI,cAAJ,CAC3B,qCAD2B,CAAb;AAEd;;;AACc,IAAH,YAAY,GAAG,IAAI,cAAJ,CAC1B,4BAD0B,CAAZ;AAEd;;AACc,IAAH,gBAAgB,GAAG,IAAI,cAAJ,CAC9B,wCAD8B,CAAhB;AAEd;;;AACc,IAAH,eAAe,GAAG,IAAI,cAAJ,CAC7B,+BAD6B,CAAf;AAEd;;AACc,IAAH,qBAAqB,GAAG,IAAI,cAAJ,CACnC,qCADmC,CAArB;AAGhB;AAAI;AAAkC;AAAyC;AAAsI;;ICKxM,a;;;;;AACb;AAAQ;AACgB;AACF;AAFpB,yBACU,YADV,EAGU,mBAHV,EAGkD;AAAA;;AAAA;;AAEhD;AAJQ,WAAA,YAAA,GAAA,YAAA;AAEA,WAAA,mBAAA,GAAA,mBAAA;AAAwC;AAGjD;AACH;AACO;AAAuC;AAC7B;;;;;WADf,oBAAW,oBAAX,EAAoC;AAClC,WAAK,IAAL,CAAU,oBAAV;AACD;AACH;AAEC;AACG;AACa;;;;WAAf,qBAAS;AAAA;;AACP,aAAO,KAAK,IAAL,CACL,OAAO,CAAC,oBAAD,CADF,EAEL,QAAQ;AAAA;AAAM;AACA;AAAuB;AAD5B,gBAAC,OAAD,EAAQ;AACf,eAAO,OAAO,CAAC,IAAR,CAAa,OAAO,CAAC,eAAD,CAApB,CAAP;AACD,OAFO,CAFH,EAKL,QAAQ;AAAA;AAAM;AACA;AACf;AAFU,gBAAC,OAAD,EAAQ;AACvB;AAA6B,YAAf,OAAO,GAAG,OAAO,CAAC,IAAR,CACd,UAAU;AAAA;AAAM;AACF;AACb;AAFU,kBAAC,cAAD,EAAe;AACxB,iBAAO,mBAAmB,CACxB,MAAI,CAAC,YADmB,EAExB,MAAI,CAAC,mBAFmB,CAAnB,CAGL,cAHK,CAAP;AAID,SALS,CADI,EAOd,GAAG;AAAA;AAAM;AACK;AAA2B;AADrC,kBAAC,MAAD,EAAO;AACT,UAAA,oBAAoB,CAAC,MAAD,EAAS,MAAI,CAAC,YAAd,CAApB;AACA,iBAAO,MAAM,CAAC,YAAd;AACD,SAHE,CAPW,EAWd,MAAM;AAAA;AACZ;AAAuC;AACzC;AADU,kBAAC,YAAD;AAAA,iBACE,YAAY,CAAC,IAAb,KAAsB,GADxB;AAAA,SADI,CAXQ,EAed,aAAa,EAfC,CAAK,CADN,CAkBvB;AAEG;;AACI;;AACP,YADc,KAAK,GAAG,OAAO,CAAC,IAAR,CACZ,IAAI,CAAC,CAAD,CADQ,EAEZ,MAAM,CAAC,eAAD,CAFM,EAGZ,GAAG;AAAA;AAAM;AAAmC;AAG3C;AAHG,kBAAC,QAAD;AAAA,iBAAc,QAAQ,CAAC,iBAAT,EAAd;AAAA,SAAD,CAHS,CACtB;AAKQ,eAAO,KAAK,CAAC,OAAD,EAAU,KAAV,CAAZ;AACD,OA5BO,CALH,CAAP;AAmCD;;;;EApDgC,O;;8BADlC,qB,CAAU,C,EAAA;AAAA,SAAA,KAAA,CAAA,IAAA,aAAA,EAAA,MAAA,CAAA,QAAA,CAAA,MAAA,CAAA,YAAA,CAAA,EAAA,MAAA,CAAA,QAAA,CAAA,qBAAA,CAAA,CAAA;AAAA,C;;;;yBACT;;AAAC;;AAAmB,aAAA,CAAA,cAAA,GAAA;AAAA,SAAA,CACX;AAAA,IAAA,IAAA,EAjCF;AAiCE,GADW,EAhCG;AAAA,IAAA,IAAA,EAAA,SAAA;AAAA,IAAA,UAAA,EAAA,CAAA;AAAA,MAAA,IAAA,EAmCpB,MAnCoB;AAmCd,MAAA,IAAA,EAAA,CAAC,qBAAD;AAnCc,KAAA;AAAA,GAgCH,CAAA;AAAA,CAAA;;;;;;;;;;;;;;;;;;AAId,C;;AAAC,IAAA,KAAA,EAAA;AAAa;AAAQ;AAAiB;AAE3C;AAJA,EAAA,aAAA,CAAA,SAAA,CAAA,YAAA;AAAmC;AAChC;AAAiB;AACnB;;AADD,EAAA,aAAA,CAAA,SAAA,CAAA,mBAAA;AAEJ;AAAE;AACF;AAGW;AAAe;;;AA8C1B,SAAS,eAAT,CAAyB,cAAzB,EAA4C;AAC1C,MAAI,mBAAmB,CAAC,cAAD,CAAvB,EAAyC;AACvC,WAAO,cAAc,CAAC,qBAAf,EAAP;AACD;;AAED,SAAO,EAAP;AACD;AACD;AACG;AACH;AACI;AAAe;;;AAFnB,SAAS,mBAAT,CACE,YADF,EAEE,mBAFF,EAE0C;AAExC;AAAA;AAAY;AACE;AAAmB;AAD1B,cAAC,cAAD,EAAe;AACxB;AAAyB,UAAf,cAAc,GAAG,YAAY,CACjC,cADiC,EAEjC,YAFiC,EAGjC,mBAHiC,CAAd;;AAMrB,UAAI,cAAc,CAAC,cAAD,CAAlB,EAAoC;AAClC,eAAO,cAAc,CAAC,gBAAf,CAAgC,cAAhC,CAAP;AACD;;AAED,aAAO,cAAP;AACD;AAZD;AAaF;AACC;AAAI;AAAkC;AAAyC;AAAsI;;;IC1GzM,a;AAAgB;AAAQ;AAClB;AAAwB;AAEzC,yBACU,aADV,EAEU,KAFV,EAE2B;AAAA;;AADjB,SAAA,aAAA,GAAA,aAAA;AACA,SAAA,KAAA,GAAA,KAAA;AAJF,SAAA,mBAAA,GAA2C,IAA3C;AAKJ;AACN;AACO;AACO;;;;;WADZ,iBAAK;AACH,UAAI,CAAC,KAAK,mBAAV,EAA+B;AAC7B,aAAK,mBAAL,GAA2B,KAAK,aAAL,CACxB,SADwB,GAExB,SAFwB,CAEd,KAAK,KAFS,CAA3B;AAGD;AACF;AACH;AACO;AACC;;;;WADN,uBAAW;AACT,UAAI,KAAK,mBAAT,EAA8B;AAC5B,aAAK,mBAAL,CAAyB,WAAzB;AACA,aAAK,mBAAL,GAA2B,IAA3B;AACD;AACF;;;;;;8BAtBF,qB,CAAU,C,EAAA;AAAA,SAAA,KAAA,CAAA,IAAA,aAAA,EAAA,MAAA,CAAA,QAAA,CAAA,aAAA,CAAA,EAAA,MAAA,CAAA,QAAA,CAAA,MAAA,CAAA,KAAA,CAAA,CAAA;AAAA,C;;;;yBACT;;AAAC;;AAAmB,aAAA,CAAA,cAAA,GAAA;AAAA,SAAA,CACX;AAAA,IAAA,IAAA,EAJF;AAIE,GADW,EAHI;AAAA,IAAA,IAAA,EAHjB;AAGiB,GAGJ,CAAA;AAAA,CAAA;;;;;;;;;;;;;;AANH,C;;AAAC,IAAA,KAAA,EAAA;AAAa;AAC7B;AAAiB;AACrB;AAKE,EAAA,aAAA,CAAA,SAAA,CAAA,mBAAA;AACF;AACO;AACE;AAAgB;;AAArB,EAAA,aAAA,CAAA,SAAA,CAAA,aAAA;AAAqC;AAClC;AAAiB;AAGtB;;AAHE,EAAA,aAAA,CAAA,SAAA,CAAA,KAAA;AACJ;AAAG;AACH;AAEqB;AACS;AAOA;;AAAI;;;AACnB,ICbF,iBAAiB,GAAG,oBDalB;ACZf;;AAAiB,IAAJ,eAAe,GAAG,YAAY,CAAC,iBAAD,CAA1B;;IAGJ,iB;AACb;AAAQ;AACW;AACX;AACH;AACO;AACZ;AAAqC;AAC1B;AANT,6BACU,OADV,EAEE,MAFF,EAGE,KAHF,EAIwB,WAJxB,EAKc,eALd,EAMc,kBANd,EASE,KATF,EASY;AAAA;;AARF,SAAA,OAAA,GAAA,OAAA;AAUR,IAAA,MAAM,CAAC,KAAP;AAEA,IAAA,WAAW,CAAC,OAAZ;AAAmB;AAAM;AACP;AAAuB;AADrB,cAAC,oBAAD;AAAA,aAClB,OAAO,CAAC,UAAR,CAAmB,oBAAnB,CADkB;AAAA,KAApB;AAIA,IAAA,KAAK,CAAC,QAAN,CAAe;AAAE,MAAA,IAAI,EAAE;AAAR,KAAf;AACD;AACH;AACO;AACH;AAAmB;;;;;WADrB,oBAAW,oBAAX,EAAoC;AAClC,WAAK,OAAL,CAAa,UAAb,CAAwB,oBAAxB;AACD;;;;;;gCAxBF,gB,CAAA;AAAA,EAAA,IAAQ,EAAA;AAAR,C;;;;AACI;;AAAC;;AAAmB,iBAAA,CAAA,cAAA,GAAA;AAAA,SAAA,CAEL;AAAA,IAAA,IAAA,EATX;AASW,GAFK,EAPC;AAAA,IAAA,IAAA,EADjB;AACiB,GAOD,EARC;AAAA,IAAA,IAAA,EAJxB;AAIwB,GAQD,EAXvB;AAAA,IAAA,IAAA,EAAA,KAAA;AAAA,IAAA,UAAA,EAAA,CAAA;AAAA,MAAA,IAAA,EAgBG,MAhBH;AAgBS,MAAA,IAAA,EAAA,CAAC,YAAD;AAhBT,KAAA;AAAA,GAWuB,EAKQ;AAAA,IAAA,IAAA,EAhB/B,eAgB+B;AAhBhB,IAAA,UAAA,EAAA,CAAA;AAAA,MAAA,IAAA,EAiBZ;AAjBY,KAAA;AAgBgB,GALR,EAML;AAAA,IAAA,IAAA,EAhBlB,kBAgBkB;AAhBA,IAAA,UAAA,EAAA,CAAA;AAAA,MAAA,IAAA,EAiBf;AAjBe,KAAA;AAgBA,GANK,EAOL;AAAA,IAAA,IAAA,EAAA,SAAA;AAAA,IAAA,UAAA,EAAA,CAAA;AAAA,MAAA,IAAA,EACf;AADe,KAAA,EACP;AAAA,MAAA,IAAA,EACR,MADQ;AACF,MAAA,IAAA,EAAA,CAAC,mBAAD;AADE,KADO;AAAA,GAPK,CAAA;AAAA,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAUjB,C;;AAAC,IAAA,KAAA,EAAA;AAER;AAAQ;AAEJ;AAAgB;AAZjB,EAAA,iBAAA,CAAA,SAAA,CAAA,OAAA;AAA+B;AACjC;AAAI;AACO;AAC0B;AAIlC;;;ICnBQ,oB;AACb;AAAQ;AACQ;AACQ;AACxB;AAAqC;AAHnC,8BACE,IADF,EAE2B,kBAF3B,EAGc,eAHd,EAIc,kBAJd,EAIoD;AAAA;;AAElD,EAAA,kBAAkB,CAAC,OAAnB;AAA0B;AAAM;AACd;AAAuB;AADd,YAAC,KAAD;AAAA,WACzB,KAAK,CAAC,OAAN;AAAa;AAAM;AACH;AAAuB;AADzB,cAAC,oBAAD;AAAA,aACZ,IAAI,CAAC,UAAL,CAAgB,oBAAhB,CADY;AAAA,KAAd,CADyB;AAAA,GAA3B;AAKD,C;;mCAbF,gB,CAAA;AAAA,EAAA,IAAQ,EAAA;AAAR,C;;;;AACI;;AAAC;;AAAmB,oBAAA,CAAA,cAAA,GAAA;AAAA,SAAA,CAEL;AAAA,IAAA,IAAA,EANX;AAMW,GAFK,EAJK;AAAA,IAAA,IAAA,EAAA,KAAA;AAAA,IAAA,UAAA,EAAA,CAAA;AAAA,MAAA,IAAA,EAOzB,MAPyB;AAOnB,MAAA,IAAA,EAAA,CAAC,eAAD;AAPmB,KAAA;AAAA,GAIL,EAGW;AAAA,IAAA,IAAA,EAR3B,eAQ2B;AARZ,IAAA,UAAA,EAAA,CAAA;AAAA,MAAA,IAAA,EASnB;AATmB,KAAA;AAQY,GAHX,EAIL;AAAA,IAAA,IAAA,EATM,kBASN;AATwB,IAAA,UAAA,EAAA,CAAA;AAAA,MAAA,IAAA,EAUvC;AAVuC,KAAA;AASxB,GAJK,CAAA;AAAA,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAKJ,C;AAAE;AAAI;AAE3B;AAAyC;AAOrB;;;ICMP,a;;;;;;;;AACb;AAAQ;AACa;AAClB;AAFD,0BACkC;AAAA,UAAhC,cAAgC,uEAAF,EAAE;AAEhC,aAAO;AACL,QAAA,QAAQ,EAAE,oBADL;AAEL,QAAA,SAAS,EAAE,CACT,cADS,EAET;AACE,UAAA,OAAO,EAAE,gBADX;AAEE,UAAA,KAAK,EAAE,IAFT;AAGE,UAAA,QAAQ,EAAE;AAHZ,SAFS,EAOT;AACE,UAAA,OAAO,EAAE,qBADX;AAEE,UAAA,KAAK,EAAE,IAFT;AAGE,UAAA,QAAQ,EAAE;AAHZ,SAPS,EAYT;AACE,UAAA,OAAO,EAAE,eADX;AAEE,UAAA,KAAK,EAAE,IAFT;AAGE,UAAA,UAAU,EAAE,aAHd;AAIE,UAAA,IAAI,EAAE,CAAC,QAAD,EAAW,gBAAX,EAA6B,qBAA7B;AAJR,SAZS;AAFN,OAAP;AAsBD;AACH;AACO;AACa;AACf;;;;WAFH,mBAC+B;AAAA,UAA7B,WAA6B,uEAAF,EAAE;AAE7B,aAAO;AACL,QAAA,QAAQ,EAAE,iBADL;AAEL,QAAA,SAAS,EAAE,CACT;AACE,UAAA,OAAO,EAAE,qBADX;AAEE,UAAA,QAAQ,EAAE;AAFZ,SADS,EAKT,aALS,EAMT,aANS,EAOT,OAPS,EAQT,WARS,EAST;AACE,UAAA,OAAO,EAAE,aADX;AAEE,UAAA,QAAQ,EAAE,CAAC,WAAD;AAFZ,SATS,EAaT;AACE,UAAA,OAAO,EAAE,mBADX;AAEE,UAAA,UAAU,EAAE,oBAFd;AAGE,UAAA,IAAI,EAAE,CACJ,CAAC,aAAD,EAAgB,IAAI,QAAJ,EAAhB,EAAgC,IAAI,QAAJ,EAAhC,CADI,EAEJ,CAAC,aAAD,EAAgB,IAAI,IAAJ,EAAhB,CAFI;AAHR,SAbS,EAqBT;AACE,UAAA,OAAO,EAAE,qBADX;AAEE,UAAA,KAAK,EAAE,IAFT;AAGE,UAAA,QAAQ,EAAE;AAHZ,SArBS,EA0BT;AACE,UAAA,OAAO,EAAE,YADX;AAEE,UAAA,UAAU,EAAE,aAFd;AAGE,UAAA,IAAI,EAAE,CAAC,QAAD,EAAW,aAAX,EAA0B,qBAA1B;AAHR,SA1BS;AAFN,OAAP;AAmCD;;;;;;4BAnEF,gB,CAAA;AAAA,EAAA,IAAQ,EAAA;AAAR,C;;;;;;;;;;;;;AACI,C;AAAC;AAAI;AACN;AACM;AACE;AAAe;;;AAAI,SAkEf,aAlEe,CAmE7B,QAnE6B,EAoE7B,YApE6B,EAqE7B,wBArE6B,EAqEU;AACtC;AACU,MAAL,aAAa,GAAgB,EAAxB;;AAF4B,6CAIf,YAJe;AAAA;;AAAA;AAIvC,wDAAsC;AAAA,UAA7B,WAA6B;AACpC,MAAA,aAAa,CAAC,IAAd,OAAA,aAAa,qBAAS,WAAT,EAAb;AACD;AANsC;AAAA;AAAA;AAAA;AAAA;;AAAA,8CAQH,wBARG;AAAA;;AAAA;AAQvC,2DAA8D;AAAA,UAArD,uBAAqD;AAC5D,MAAA,aAAa,CAAC,IAAd,OAAA,aAAa,qBAAS,uBAAT,EAAb;AACD;AAVsC;AAAA;AAAA;AAAA;AAAA;;AAYvC,SAAO,qBAAqB,CAAC,QAAD,EAAW,aAAX,CAA5B;AACD;AACD;AACG;AAAuB;AACjB;AACP;;;AAAI,SAFU,qBAEV,CADJ,QACI,EAAJ,OAAI,EAAgB;AAEpB,SAAO,OAAO,CAAC,GAAR;AAAW;AAAM;AAAyB;AAGxC;AAHU,YAAC,MAAD;AAAA,WAAY,QAAQ,CAAC,GAAT,CAAa,MAAb,CAAZ;AAAA,GAAZ,CAAP;AACD;AACD;AACG;AAAqB;AACZ;AACV;;;AAAI,SAFU,oBAEV,CADJ,MACI,EAAJ,WAAI,EAAgB;AACnB;;AAC4C;AAC9B,MAAT,UAAU,GAAG,EAAE,WAAW,CAAC,MAAZ,KAAuB,CAAvB,IAA4B,WAAW,CAAC,CAAD,CAAX,CAAe,MAAf,KAA0B,CAAxD,CAAJ;;AACf,MAAI,UAAU,IAAI,MAAlB,EAA0B;AACxB,UAAM,IAAI,SAAJ,wGAAN;AAGD;;AACD,SAAO,SAAP;AACF;AACC;AAAI;AAAkC;AAA8B;AAAsI;;AAAI;AAAI;AAAqD;AAAW;AAAiF;;;AAAI,SAAA,SAAA,GAAA,CCzFvW;;AACD,IAAA,KAAA,EAAA;AAEQ;AApBN,EAAA,SAAA,CAAA,SAAA,CAAA,OAAA;AACF;;AAGE,EAAA,SAAA,CAAA,SAAA,CAAA,KAAA;AACF;;AAGE,EAAA,SAAA,CAAA,SAAA,CAAA,QAAA;AACF;;AACE,EAAA,SAAA,CAAA,SAAA,CAAA,QAAA;AAGF;;AAGE,EAAA,SAAA,CAAA,SAAA,CAAA,WAAA;AACF;AACA;AACG;AAEG;AAA8B;AAAuB;AAAe;;;AAAI,SA8B9D,GA9B8D;AAqC5E;AACA,eAtC4E,EA+C5E,OA/C4E,EA+CzB;AAClD,cAMC,OAAO,eAAP,KAA2B,UAA3B,GACI;AACE,IAAA,OAAO,EAAE,eADX;AAEE,IAAA,KAAK;AAAA;AAAE,IAAA,OAFT;AAGE,IAAA,QAAQ,EAAE,SAHZ;AAIE,IAAA,QAAQ,EAAE,SAJZ;AAKE,IAAA,WAAW,EAAE;AALf,GADJ,GAQJ,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,EAAA,EAAa,eAAb,CAAA,EAA4B;AAAE,IAAA,QAAQ,EAAE,eAAe,CAAC,QAAhB,IAA4B;AAAxC,GAA5B,CAdG;AAAA,MAKO,OALP,SAKO,OALP;AAAA,MAKgB,KALhB,SAKgB,KALhB;AAAA,MAKuB,QALvB,SAKuB,QALvB;AAAA,MAKiC,QALjC,SAKiC,QALjC;AAAA,MAK2C,WAL3C,SAK2C,WAL3C;;AAqBD;AAAA;AAAY;AAEP;AAAmB;AAFjB,cAAC,MAAD;AAAA,aACL,KAAK;AAAA;AACL;AAAmB;AAAjB,kBAAA;AAAQ;AAAyB,YACzB,OAAO,GAAG,IAAI,OAAJ,EADe;AAE/B,eAAO,KAAK,CACV,MAAM,CAAC,IAAP,CACE,QAAQ;AAAA;AAAM;AACX;AACA;AAAuB;AAFjB,kBAAC,KAAD,EAAQ,KAAR;AAAA,iBACP,KAAK;AAAA;AAAM;AACL;AADA,sBAAA;AACpB;AAA6B,gBAAT,SAAS,GAAG,KAAH;AAC7B;;AAA6B,gBAAT,OAAO,GAAG,KAAD;AAC7B;;AAA6B,gBAAT,cAAc,GAAG,CAAR;AACb,mBAAO,OAAO,CAAC,KAAD,EAAQ,KAAR,CAAP,CAAsB,IAAtB,CACL,WAAW,EADN,EAEL,GAAG;AAAA;AAAM;AACC;AACtB;AAFgB,sBAAC,YAAD,EAAa;AAGf,sBAAQ,YAAY,CAAC,IAArB;AACE,qBAAK,GAAL;AACE,kBAAA,OAAO,GAAG,IAAV;AACA,yBAAO,IAAI,YAAJ;AAAgB;AAC5B;AACO,qBAFK,EAGL,KAAK,CAAC,YAAY,CAAC,KAAd,EAAqB,KAArB,CAHA,CAAP;;AAKF,qBAAK,GAAL;AACE,kBAAA,SAAS,GAAG,IAAZ;AACA,yBAAO,QAAQ,GACX,IAAI,YAAJ;AAAgB;AACzB;AACW,qBAFF,EAGE,QAAQ,CAAC,cAAD,EAAiB,KAAjB,CAHV,CADW,GAMX,SANJ;;AAOF;AACE,oBAAE,cAAF;AACA,yBAAO,YAAP;AAnBJ;AAqBD,aAxBE,CAFE,EA2BL,MAAM;AAAA;AAAM;AAA4B;AAC7C;AADY,sBAAC,CAAD;AAAA,qBAAmC,CAAC,IAAI,IAAxC;AAAA,aAAD,CA3BD,EA4BL,aAAa,EA5BR,EA6BL,QAAQ;AAAA;AAAM;AACR;AADG,wBAAA;AACP,kBAAI,CAAC,SAAD,IAAc,CAAC,OAAf,IAA0B,WAA9B,EAA2C;AACzC,gBAAA,OAAO,CAAC,IAAR,CAAa,WAAW,CAAC,cAAD,EAAiB,KAAjB,CAAxB;AACD;AACF,aAJO,CA7BH,CAAP;AAmCD,WAvCI,CADE;AAAA,SAAD,CADV,CADU,EA6CV,OA7CU,CAAZ;AA+CD,OAlDE,CADA;AAAA;AAAP;AAqDF;AACC;AAAI;AAAkC;AAAgC;AAAsI;;AAAK;AAAI;AAAkC;AAAiC;AAAsI;;AAAK;AAAI;AAAkC;AAA4B;AAAsI;;AAAK;AAAI;AAAkC;AAAmC;AAAsI;;;AAAK,SAAA,OAAA,EAAA,qBAAA,EAAA,MAAA,EAAA,aAAA,EAAA,oBAAA,EAAA,aAAA,EAAA,iBAAA,EAAA,aAAA,EAAA,iBAAA,EAAA,qBAAA,EAAA,GAAA,EAAA,YAAA,EAAA,0BAAA,EAAA,kBAAA,EAAA,YAAA,EAAA,MAAA,EAAA,eAAA,EAAA,iBAAA,IAAA,EAAA,EAAA,aAAA,IAAA,EAAA,EAAA,oBAAA,IAAA,EAAA,EAAA,mBAAA,IAAA,EAAA,EAAA,aAAA,IAAA,EAAA,EAAA,YAAA,IAAA,EAAA,EAAA,gBAAA,IAAA,EAAA,EAAA,eAAA,IAAA,EAAA","sourcesContent":["/**\n * Configures an effect created by `createEffect`.\n */\nexport interface EffectConfig {\n  /**\n   * Determines if the action emitted by the effect is dispatched to the store.\n   * If false, effect does not need to return type `Observable<Action>`.\n   */\n  dispatch?: boolean;\n  /**\n   * Determines if the effect will be resubscribed to if an error occurs in the main actions stream.\n   */\n  useEffectsErrorHandler?: boolean;\n}\n\nexport const DEFAULT_EFFECT_CONFIG: Readonly<Required<EffectConfig>> = {\n  dispatch: true,\n  useEffectsErrorHandler: true,\n};\n\nexport const CREATE_EFFECT_METADATA_KEY = '__@ngrx/effects_create__';\n\nexport interface CreateEffectMetadata {\n  [CREATE_EFFECT_METADATA_KEY]: EffectConfig;\n}\n\nexport type EffectPropertyKey<T extends Object> = Exclude<\n  keyof T,\n  keyof Object\n>;\n\nexport interface EffectMetadata<T extends Object>\n  extends Required<EffectConfig> {\n  propertyName: EffectPropertyKey<T>;\n}\n\nexport type EffectsMetadata<T> = {\n  [key in EffectPropertyKey<T>]?: EffectConfig;\n};\n","import { Observable } from 'rxjs';\nimport { Action, ActionCreator } from '@ngrx/store';\nimport {\n  EffectMetadata,\n  EffectConfig,\n  DEFAULT_EFFECT_CONFIG,\n  CreateEffectMetadata,\n  CREATE_EFFECT_METADATA_KEY,\n} from './models';\n\ntype DispatchType<T> = T extends { dispatch: infer U } ? U : true;\ntype ObservableType<T, OriginalType> = T extends false ? OriginalType : Action;\ntype EffectResult<OT> = Observable<OT> | ((...args: any[]) => Observable<OT>);\ntype ConditionallyDisallowActionCreator<DT, Result> = DT extends false\n  ? unknown // If DT (DispatchType is false, then we don't enforce any return types)\n  : Result extends EffectResult<infer OT>\n  ? OT extends ActionCreator\n    ? 'ActionCreator cannot be dispatched. Did you forget to call the action creator function?'\n    : unknown\n  : unknown;\n\n/**\n * @description\n * Creates an effect from an `Observable` and an `EffectConfig`.\n *\n * @param source A function which returns an `Observable`.\n * @param config A `Partial<EffectConfig>` to configure the effect.  By default, `dispatch` is true and `useEffectsErrorHandler` is true.\n * @returns If `EffectConfig`#`dispatch` is true, returns `Observable<Action>`.  Else, returns `Observable<unknown>`.\n *\n * @usageNotes\n *\n * ** Mapping to a different action **\n * ```ts\n * effectName$ = createEffect(\n *   () => this.actions$.pipe(\n *     ofType(FeatureActions.actionOne),\n *     map(() => FeatureActions.actionTwo())\n *   )\n * );\n * ```\n *\n *  ** Non-dispatching effects **\n * ```ts\n * effectName$ = createEffect(\n *   () => this.actions$.pipe(\n *     ofType(FeatureActions.actionOne),\n *     tap(() => console.log('Action One Dispatched'))\n *   ),\n *   { dispatch: false }\n *   // FeatureActions.actionOne is not dispatched\n * );\n * ```\n */\nexport function createEffect<\n  C extends EffectConfig,\n  DT extends DispatchType<C>,\n  OT extends ObservableType<DT, OT>,\n  R extends EffectResult<OT>\n>(\n  source: () => R & ConditionallyDisallowActionCreator<DT, R>,\n  config?: Partial<C>\n): R & CreateEffectMetadata {\n  const effect = source();\n  const value: EffectConfig = {\n    ...DEFAULT_EFFECT_CONFIG,\n    ...config, // Overrides any defaults if values are provided\n  };\n  Object.defineProperty(effect, CREATE_EFFECT_METADATA_KEY, {\n    value,\n  });\n  return effect as typeof effect & CreateEffectMetadata;\n}\n\nexport function getCreateEffectMetadata<\n  T extends { [props in keyof T]: Object }\n>(instance: T): EffectMetadata<T>[] {\n  const propertyNames = Object.getOwnPropertyNames(instance) as Array<keyof T>;\n\n  const metadata: EffectMetadata<T>[] = propertyNames\n    .filter(\n      (propertyName) =>\n        instance[propertyName] &&\n        instance[propertyName].hasOwnProperty(CREATE_EFFECT_METADATA_KEY)\n    )\n    .map((propertyName) => {\n      const metaData = (instance[propertyName] as any)[\n        CREATE_EFFECT_METADATA_KEY\n      ];\n      return {\n        propertyName,\n        ...metaData,\n      };\n    });\n\n  return metadata;\n}\n","export function getSourceForInstance<T>(instance: T): T {\n  return Object.getPrototypeOf(instance);\n}\n","import { compose } from '@ngrx/store';\n\nimport {\n  DEFAULT_EFFECT_CONFIG,\n  EffectConfig,\n  EffectMetadata,\n  EffectPropertyKey,\n} from './models';\nimport { getSourceForInstance } from './utils';\n\nconst METADATA_KEY = '__@ngrx/effects__';\n\nexport function Effect(config: EffectConfig = {}) {\n  return function <T extends Object, K extends EffectPropertyKey<T>>(\n    target: T,\n    propertyName: K\n  ) {\n    const metadata: EffectMetadata<T> = {\n      ...DEFAULT_EFFECT_CONFIG,\n      ...config, // Overrides any defaults if values are provided\n      propertyName,\n    };\n    addEffectMetadataEntry<T>(target, metadata);\n  };\n}\n\nexport function getEffectDecoratorMetadata<T>(\n  instance: T\n): EffectMetadata<T>[] {\n  const effectsDecorators: EffectMetadata<T>[] = compose(\n    getEffectMetadataEntries,\n    getSourceForInstance\n  )(instance);\n\n  return effectsDecorators;\n}\n\n/**\n * Type guard to detemine whether METADATA_KEY is already present on the Class\n * constructor\n */\nfunction hasMetadataEntries<T extends Object>(\n  sourceProto: T\n): sourceProto is typeof sourceProto & {\n  constructor: typeof sourceProto.constructor & {\n    [METADATA_KEY]: EffectMetadata<T>[];\n  };\n} {\n  return sourceProto.constructor.hasOwnProperty(METADATA_KEY);\n}\n\n/** Add Effect Metadata to the Effect Class constructor under specific key */\nfunction addEffectMetadataEntry<T extends object>(\n  sourceProto: T,\n  metadata: EffectMetadata<T>\n) {\n  if (hasMetadataEntries(sourceProto)) {\n    sourceProto.constructor[METADATA_KEY].push(metadata);\n  } else {\n    Object.defineProperty(sourceProto.constructor, METADATA_KEY, {\n      value: [metadata],\n    });\n  }\n}\n\nfunction getEffectMetadataEntries<T extends object>(\n  sourceProto: T\n): EffectMetadata<T>[] {\n  return hasMetadataEntries(sourceProto)\n    ? sourceProto.constructor[METADATA_KEY]\n    : [];\n}\n","import { EffectMetadata, EffectsMetadata } from './models';\nimport { getCreateEffectMetadata } from './effect_creator';\nimport { getEffectDecoratorMetadata } from './effect_decorator';\n\nexport function getEffectsMetadata<T>(instance: T): EffectsMetadata<T> {\n  return getSourceMetadata(instance).reduce(\n    (\n      acc: EffectsMetadata<T>,\n      { propertyName, dispatch, useEffectsErrorHandler }\n    ) => {\n      acc[propertyName] = { dispatch, useEffectsErrorHandler };\n      return acc;\n    },\n    {}\n  );\n}\n\nexport function getSourceMetadata<T>(instance: T): EffectMetadata<T>[] {\n  const effects: Array<(instance: T) => EffectMetadata<T>[]> = [\n    getEffectDecoratorMetadata,\n    getCreateEffectMetadata,\n  ];\n\n  return effects.reduce<EffectMetadata<T>[]>(\n    (sources, source) => sources.concat(source(instance)),\n    []\n  );\n}\n","import { Action } from '@ngrx/store';\nimport { merge, Notification, Observable } from 'rxjs';\nimport { ignoreElements, map, materialize } from 'rxjs/operators';\n\nimport { EffectNotification } from './effect_notification';\nimport { getSourceMetadata } from './effects_metadata';\nimport { EffectsErrorHandler } from './effects_error_handler';\nimport { getSourceForInstance } from './utils';\nimport { ErrorHandler } from '@angular/core';\n\nexport function mergeEffects(\n  sourceInstance: any,\n  globalErrorHandler: ErrorHandler,\n  effectsErrorHandler: EffectsErrorHandler\n): Observable<EffectNotification> {\n  const sourceName = getSourceForInstance(sourceInstance).constructor.name;\n\n  const observables$: Observable<any>[] = getSourceMetadata(sourceInstance).map(\n    ({\n      propertyName,\n      dispatch,\n      useEffectsErrorHandler,\n    }): Observable<EffectNotification> => {\n      const observable$: Observable<any> =\n        typeof sourceInstance[propertyName] === 'function'\n          ? sourceInstance[propertyName]()\n          : sourceInstance[propertyName];\n\n      const effectAction$ = useEffectsErrorHandler\n        ? effectsErrorHandler(observable$, globalErrorHandler)\n        : observable$;\n\n      if (dispatch === false) {\n        return effectAction$.pipe(ignoreElements());\n      }\n\n      const materialized$ = effectAction$.pipe(materialize());\n\n      return materialized$.pipe(\n        map(\n          (notification: Notification<Action>): EffectNotification => ({\n            effect: sourceInstance[propertyName],\n            notification,\n            propertyName,\n            sourceName,\n            sourceInstance,\n          })\n        )\n      );\n    }\n  );\n\n  return merge(...observables$);\n}\n","import { ErrorHandler } from '@angular/core';\nimport { Action } from '@ngrx/store';\nimport { Observable } from 'rxjs';\nimport { catchError } from 'rxjs/operators';\n\nexport type EffectsErrorHandler = <T extends Action>(\n  observable$: Observable<T>,\n  errorHandler: ErrorHandler\n) => Observable<T>;\n\nconst MAX_NUMBER_OF_RETRY_ATTEMPTS = 10;\n\nexport function defaultEffectsErrorHandler<T extends Action>(\n  observable$: Observable<T>,\n  errorHandler: ErrorHandler,\n  retryAttemptLeft: number = MAX_NUMBER_OF_RETRY_ATTEMPTS\n): Observable<T> {\n  return observable$.pipe(\n    catchError((error) => {\n      if (errorHandler) errorHandler.handleError(error);\n      if (retryAttemptLeft <= 1) {\n        return observable$; // last attempt\n      }\n      // Return observable that produces this particular effect\n      return defaultEffectsErrorHandler(\n        observable$,\n        errorHandler,\n        retryAttemptLeft - 1\n      );\n    })\n  );\n}\n","import { Inject, Injectable } from '@angular/core';\nimport {\n  Action,\n  ActionCreator,\n  Creator,\n  ScannedActionsSubject,\n} from '@ngrx/store';\nimport { Observable, OperatorFunction, Operator } from 'rxjs';\nimport { filter } from 'rxjs/operators';\n\n@Injectable()\nexport class Actions<V = Action> extends Observable<V> {\n  constructor(@Inject(ScannedActionsSubject) source?: Observable<V>) {\n    super();\n\n    if (source) {\n      this.source = source;\n    }\n  }\n\n  lift<R>(operator: Operator<V, R>): Observable<R> {\n    const observable = new Actions<R>();\n    observable.source = this;\n    observable.operator = operator;\n    return observable;\n  }\n}\n\n// Module-private helper type\ntype ActionExtractor<\n  T extends string | AC,\n  AC extends ActionCreator<string, Creator>,\n  E\n> = T extends string ? E : ReturnType<Extract<T, AC>>;\n/**\n * 'ofType' filters an Observable of Actions into an observable of the actions\n * whose type strings are passed to it.\n *\n * For example, if `actions` has type `Actions<AdditionAction|SubstractionAction>`, and\n * the type of the `Addition` action is `add`, then\n * `actions.pipe(ofType('add'))` returns an `Observable<AdditionAction>`.\n *\n * Properly typing this function is hard and requires some advanced TS tricks\n * below.\n *\n * Type narrowing automatically works, as long as your `actions` object\n * starts with a `Actions<SomeUnionOfActions>` instead of generic `Actions`.\n *\n * For backwards compatibility, when one passes a single type argument\n * `ofType<T>('something')` the result is an `Observable<T>`. Note, that `T`\n * completely overrides any possible inference from 'something'.\n *\n * Unfortunately, for unknown 'actions: Actions' these types will produce\n * 'Observable<never>'. In such cases one has to manually set the generic type\n * like `actions.ofType<AdditionAction>('add')`.\n */\nexport function ofType<\n  AC extends ActionCreator<string, Creator>[],\n  U extends Action = Action,\n  V = ReturnType<AC[number]>\n>(...allowedTypes: AC): OperatorFunction<U, V>;\n\nexport function ofType<\n  E extends Extract<U, { type: T1 }>,\n  AC extends ActionCreator<string, Creator>,\n  T1 extends string | AC,\n  U extends Action = Action,\n  V = T1 extends string ? E : ReturnType<Extract<T1, AC>>\n>(t1: T1): OperatorFunction<U, V>;\nexport function ofType<\n  E extends Extract<U, { type: T1 | T2 }>,\n  AC extends ActionCreator<string, Creator>,\n  T1 extends string | AC,\n  T2 extends string | AC,\n  U extends Action = Action,\n  V = ActionExtractor<T1 | T2, AC, E>\n>(t1: T1, t2: T2): OperatorFunction<U, V>;\nexport function ofType<\n  E extends Extract<U, { type: T1 | T2 | T3 }>,\n  AC extends ActionCreator<string, Creator>,\n  T1 extends string | AC,\n  T2 extends string | AC,\n  T3 extends string | AC,\n  U extends Action = Action,\n  V = ActionExtractor<T1 | T2 | T3, AC, E>\n>(t1: T1, t2: T2, t3: T3): OperatorFunction<U, V>;\nexport function ofType<\n  E extends Extract<U, { type: T1 | T2 | T3 | T4 }>,\n  AC extends ActionCreator<string, Creator>,\n  T1 extends string | AC,\n  T2 extends string | AC,\n  T3 extends string | AC,\n  T4 extends string | AC,\n  U extends Action = Action,\n  V = ActionExtractor<T1 | T2 | T3 | T4, AC, E>\n>(t1: T1, t2: T2, t3: T3, t4: T4): OperatorFunction<U, V>;\nexport function ofType<\n  E extends Extract<U, { type: T1 | T2 | T3 | T4 | T5 }>,\n  AC extends ActionCreator<string, Creator>,\n  T1 extends string | AC,\n  T2 extends string | AC,\n  T3 extends string | AC,\n  T4 extends string | AC,\n  T5 extends string | AC,\n  U extends Action = Action,\n  V = ActionExtractor<T1 | T2 | T3 | T4 | T5, AC, E>\n>(t1: T1, t2: T2, t3: T3, t4: T4, t5: T5): OperatorFunction<U, V>;\n/**\n * Fallback for more than 5 arguments.\n * There is no inference, so the return type is the same as the input -\n * Observable<Action>.\n *\n * We provide a type parameter, even though TS will not infer it from the\n * arguments, to preserve backwards compatibility with old versions of ngrx.\n */\nexport function ofType<V extends Action>(\n  ...allowedTypes: Array<string | ActionCreator<string, Creator>>\n): OperatorFunction<Action, V>;\nexport function ofType(\n  ...allowedTypes: Array<string | ActionCreator<string, Creator>>\n): OperatorFunction<Action, Action> {\n  return filter((action: Action) =>\n    allowedTypes.some((typeOrActionCreator) => {\n      if (typeof typeOrActionCreator === 'string') {\n        // Comparing the string to type\n        return typeOrActionCreator === action.type;\n      }\n\n      // We are filtering by ActionCreator\n      return typeOrActionCreator.type === action.type;\n    })\n  );\n}\n","import { ErrorHandler } from '@angular/core';\nimport { Action } from '@ngrx/store';\nimport { Notification, Observable } from 'rxjs';\n\nexport interface EffectNotification {\n  effect: Observable<any> | (() => Observable<any>);\n  propertyName: PropertyKey;\n  sourceName: string;\n  sourceInstance: any;\n  notification: Notification<Action | null | undefined>;\n}\n\nexport function reportInvalidActions(\n  output: EffectNotification,\n  reporter: ErrorHandler\n) {\n  if (output.notification.kind === 'N') {\n    const action = output.notification.value;\n    const isInvalidAction = !isAction(action);\n\n    if (isInvalidAction) {\n      reporter.handleError(\n        new Error(\n          `Effect ${getEffectName(\n            output\n          )} dispatched an invalid action: ${stringify(action)}`\n        )\n      );\n    }\n  }\n}\n\nfunction isAction(action: any): action is Action {\n  return (\n    typeof action !== 'function' &&\n    action &&\n    action.type &&\n    typeof action.type === 'string'\n  );\n}\n\nfunction getEffectName({\n  propertyName,\n  sourceInstance,\n  sourceName,\n}: EffectNotification) {\n  const isMethod = typeof sourceInstance[propertyName] === 'function';\n\n  return `\"${sourceName}.${String(propertyName)}${isMethod ? '()' : ''}\"`;\n}\n\nfunction stringify(action: Action | null | undefined) {\n  try {\n    return JSON.stringify(action);\n  } catch {\n    return action;\n  }\n}\n","import { Observable } from 'rxjs';\nimport { EffectNotification } from '.';\nimport { Action } from '@ngrx/store';\n\n/**\n * @description\n * Interface to set an identifier for effect instances.\n *\n * By default, each Effects class is registered\n * once regardless of how many times the Effect class\n * is loaded. By implementing this interface, you define\n * a unique identifier to register an Effects class instance\n * multiple times.\n *\n * @usageNotes\n *\n * ### Set an identifier for an Effects class\n *\n * ```ts\n * class EffectWithIdentifier implements OnIdentifyEffects {\n *  constructor(private effectIdentifier: string) {}\n *\n *  ngrxOnIdentifyEffects() {\n *    return this.effectIdentifier;\n *  }\n *\n * ```\n */\nexport declare interface OnIdentifyEffects {\n  /**\n   * @description\n   * String identifier to differentiate effect instances.\n   */\n  ngrxOnIdentifyEffects(): string;\n}\n\nexport const onIdentifyEffectsKey: keyof OnIdentifyEffects =\n  'ngrxOnIdentifyEffects';\n\nexport function isOnIdentifyEffects(\n  instance: any\n): instance is OnIdentifyEffects {\n  return isFunction(instance, onIdentifyEffectsKey);\n}\n\n/**\n * @description\n * Interface to control the lifecycle of effects.\n *\n * By default, effects are merged and subscribed to the store. Implement the OnRunEffects interface to control the lifecycle of the resolved effects.\n *\n * @usageNotes\n *\n * ### Implement the OnRunEffects interface on an Effects class\n *\n * ```ts\n * export class UserEffects implements OnRunEffects {\n *   constructor(private actions$: Actions) {}\n *\n *   ngrxOnRunEffects(resolvedEffects$: Observable<EffectNotification>) {\n *     return this.actions$.pipe(\n *       ofType('LOGGED_IN'),\n *       exhaustMap(() =>\n *         resolvedEffects$.pipe(\n *           takeUntil(this.actions$.pipe(ofType('LOGGED_OUT')))\n *         )\n *       )\n *     );\n *   }\n * }\n * ```\n */\nexport declare interface OnRunEffects {\n  /**\n   * @description\n   * Method to control the lifecycle of effects.\n   */\n  ngrxOnRunEffects(\n    resolvedEffects$: Observable<EffectNotification>\n  ): Observable<EffectNotification>;\n}\n\nexport const onRunEffectsKey: keyof OnRunEffects = 'ngrxOnRunEffects';\n\nexport function isOnRunEffects(instance: any): instance is OnRunEffects {\n  return isFunction(instance, onRunEffectsKey);\n}\n\n/**\n * @description\n * Interface to dispatch an action after effect registration.\n *\n * Implement this interface to dispatch a custom action after\n * the effect has been added. You can listen to this action\n * in the rest of the application to execute something after\n * the effect is registered.\n *\n * @usageNotes\n *\n * ### Set an identifier for an Effects class\n *\n * ```ts\n * class EffectWithInitAction implements OnInitEffects {\n *  ngrxOnInitEffects() {\n *    return { type: '[EffectWithInitAction] Init' };\n *  }\n * ```\n */\nexport declare interface OnInitEffects {\n  /**\n   * @description\n   * Action to be dispatched after the effect is registered.\n   */\n  ngrxOnInitEffects(): Action;\n}\n\nexport const onInitEffects: keyof OnInitEffects = 'ngrxOnInitEffects';\n\nexport function isOnInitEffects(instance: any): instance is OnInitEffects {\n  return isFunction(instance, onInitEffects);\n}\n\nfunction isFunction(instance: any, functionName: string) {\n  return (\n    instance &&\n    functionName in instance &&\n    typeof instance[functionName] === 'function'\n  );\n}\n","import { InjectionToken, Type } from '@angular/core';\nimport { EffectsErrorHandler } from './effects_error_handler';\n\nexport const _ROOT_EFFECTS_GUARD = new InjectionToken<void>(\n  '@ngrx/effects Internal Root Guard'\n);\nexport const IMMEDIATE_EFFECTS = new InjectionToken<any[]>(\n  'ngrx/effects: Immediate Effects'\n);\nexport const USER_PROVIDED_EFFECTS = new InjectionToken<Type<any>[][]>(\n  'ngrx/effects: User Provided Effects'\n);\nexport const _ROOT_EFFECTS = new InjectionToken<Type<any>[]>(\n  'ngrx/effects: Internal Root Effects'\n);\nexport const ROOT_EFFECTS = new InjectionToken<Type<any>[]>(\n  'ngrx/effects: Root Effects'\n);\nexport const _FEATURE_EFFECTS = new InjectionToken<Type<any>[]>(\n  'ngrx/effects: Internal Feature Effects'\n);\nexport const FEATURE_EFFECTS = new InjectionToken<any[][]>(\n  'ngrx/effects: Feature Effects'\n);\nexport const EFFECTS_ERROR_HANDLER = new InjectionToken<EffectsErrorHandler>(\n  'ngrx/effects: Effects Error Handler'\n);\n","import { ErrorHandler, Inject, Injectable } from '@angular/core';\nimport { Action } from '@ngrx/store';\nimport { Notification, Observable, Subject, merge } from 'rxjs';\nimport {\n  dematerialize,\n  exhaustMap,\n  filter,\n  groupBy,\n  map,\n  mergeMap,\n  take,\n} from 'rxjs/operators';\n\nimport {\n  reportInvalidActions,\n  EffectNotification,\n} from './effect_notification';\nimport { EffectsErrorHandler } from './effects_error_handler';\nimport { mergeEffects } from './effects_resolver';\nimport {\n  onIdentifyEffectsKey,\n  onRunEffectsKey,\n  OnRunEffects,\n  onInitEffects,\n  isOnIdentifyEffects,\n  isOnRunEffects,\n  isOnInitEffects,\n} from './lifecycle_hooks';\nimport { EFFECTS_ERROR_HANDLER } from './tokens';\nimport { getSourceForInstance } from './utils';\n\n@Injectable()\nexport class EffectSources extends Subject<any> {\n  constructor(\n    private errorHandler: ErrorHandler,\n    @Inject(EFFECTS_ERROR_HANDLER)\n    private effectsErrorHandler: EffectsErrorHandler\n  ) {\n    super();\n  }\n\n  addEffects(effectSourceInstance: any): void {\n    this.next(effectSourceInstance);\n  }\n\n  /**\n   * @internal\n   */\n  toActions(): Observable<Action> {\n    return this.pipe(\n      groupBy(getSourceForInstance),\n      mergeMap((source$) => {\n        return source$.pipe(groupBy(effectsInstance));\n      }),\n      mergeMap((source$) => {\n        const effect$ = source$.pipe(\n          exhaustMap((sourceInstance) => {\n            return resolveEffectSource(\n              this.errorHandler,\n              this.effectsErrorHandler\n            )(sourceInstance);\n          }),\n          map((output) => {\n            reportInvalidActions(output, this.errorHandler);\n            return output.notification;\n          }),\n          filter(\n            (notification): notification is Notification<Action> =>\n              notification.kind === 'N'\n          ),\n          dematerialize()\n        );\n\n        // start the stream with an INIT action\n        // do this only for the first Effect instance\n        const init$ = source$.pipe(\n          take(1),\n          filter(isOnInitEffects),\n          map((instance) => instance.ngrxOnInitEffects())\n        );\n\n        return merge(effect$, init$);\n      })\n    );\n  }\n}\n\nfunction effectsInstance(sourceInstance: any) {\n  if (isOnIdentifyEffects(sourceInstance)) {\n    return sourceInstance.ngrxOnIdentifyEffects();\n  }\n\n  return '';\n}\n\nfunction resolveEffectSource(\n  errorHandler: ErrorHandler,\n  effectsErrorHandler: EffectsErrorHandler\n): (sourceInstance: any) => Observable<EffectNotification> {\n  return (sourceInstance) => {\n    const mergedEffects$ = mergeEffects(\n      sourceInstance,\n      errorHandler,\n      effectsErrorHandler\n    );\n\n    if (isOnRunEffects(sourceInstance)) {\n      return sourceInstance.ngrxOnRunEffects(mergedEffects$);\n    }\n\n    return mergedEffects$;\n  };\n}\n","import { Injectable, OnDestroy } from '@angular/core';\nimport { Store } from '@ngrx/store';\nimport { Subscription } from 'rxjs';\n\nimport { EffectSources } from './effect_sources';\n\n@Injectable()\nexport class EffectsRunner implements OnDestroy {\n  private effectsSubscription: Subscription | null = null;\n\n  constructor(\n    private effectSources: EffectSources,\n    private store: Store<any>\n  ) {}\n\n  start() {\n    if (!this.effectsSubscription) {\n      this.effectsSubscription = this.effectSources\n        .toActions()\n        .subscribe(this.store);\n    }\n  }\n\n  ngOnDestroy() {\n    if (this.effectsSubscription) {\n      this.effectsSubscription.unsubscribe();\n      this.effectsSubscription = null;\n    }\n  }\n}\n","import { NgModule, Inject, Optional } from '@angular/core';\nimport {\n  createAction,\n  StoreModule,\n  Store,\n  StoreRootModule,\n  StoreFeatureModule,\n} from '@ngrx/store';\nimport { EffectsRunner } from './effects_runner';\nimport { EffectSources } from './effect_sources';\nimport { ROOT_EFFECTS, _ROOT_EFFECTS_GUARD } from './tokens';\n\nexport const ROOT_EFFECTS_INIT = '@ngrx/effects/init';\nexport const rootEffectsInit = createAction(ROOT_EFFECTS_INIT);\n\n@NgModule({})\nexport class EffectsRootModule {\n  constructor(\n    private sources: EffectSources,\n    runner: EffectsRunner,\n    store: Store<any>,\n    @Inject(ROOT_EFFECTS) rootEffects: any[],\n    @Optional() storeRootModule: StoreRootModule,\n    @Optional() storeFeatureModule: StoreFeatureModule,\n    @Optional()\n    @Inject(_ROOT_EFFECTS_GUARD)\n    guard: any\n  ) {\n    runner.start();\n\n    rootEffects.forEach((effectSourceInstance) =>\n      sources.addEffects(effectSourceInstance)\n    );\n\n    store.dispatch({ type: ROOT_EFFECTS_INIT });\n  }\n\n  addEffects(effectSourceInstance: any) {\n    this.sources.addEffects(effectSourceInstance);\n  }\n}\n","import { NgModule, Inject, Optional } from '@angular/core';\nimport { StoreRootModule, StoreFeatureModule } from '@ngrx/store';\nimport { EffectsRootModule } from './effects_root_module';\nimport { FEATURE_EFFECTS } from './tokens';\n\n@NgModule({})\nexport class EffectsFeatureModule {\n  constructor(\n    root: EffectsRootModule,\n    @Inject(FEATURE_EFFECTS) effectSourceGroups: any[][],\n    @Optional() storeRootModule: StoreRootModule,\n    @Optional() storeFeatureModule: StoreFeatureModule\n  ) {\n    effectSourceGroups.forEach((group) =>\n      group.forEach((effectSourceInstance) =>\n        root.addEffects(effectSourceInstance)\n      )\n    );\n  }\n}\n","import {\n  Injector,\n  ModuleWithProviders,\n  NgModule,\n  Optional,\n  Self,\n  SkipSelf,\n  Type,\n} from '@angular/core';\nimport { Actions } from './actions';\nimport { EffectSources } from './effect_sources';\nimport { EffectsFeatureModule } from './effects_feature_module';\nimport { defaultEffectsErrorHandler } from './effects_error_handler';\nimport { EffectsRootModule } from './effects_root_module';\nimport { EffectsRunner } from './effects_runner';\nimport {\n  _FEATURE_EFFECTS,\n  _ROOT_EFFECTS,\n  _ROOT_EFFECTS_GUARD,\n  EFFECTS_ERROR_HANDLER,\n  FEATURE_EFFECTS,\n  ROOT_EFFECTS,\n  USER_PROVIDED_EFFECTS,\n} from './tokens';\n\n@NgModule({})\nexport class EffectsModule {\n  static forFeature(\n    featureEffects: Type<any>[] = []\n  ): ModuleWithProviders<EffectsFeatureModule> {\n    return {\n      ngModule: EffectsFeatureModule,\n      providers: [\n        featureEffects,\n        {\n          provide: _FEATURE_EFFECTS,\n          multi: true,\n          useValue: featureEffects,\n        },\n        {\n          provide: USER_PROVIDED_EFFECTS,\n          multi: true,\n          useValue: [],\n        },\n        {\n          provide: FEATURE_EFFECTS,\n          multi: true,\n          useFactory: createEffects,\n          deps: [Injector, _FEATURE_EFFECTS, USER_PROVIDED_EFFECTS],\n        },\n      ],\n    };\n  }\n\n  static forRoot(\n    rootEffects: Type<any>[] = []\n  ): ModuleWithProviders<EffectsRootModule> {\n    return {\n      ngModule: EffectsRootModule,\n      providers: [\n        {\n          provide: EFFECTS_ERROR_HANDLER,\n          useValue: defaultEffectsErrorHandler,\n        },\n        EffectsRunner,\n        EffectSources,\n        Actions,\n        rootEffects,\n        {\n          provide: _ROOT_EFFECTS,\n          useValue: [rootEffects],\n        },\n        {\n          provide: _ROOT_EFFECTS_GUARD,\n          useFactory: _provideForRootGuard,\n          deps: [\n            [EffectsRunner, new Optional(), new SkipSelf()],\n            [_ROOT_EFFECTS, new Self()],\n          ],\n        },\n        {\n          provide: USER_PROVIDED_EFFECTS,\n          multi: true,\n          useValue: [],\n        },\n        {\n          provide: ROOT_EFFECTS,\n          useFactory: createEffects,\n          deps: [Injector, _ROOT_EFFECTS, USER_PROVIDED_EFFECTS],\n        },\n      ],\n    };\n  }\n}\n\nexport function createEffects(\n  injector: Injector,\n  effectGroups: Type<any>[][],\n  userProvidedEffectGroups: Type<any>[][]\n): any[] {\n  const mergedEffects: Type<any>[] = [];\n\n  for (let effectGroup of effectGroups) {\n    mergedEffects.push(...effectGroup);\n  }\n\n  for (let userProvidedEffectGroup of userProvidedEffectGroups) {\n    mergedEffects.push(...userProvidedEffectGroup);\n  }\n\n  return createEffectInstances(injector, mergedEffects);\n}\n\nexport function createEffectInstances(\n  injector: Injector,\n  effects: Type<any>[]\n): any[] {\n  return effects.map((effect) => injector.get(effect));\n}\n\nexport function _provideForRootGuard(\n  runner: EffectsRunner,\n  rootEffects: any[][]\n): any {\n  // check whether any effects are actually passed\n  const hasEffects = !(rootEffects.length === 1 && rootEffects[0].length === 0);\n  if (hasEffects && runner) {\n    throw new TypeError(\n      `EffectsModule.forRoot() called twice. Feature modules should use EffectsModule.forFeature() instead.`\n    );\n  }\n  return 'guarded';\n}\n","import { Action } from '@ngrx/store';\nimport {\n  defer,\n  merge,\n  Notification,\n  Observable,\n  OperatorFunction,\n  Subject,\n} from 'rxjs';\nimport {\n  concatMap,\n  dematerialize,\n  filter,\n  finalize,\n  map,\n  materialize,\n} from 'rxjs/operators';\n\n/** Represents config with named paratemeters for act */\nexport interface ActConfig<\n  Input,\n  OutputAction extends Action,\n  ErrorAction extends Action,\n  CompleteAction extends Action,\n  UnsubscribeAction extends Action\n> {\n  // Project function that produces the output actions in success cases\n  project: (input: Input, index: number) => Observable<OutputAction>;\n  // Error handle function for project\n  // error that happened during project execution\n  // input value that project errored with\n  error: (error: any, input: Input) => ErrorAction;\n  // Optional complete action provider\n  // count is the number of actions project emitted before completion\n  // input value that project completed with\n  complete?: (count: number, input: Input) => CompleteAction;\n  // Optional flattening operator\n  operator?: <Input, OutputAction>(\n    project: (input: Input, index: number) => Observable<OutputAction>\n  ) => OperatorFunction<Input, OutputAction>;\n  // Optional unsubscribe action provider\n  // count is the number of actions project emitted before unsubscribing\n  // input value that was unsubscribed from\n  unsubscribe?: (count: number, input: Input) => UnsubscribeAction;\n}\n\n/**\n * Wraps project fn with error handling making it safe to use in Effects.\n * Takes either config with named properties that represent different possible\n * callbacks or project/error callbacks that are required.\n */\nexport function act<\n  Input,\n  OutputAction extends Action,\n  ErrorAction extends Action\n>(\n  project: (input: Input, index: number) => Observable<OutputAction>,\n  error: (error: any, input: Input) => ErrorAction\n): (source: Observable<Input>) => Observable<OutputAction | ErrorAction>;\nexport function act<\n  Input,\n  OutputAction extends Action,\n  ErrorAction extends Action,\n  CompleteAction extends Action = never,\n  UnsubscribeAction extends Action = never\n>(\n  config: ActConfig<\n    Input,\n    OutputAction,\n    ErrorAction,\n    CompleteAction,\n    UnsubscribeAction\n  >\n): (\n  source: Observable<Input>\n) => Observable<\n  OutputAction | ErrorAction | CompleteAction | UnsubscribeAction\n>;\nexport function act<\n  Input,\n  OutputAction extends Action,\n  ErrorAction extends Action,\n  CompleteAction extends Action = never,\n  UnsubscribeAction extends Action = never\n>(\n  /** Allow to take either config object or project/error functions */\n  configOrProject:\n    | ActConfig<\n        Input,\n        OutputAction,\n        ErrorAction,\n        CompleteAction,\n        UnsubscribeAction\n      >\n    | ((input: Input, index: number) => Observable<OutputAction>),\n  errorFn?: (error: any, input: Input) => ErrorAction\n): (\n  source: Observable<Input>\n) => Observable<\n  OutputAction | ErrorAction | CompleteAction | UnsubscribeAction\n> {\n  const { project, error, complete, operator, unsubscribe } =\n    typeof configOrProject === 'function'\n      ? {\n          project: configOrProject,\n          error: errorFn!,\n          operator: concatMap,\n          complete: undefined,\n          unsubscribe: undefined,\n        }\n      : { ...configOrProject, operator: configOrProject.operator || concatMap };\n\n  type ResultAction =\n    | OutputAction\n    | ErrorAction\n    | CompleteAction\n    | UnsubscribeAction;\n  return (source) =>\n    defer(\n      (): Observable<ResultAction> => {\n        const subject = new Subject<UnsubscribeAction>();\n        return merge(\n          source.pipe(\n            operator((input, index) =>\n              defer(() => {\n                let completed = false;\n                let errored = false;\n                let projectedCount = 0;\n                return project(input, index).pipe(\n                  materialize(),\n                  map((notification):\n                    | Notification<ResultAction>\n                    | undefined => {\n                    switch (notification.kind) {\n                      case 'E':\n                        errored = true;\n                        return new Notification(\n                          // TODO: remove any in RxJS 6.5\n                          'N' as any,\n                          error(notification.error, input)\n                        );\n                      case 'C':\n                        completed = true;\n                        return complete\n                          ? new Notification(\n                              // TODO: remove any in RxJS 6.5\n                              'N' as any,\n                              complete(projectedCount, input)\n                            )\n                          : undefined;\n                      default:\n                        ++projectedCount;\n                        return notification;\n                    }\n                  }),\n                  filter((n): n is NonNullable<typeof n> => n != null),\n                  dematerialize(),\n                  finalize(() => {\n                    if (!completed && !errored && unsubscribe) {\n                      subject.next(unsubscribe(projectedCount, input));\n                    }\n                  })\n                );\n              })\n            )\n          ),\n          subject\n        );\n      }\n    );\n}\n"]},"metadata":{},"sourceType":"module"}