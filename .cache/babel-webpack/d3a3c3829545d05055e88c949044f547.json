{"ast":null,"code":"import _toArray from \"D:/queen-supermarket/Biz1Market_EXE/node_modules/@babel/runtime/helpers/esm/toArray\";\nimport _toConsumableArray from \"D:/queen-supermarket/Biz1Market_EXE/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _classCallCheck from \"D:/queen-supermarket/Biz1Market_EXE/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"D:/queen-supermarket/Biz1Market_EXE/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport { queueScheduler, asyncScheduler } from 'rxjs';\nimport { tap, subscribeOn, observeOn } from 'rxjs/operators';\nimport { InjectionToken, Version, isDevMode, NgZone, Optional, VERSION as VERSION$1, NgModule, Inject, PLATFORM_ID } from '@angular/core';\nimport firebase from 'firebase/app';\nimport * as ɵngcc0 from '@angular/core';\n\nfunction noop() {}\n/**\n * Schedules tasks so that they are invoked inside the Zone that is passed in the constructor.\n */\n// tslint:disable-next-line:class-name\n\n\nvar ɵZoneScheduler = /*#__PURE__*/function () {\n  function ɵZoneScheduler(zone) {\n    var delegate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : queueScheduler;\n\n    _classCallCheck(this, ɵZoneScheduler);\n\n    this.zone = zone;\n    this.delegate = delegate;\n  }\n\n  _createClass(ɵZoneScheduler, [{\n    key: \"now\",\n    value: function now() {\n      return this.delegate.now();\n    }\n  }, {\n    key: \"schedule\",\n    value: function schedule(work, delay, state) {\n      var targetZone = this.zone; // Wrap the specified work function to make sure that if nested scheduling takes place the\n      // work is executed in the correct zone\n\n      var workInZone = function workInZone(state) {\n        var _this = this;\n\n        targetZone.runGuarded(function () {\n          work.apply(_this, [state]);\n        });\n      }; // Scheduling itself needs to be run in zone to ensure setInterval calls for async scheduling are done\n      // inside the correct zone. This scheduler needs to schedule asynchronously always to ensure that\n      // firebase emissions are never synchronous. Specifying a delay causes issues with the queueScheduler delegate.\n\n\n      return this.delegate.schedule(workInZone, delay, state);\n    }\n  }]);\n\n  return ɵZoneScheduler;\n}(); // tslint:disable-next-line:class-name\n\n\nvar ɵBlockUntilFirstOperator = /*#__PURE__*/function () {\n  function ɵBlockUntilFirstOperator(zone) {\n    _classCallCheck(this, ɵBlockUntilFirstOperator);\n\n    this.zone = zone;\n    this.task = null;\n  }\n\n  _createClass(ɵBlockUntilFirstOperator, [{\n    key: \"call\",\n    value: function call(subscriber, source) {\n      var unscheduleTask = this.unscheduleTask.bind(this);\n      this.task = this.zone.run(function () {\n        return Zone.current.scheduleMacroTask('firebaseZoneBlock', noop, {}, noop, noop);\n      });\n      return source.pipe(tap({\n        next: unscheduleTask,\n        complete: unscheduleTask,\n        error: unscheduleTask\n      })).subscribe(subscriber).add(unscheduleTask);\n    }\n  }, {\n    key: \"unscheduleTask\",\n    value: function unscheduleTask() {\n      var _this2 = this;\n\n      // maybe this is a race condition, invoke in a timeout\n      // hold for 10ms while I try to figure out what is going on\n      setTimeout(function () {\n        if (_this2.task != null && _this2.task.state === 'scheduled') {\n          _this2.task.invoke();\n\n          _this2.task = null;\n        }\n      }, 10);\n    }\n  }]);\n\n  return ɵBlockUntilFirstOperator;\n}(); // tslint:disable-next-line:class-name\n\n\nvar ɵAngularFireSchedulers = /*#__PURE__*/_createClass(function ɵAngularFireSchedulers(ngZone) {\n  _classCallCheck(this, ɵAngularFireSchedulers);\n\n  this.ngZone = ngZone;\n  this.outsideAngular = ngZone.runOutsideAngular(function () {\n    return new ɵZoneScheduler(Zone.current);\n  });\n  this.insideAngular = ngZone.run(function () {\n    return new ɵZoneScheduler(Zone.current, asyncScheduler);\n  });\n});\n/**\n * Operator to block the zone until the first value has been emitted or the observable\n * has completed/errored. This is used to make sure that universal waits until the first\n * value from firebase but doesn't block the zone forever since the firebase subscription\n * is still alive.\n */\n\n\nfunction ɵkeepUnstableUntilFirstFactory(schedulers) {\n  return function keepUnstableUntilFirst(obs$) {\n    obs$ = obs$.lift(new ɵBlockUntilFirstOperator(schedulers.ngZone));\n    return obs$.pipe( // Run the subscribe body outside of Angular (e.g. calling Firebase SDK to add a listener to a change event)\n    subscribeOn(schedulers.outsideAngular), // Run operators inside the angular zone (e.g. side effects via tap())\n    observeOn(schedulers.insideAngular) // INVESTIGATE https://github.com/angular/angularfire/pull/2315\n    // share()\n    );\n  };\n} // DEBUG quick debugger function for inline logging that typescript doesn't complain about\n//       wrote it for debugging the ɵlazySDKProxy, commenting out for now; should consider exposing a\n//       verbose mode for AngularFire in a future release that uses something like this in multiple places\n//       usage: () => log('something') || returnValue\n// const log = (...args: any[]): false => { console.log(...args); return false }\n// The problem here are things like ngOnDestroy are missing, then triggering the service\n// rather than dig too far; I'm capturing these as I go.\n\n\nvar noopFunctions = ['ngOnDestroy']; // INVESTIGATE should we make the Proxy revokable and do some cleanup?\n//             right now it's fairly simple but I'm sure this will grow in complexity\n\nvar ɵlazySDKProxy = function ɵlazySDKProxy(klass, observable, zone) {\n  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  return new Proxy(klass, {\n    get: function get(_, name) {\n      return zone.runOutsideAngular(function () {\n        var _a;\n\n        if (klass[name]) {\n          if ((_a = options === null || options === void 0 ? void 0 : options.spy) === null || _a === void 0 ? void 0 : _a.get) {\n            options.spy.get(name, klass[name]);\n          }\n\n          return klass[name];\n        }\n\n        if (noopFunctions.indexOf(name) > -1) {\n          return function () {};\n        }\n\n        var promise = observable.toPromise().then(function (mod) {\n          var ret = mod && mod[name]; // TODO move to proper type guards\n\n          if (typeof ret === 'function') {\n            return ret.bind(mod);\n          } else if (ret && ret.then) {\n            return ret.then(function (res) {\n              return zone.run(function () {\n                return res;\n              });\n            });\n          } else {\n            return zone.run(function () {\n              return ret;\n            });\n          }\n        }); // recurse the proxy\n\n        return new Proxy(function () {}, {\n          get: function get(_, name) {\n            return promise[name];\n          },\n          // TODO handle callbacks as transparently as I can\n          apply: function apply(self, _, args) {\n            return promise.then(function (it) {\n              var _a;\n\n              var res = it && it.apply(void 0, _toConsumableArray(args));\n\n              if ((_a = options === null || options === void 0 ? void 0 : options.spy) === null || _a === void 0 ? void 0 : _a.apply) {\n                options.spy.apply(name, args, res);\n              }\n\n              return res;\n            });\n          }\n        });\n      });\n    }\n  });\n};\n\nvar ɵapplyMixins = function ɵapplyMixins(derivedCtor, constructors) {\n  constructors.forEach(function (baseCtor) {\n    Object.getOwnPropertyNames(baseCtor.prototype || baseCtor).forEach(function (name) {\n      Object.defineProperty(derivedCtor.prototype, name, Object.getOwnPropertyDescriptor(baseCtor.prototype || baseCtor, name));\n    });\n  });\n};\n\nvar FIREBASE_OPTIONS = new InjectionToken('angularfire2.app.options');\nvar FIREBASE_APP_NAME = new InjectionToken('angularfire2.app.nameOrConfig'); // Have to implement as we need to return a class from the provider, we should consider exporting\n// this in the firebase/app types as this is our highest risk of breaks\n\nvar FirebaseApp = /*#__PURE__*/_createClass(function FirebaseApp() {\n  _classCallCheck(this, FirebaseApp);\n});\n\nvar VERSION = new Version('6.1.5');\n\nfunction ɵfirebaseAppFactory(options, zone, nameOrConfig) {\n  var name = typeof nameOrConfig === 'string' && nameOrConfig || '[DEFAULT]';\n  var config = typeof nameOrConfig === 'object' && nameOrConfig || {};\n  config.name = config.name || name; // Added any due to some inconsistency between @firebase/app and firebase types\n\n  var existingApp = firebase.apps.filter(function (app) {\n    return app && app.name === config.name;\n  })[0]; // We support FirebaseConfig, initializeApp's public type only accepts string; need to cast as any\n  // Could be solved with https://github.com/firebase/firebase-js-sdk/pull/1206\n\n  var app = existingApp || zone.runOutsideAngular(function () {\n    return firebase.initializeApp(options, config);\n  });\n\n  try {\n    if (JSON.stringify(options) !== JSON.stringify(app.options)) {\n      var hmr = !!module.hot;\n      log('error', \"\".concat(app.name, \" Firebase App already initialized with different options\").concat(hmr ? ', you may need to reload as Firebase is not HMR aware.' : '.'));\n    }\n  } catch (e) {}\n\n  return app;\n}\n\nvar ɵlogAuthEmulatorError = function ɵlogAuthEmulatorError() {\n  // TODO sort this out, https://github.com/angular/angularfire/issues/2656\n  log('warn', 'You may need to import \\'firebase/auth\\' manually in your component rather than rely on AngularFireAuth\\'s dynamic import, when using the emulator suite https://github.com/angular/angularfire/issues/2656');\n};\n\nvar log = function log(level) {\n  if (isDevMode() && typeof console !== 'undefined') {\n    var _console;\n\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    (_console = console)[level].apply(_console, args);\n  }\n};\n\nvar ɵ0 = log;\nglobalThis.ɵAngularfireInstanceCache || (globalThis.ɵAngularfireInstanceCache = new Map());\n\nfunction ɵfetchInstance(cacheKey, moduleName, app, fn, args) {\n  var _ref = globalThis.ɵAngularfireInstanceCache.get(cacheKey) || [],\n      _ref2 = _toArray(_ref),\n      instance = _ref2[0],\n      cachedArgs = _ref2.slice(1);\n\n  if (instance) {\n    try {\n      if (args.some(function (arg, i) {\n        var cachedArg = cachedArgs[i];\n\n        if (arg && typeof arg === 'object') {\n          return JSON.stringify(arg) !== JSON.stringify(cachedArg);\n        } else {\n          return arg !== cachedArg;\n        }\n      })) {\n        var hmr = !!module.hot;\n        log('error', \"\".concat(moduleName, \" was already initialized on the \").concat(app.name, \" Firebase App instance with different settings.\").concat(hmr ? ' You may need to reload as Firebase is not HMR aware.' : ''));\n      }\n    } catch (e) {}\n\n    return instance;\n  } else {\n    var newInstance = fn();\n    globalThis.ɵAngularfireInstanceCache.set(cacheKey, [newInstance].concat(_toConsumableArray(args)));\n    return newInstance;\n  }\n}\n\nvar FIREBASE_APP_PROVIDER = {\n  provide: FirebaseApp,\n  useFactory: ɵfirebaseAppFactory,\n  deps: [FIREBASE_OPTIONS, NgZone, [new Optional(), FIREBASE_APP_NAME]]\n};\n\nvar AngularFireModule = /*#__PURE__*/function () {\n  // tslint:disable-next-line:ban-types\n  function AngularFireModule(platformId) {\n    _classCallCheck(this, AngularFireModule);\n\n    firebase.registerVersion('angularfire', VERSION.full, platformId.toString());\n    firebase.registerVersion('angular', VERSION$1.full);\n  }\n\n  _createClass(AngularFireModule, null, [{\n    key: \"initializeApp\",\n    value: function initializeApp(options, nameOrConfig) {\n      return {\n        ngModule: AngularFireModule,\n        providers: [{\n          provide: FIREBASE_OPTIONS,\n          useValue: options\n        }, {\n          provide: FIREBASE_APP_NAME,\n          useValue: nameOrConfig\n        }]\n      };\n    }\n  }]);\n\n  return AngularFireModule;\n}();\n\nAngularFireModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({\n  type: AngularFireModule\n});\nAngularFireModule.ɵinj = ɵngcc0.ɵɵdefineInjector({\n  factory: function AngularFireModule_Factory(t) {\n    return new (t || AngularFireModule)(ɵngcc0.ɵɵinject(PLATFORM_ID));\n  },\n  providers: [FIREBASE_APP_PROVIDER]\n});\n/** @nocollapse */\n\nAngularFireModule.ctorParameters = function () {\n  return [{\n    type: Object,\n    decorators: [{\n      type: Inject,\n      args: [PLATFORM_ID]\n    }]\n  }];\n};\n/*@__PURE__*/\n\n\n(function () {\n  ɵngcc0.ɵsetClassMetadata(AngularFireModule, [{\n    type: NgModule,\n    args: [{\n      providers: [FIREBASE_APP_PROVIDER]\n    }]\n  }], function () {\n    return [{\n      type: Object,\n      decorators: [{\n        type: Inject,\n        args: [PLATFORM_ID]\n      }]\n    }];\n  }, null);\n})();\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { AngularFireModule, FIREBASE_APP_NAME, FIREBASE_OPTIONS, FirebaseApp, VERSION, ɵ0, ɵAngularFireSchedulers, ɵBlockUntilFirstOperator, ɵZoneScheduler, ɵapplyMixins, ɵfetchInstance, ɵfirebaseAppFactory, ɵkeepUnstableUntilFirstFactory, ɵlazySDKProxy, ɵlogAuthEmulatorError };","map":{"version":3,"sources":["../../../src/core/angularfire2.ts","../../../src/core/firebase.app.module.ts","../../../src/core/angular-fire.ts"],"names":["NG_VERSION"],"mappings":"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","sourcesContent":["import { NgZone } from '@angular/core';\nimport {\n  asyncScheduler,\n  Observable,\n  Operator,\n  queueScheduler,\n  SchedulerAction,\n  SchedulerLike,\n  Subscriber,\n  Subscription,\n  TeardownLogic\n} from 'rxjs';\nimport { observeOn, subscribeOn, tap } from 'rxjs/operators';\n\nfunction noop() {\n}\n\n/**\n * Schedules tasks so that they are invoked inside the Zone that is passed in the constructor.\n */\n// tslint:disable-next-line:class-name\nexport class ɵZoneScheduler implements SchedulerLike {\n  constructor(private zone: any, private delegate: any = queueScheduler) {\n  }\n\n  now() {\n    return this.delegate.now();\n  }\n\n  schedule(work: (this: SchedulerAction<any>, state?: any) => void, delay?: number, state?: any): Subscription {\n    const targetZone = this.zone;\n    // Wrap the specified work function to make sure that if nested scheduling takes place the\n    // work is executed in the correct zone\n    const workInZone = function(this: SchedulerAction<any>, state: any) {\n      targetZone.runGuarded(() => {\n        work.apply(this, [state]);\n      });\n    };\n\n    // Scheduling itself needs to be run in zone to ensure setInterval calls for async scheduling are done\n    // inside the correct zone. This scheduler needs to schedule asynchronously always to ensure that\n    // firebase emissions are never synchronous. Specifying a delay causes issues with the queueScheduler delegate.\n    return this.delegate.schedule(workInZone, delay, state);\n  }\n}\n\n// tslint:disable-next-line:class-name\nexport class ɵBlockUntilFirstOperator<T> implements Operator<T, T> {\n  private task: MacroTask | null = null;\n\n  constructor(private zone: any) {\n  }\n\n  call(subscriber: Subscriber<T>, source: Observable<T>): TeardownLogic {\n    const unscheduleTask = this.unscheduleTask.bind(this);\n    this.task = this.zone.run(() => Zone.current.scheduleMacroTask('firebaseZoneBlock', noop, {}, noop, noop));\n\n    return source.pipe(\n      tap({ next: unscheduleTask, complete: unscheduleTask, error: unscheduleTask })\n    ).subscribe(subscriber).add(unscheduleTask);\n  }\n\n  private unscheduleTask() {\n    // maybe this is a race condition, invoke in a timeout\n    // hold for 10ms while I try to figure out what is going on\n    setTimeout(() => {\n      if (this.task != null && this.task.state === 'scheduled') {\n        this.task.invoke();\n        this.task = null;\n      }\n    }, 10);\n  }\n}\n\n// tslint:disable-next-line:class-name\nexport class ɵAngularFireSchedulers {\n  public readonly outsideAngular: ɵZoneScheduler;\n  public readonly insideAngular: ɵZoneScheduler;\n\n  constructor(public ngZone: NgZone) {\n    this.outsideAngular = ngZone.runOutsideAngular(() => new ɵZoneScheduler(Zone.current));\n    this.insideAngular = ngZone.run(() => new ɵZoneScheduler(Zone.current, asyncScheduler));\n  }\n}\n\n/**\n * Operator to block the zone until the first value has been emitted or the observable\n * has completed/errored. This is used to make sure that universal waits until the first\n * value from firebase but doesn't block the zone forever since the firebase subscription\n * is still alive.\n */\nexport function ɵkeepUnstableUntilFirstFactory(schedulers: ɵAngularFireSchedulers) {\n  return function keepUnstableUntilFirst<T>(obs$: Observable<T>): Observable<T> {\n    obs$ = obs$.lift(\n      new ɵBlockUntilFirstOperator(schedulers.ngZone)\n    );\n\n    return obs$.pipe(\n      // Run the subscribe body outside of Angular (e.g. calling Firebase SDK to add a listener to a change event)\n      subscribeOn(schedulers.outsideAngular),\n      // Run operators inside the angular zone (e.g. side effects via tap())\n      observeOn(schedulers.insideAngular)\n      // INVESTIGATE https://github.com/angular/angularfire/pull/2315\n      // share()\n    );\n  };\n}\n\n// tslint:disable:ban-types\ntype FunctionPropertyNames<T> = { [K in keyof T]: T[K] extends Function ? K : never }[keyof T];\ntype PromiseReturningFunctionPropertyNames<T> = {\n  [K in FunctionPropertyNames<T>]: ReturnType<T[K]> extends Promise<any> ? K : never\n}[FunctionPropertyNames<T>];\ntype NonPromiseReturningFunctionPropertyNames<T> = {\n  [K in FunctionPropertyNames<T>]: ReturnType<T[K]> extends Promise<any> ? never : K\n}[FunctionPropertyNames<T>];\ntype NonFunctionPropertyNames<T> = { [K in keyof T]: T[K] extends Function ? never : K }[keyof T];\n// tslint:enable:ban-types\n\nexport type ɵPromiseProxy<T> = { [K in NonFunctionPropertyNames<T>]: Promise<T[K]> } &\n  { [K in NonPromiseReturningFunctionPropertyNames<T>]: (...args: Parameters<T[K]>) => Promise<ReturnType<T[K]>> } &\n  { [K in PromiseReturningFunctionPropertyNames<T>]: (...args: Parameters<T[K]>) => ReturnType<T[K]> };\n\n\n// DEBUG quick debugger function for inline logging that typescript doesn't complain about\n//       wrote it for debugging the ɵlazySDKProxy, commenting out for now; should consider exposing a\n//       verbose mode for AngularFire in a future release that uses something like this in multiple places\n//       usage: () => log('something') || returnValue\n// const log = (...args: any[]): false => { console.log(...args); return false }\n\n// The problem here are things like ngOnDestroy are missing, then triggering the service\n// rather than dig too far; I'm capturing these as I go.\nconst noopFunctions = ['ngOnDestroy'];\n\n// INVESTIGATE should we make the Proxy revokable and do some cleanup?\n//             right now it's fairly simple but I'm sure this will grow in complexity\nexport const ɵlazySDKProxy = (klass: any, observable: Observable<any>, zone: NgZone, options: {\n  spy?: {\n    get?: ((name: string, it: any) => void),\n    apply?: ((name: string, args: any[], it: any) => void)\n  }\n} = {}) => {\n  return new Proxy(klass, {\n    get: (_, name: string) => zone.runOutsideAngular(() => {\n      if (klass[name]) {\n        if (options?.spy?.get) {\n          options.spy.get(name, klass[name]);\n        }\n        return klass[name];\n      }\n      if (noopFunctions.indexOf(name) > -1) {\n        return () => {\n        };\n      }\n      const promise = observable.toPromise().then(mod => {\n        const ret = mod && mod[name];\n        // TODO move to proper type guards\n        if (typeof ret === 'function') {\n          return ret.bind(mod);\n        } else if (ret && ret.then) {\n          return ret.then((res: any) => zone.run(() => res));\n        } else {\n          return zone.run(() => ret);\n        }\n      });\n      // recurse the proxy\n      return new Proxy(() => {}, {\n          get: (_, name) => promise[name],\n          // TODO handle callbacks as transparently as I can\n          apply: (self, _, args) => promise.then(it => {\n            const res = it && it(...args);\n            if (options?.spy?.apply) {\n              options.spy.apply(name, args, res);\n            }\n            return res;\n          })\n        }\n      );\n    })\n  });\n};\n\nexport const ɵapplyMixins = (derivedCtor: any, constructors: any[]) => {\n  constructors.forEach((baseCtor) => {\n    Object.getOwnPropertyNames(baseCtor.prototype || baseCtor).forEach((name) => {\n      Object.defineProperty(\n        derivedCtor.prototype,\n        name,\n        Object.getOwnPropertyDescriptor(baseCtor.prototype || baseCtor, name)\n      );\n    });\n  });\n};\n","import {\n  Inject, InjectionToken, isDevMode, ModuleWithProviders, NgModule, NgZone, Optional, PLATFORM_ID, VERSION as NG_VERSION, Version\n} from '@angular/core';\nimport firebase from 'firebase/app';\n\n// INVESTIGATE Public types don't expose FirebaseOptions or FirebaseAppConfig, is this the case anylonger?\nexport interface FirebaseOptions {\n  [key: string]: any;\n}\n\nexport interface FirebaseAppConfig {\n  [key: string]: any;\n}\n\nexport const FIREBASE_OPTIONS = new InjectionToken<FirebaseOptions>('angularfire2.app.options');\nexport const FIREBASE_APP_NAME = new InjectionToken<string | FirebaseAppConfig | undefined>('angularfire2.app.nameOrConfig');\n\n// Have to implement as we need to return a class from the provider, we should consider exporting\n// this in the firebase/app types as this is our highest risk of breaks\nexport class FirebaseApp implements Partial<firebase.app.App> {\n  name: string;\n  options: {};\n  analytics: () => firebase.analytics.Analytics;\n  auth: () => firebase.auth.Auth;\n  database: (databaseURL?: string) => firebase.database.Database;\n  messaging: () => firebase.messaging.Messaging;\n  performance: () => firebase.performance.Performance;\n  storage: (storageBucket?: string) => firebase.storage.Storage;\n  delete: () => Promise<void>;\n  firestore: () => firebase.firestore.Firestore;\n  functions: (region?: string) => firebase.functions.Functions;\n  remoteConfig: () => firebase.remoteConfig.RemoteConfig;\n}\n\nexport const VERSION = new Version('ANGULARFIRE2_VERSION');\n\nexport function ɵfirebaseAppFactory(options: FirebaseOptions, zone: NgZone, nameOrConfig?: string | FirebaseAppConfig | null) {\n  const name = typeof nameOrConfig === 'string' && nameOrConfig || '[DEFAULT]';\n  const config = typeof nameOrConfig === 'object' && nameOrConfig || {};\n  config.name = config.name || name;\n  // Added any due to some inconsistency between @firebase/app and firebase types\n  const existingApp = firebase.apps.filter(app => app && app.name === config.name)[0] as any;\n  // We support FirebaseConfig, initializeApp's public type only accepts string; need to cast as any\n  // Could be solved with https://github.com/firebase/firebase-js-sdk/pull/1206\n  const app = (existingApp || zone.runOutsideAngular(() => firebase.initializeApp(options, config as any))) as FirebaseApp;\n  try {\n    if (JSON.stringify(options) !== JSON.stringify(app.options)) {\n      const hmr = !!(module as any).hot;\n      log('error', `${app.name} Firebase App already initialized with different options${hmr ? ', you may need to reload as Firebase is not HMR aware.' : '.'}`);\n    }\n  } catch (e) { }\n  return app;\n}\n\nexport const ɵlogAuthEmulatorError = () => {\n  // TODO sort this out, https://github.com/angular/angularfire/issues/2656\n  log('warn', 'You may need to import \\'firebase/auth\\' manually in your component rather than rely on AngularFireAuth\\'s dynamic import, when using the emulator suite https://github.com/angular/angularfire/issues/2656');\n};\n\nconst log = (level: 'log'|'error'|'info'|'warn', ...args: any) => {\n  if (isDevMode() && typeof console !== 'undefined') {\n    console[level](...args);\n  }\n};\n\nglobalThis.ɵAngularfireInstanceCache ||= new Map();\n\nexport function ɵfetchInstance<T>(cacheKey: any, moduleName: string, app: FirebaseApp, fn: () => T, args: any[]): T {\n  const [instance, ...cachedArgs] = globalThis.ɵAngularfireInstanceCache.get(cacheKey) || [];\n  if (instance) {\n    try {\n      if (args.some((arg, i) => {\n        const cachedArg = cachedArgs[i];\n        if (arg && typeof arg === 'object') {\n          return JSON.stringify(arg) !== JSON.stringify(cachedArg);\n        } else {\n          return arg !== cachedArg;\n        }\n      })) {\n        const hmr = !!(module as any).hot;\n        log('error', `${moduleName} was already initialized on the ${app.name} Firebase App instance with different settings.${hmr ? ' You may need to reload as Firebase is not HMR aware.' : ''}`);\n      }\n    } catch (e) { }\n    return instance;\n  } else {\n    const newInstance = fn();\n    globalThis.ɵAngularfireInstanceCache.set(cacheKey, [newInstance, ...args]);\n    return newInstance;\n  }\n}\n\nconst FIREBASE_APP_PROVIDER = {\n  provide: FirebaseApp,\n  useFactory: ɵfirebaseAppFactory,\n  deps: [\n    FIREBASE_OPTIONS,\n    NgZone,\n    [new Optional(), FIREBASE_APP_NAME]\n  ]\n};\n\n@NgModule({\n  providers: [FIREBASE_APP_PROVIDER]\n})\nexport class AngularFireModule {\n  static initializeApp(options: FirebaseOptions, nameOrConfig?: string | FirebaseAppConfig): ModuleWithProviders<AngularFireModule> {\n    return {\n      ngModule: AngularFireModule,\n      providers: [\n        {provide: FIREBASE_OPTIONS, useValue: options},\n        {provide: FIREBASE_APP_NAME, useValue: nameOrConfig}\n      ]\n    };\n  }\n\n  // tslint:disable-next-line:ban-types\n  constructor(@Inject(PLATFORM_ID) platformId: Object) {\n    firebase.registerVersion('angularfire', VERSION.full, platformId.toString());\n    firebase.registerVersion('angular', NG_VERSION.full);\n  }\n}\n","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './public_api';\n"]},"metadata":{},"sourceType":"module"}