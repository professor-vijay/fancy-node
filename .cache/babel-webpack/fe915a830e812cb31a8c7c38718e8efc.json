{"ast":null,"code":"import _createForOfIteratorHelper from \"D:/master-sp-new/Biz1Maket_Single_Store/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport _regeneratorRuntime from \"D:/master-sp-new/Biz1Maket_Single_Store/node_modules/@babel/runtime/regenerator\";\nimport _toConsumableArray from \"D:/master-sp-new/Biz1Maket_Single_Store/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _inherits from \"D:/master-sp-new/Biz1Maket_Single_Store/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"D:/master-sp-new/Biz1Maket_Single_Store/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport _slicedToArray from \"D:/master-sp-new/Biz1Maket_Single_Store/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _classCallCheck from \"D:/master-sp-new/Biz1Maket_Single_Store/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"D:/master-sp-new/Biz1Maket_Single_Store/node_modules/@babel/runtime/helpers/esm/createClass\";\n\n/**\n * @license Angular v10.2.5\n * (c) 2010-2020 Google LLC. https://angular.io/\n * License: MIT\n */\nimport { getDebugNode, RendererFactory2, ɵstringify, ɵReflectionCapabilities, Directive, Component, Pipe, NgModule, ɵgetInjectableDef, ɵNG_COMP_DEF, ɵRender3NgModuleRef, ApplicationInitStatus, LOCALE_ID, ɵDEFAULT_LOCALE_ID, ɵsetLocaleId, ɵRender3ComponentFactory, ɵcompileComponent, ɵNG_DIR_DEF, ɵcompileDirective, ɵNG_PIPE_DEF, ɵcompilePipe, ɵNG_MOD_DEF, ɵtransitiveScopesFor, ɵpatchComponentDefWithScope, ɵNG_INJ_DEF, ɵcompileNgModuleDefs, NgZone, Compiler, COMPILER_OPTIONS, ɵNgModuleFactory, ModuleWithComponentFactories, InjectionToken, Injector, InjectFlags, ɵresetCompiledComponents, ɵflushModuleScopingQueueAsMuchAsPossible, Injectable, ɵclearOverrides, ɵoverrideComponentView, ɵINJECTOR_SCOPE, Optional, SkipSelf, ɵoverrideProvider, ɵivyEnabled } from '@angular/core';\nimport { __awaiter } from 'tslib';\nimport { ResourceLoader } from '@angular/compiler';\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as ɵngcc0 from '@angular/core';\n\nvar _global = typeof window === 'undefined' ? global : window;\n/**\n * Wraps a test function in an asynchronous test zone. The test will automatically\n * complete when all asynchronous calls within this zone are done. Can be used\n * to wrap an {@link inject} call.\n *\n * Example:\n *\n * ```\n * it('...', async(inject([AClass], (object) => {\n *   object.doSomething.then(() => {\n *     expect(...);\n *   })\n * });\n * ```\n *\n *\n */\n\n\nfunction asyncFallback(fn) {\n  // If we're running using the Jasmine test framework, adapt to call the 'done'\n  // function when asynchronous activity is finished.\n  if (_global.jasmine) {\n    // Not using an arrow function to preserve context passed from call site\n    return function (done) {\n      if (!done) {\n        // if we run beforeEach in @angular/core/testing/testing_internal then we get no done\n        // fake it here and assume sync.\n        done = function done() {};\n\n        done.fail = function (e) {\n          throw e;\n        };\n      }\n\n      runInTestZone(fn, this, done, function (err) {\n        if (typeof err === 'string') {\n          return done.fail(new Error(err));\n        } else {\n          done.fail(err);\n        }\n      });\n    };\n  } // Otherwise, return a promise which will resolve when asynchronous activity\n  // is finished. This will be correctly consumed by the Mocha framework with\n  // it('...', async(myFn)); or can be used in a custom framework.\n  // Not using an arrow function to preserve context passed from call site\n\n\n  return function () {\n    var _this = this;\n\n    return new Promise(function (finishCallback, failCallback) {\n      runInTestZone(fn, _this, finishCallback, failCallback);\n    });\n  };\n}\n\nfunction runInTestZone(fn, context, finishCallback, failCallback) {\n  var currentZone = Zone.current;\n  var AsyncTestZoneSpec = Zone['AsyncTestZoneSpec'];\n\n  if (AsyncTestZoneSpec === undefined) {\n    throw new Error('AsyncTestZoneSpec is needed for the async() test helper but could not be found. ' + 'Please make sure that your environment includes zone.js/dist/async-test.js');\n  }\n\n  var ProxyZoneSpec = Zone['ProxyZoneSpec'];\n\n  if (ProxyZoneSpec === undefined) {\n    throw new Error('ProxyZoneSpec is needed for the async() test helper but could not be found. ' + 'Please make sure that your environment includes zone.js/dist/proxy.js');\n  }\n\n  var proxyZoneSpec = ProxyZoneSpec.get();\n  ProxyZoneSpec.assertPresent(); // We need to create the AsyncTestZoneSpec outside the ProxyZone.\n  // If we do it in ProxyZone then we will get to infinite recursion.\n\n  var proxyZone = Zone.current.getZoneWith('ProxyZoneSpec');\n  var previousDelegate = proxyZoneSpec.getDelegate();\n  proxyZone.parent.run(function () {\n    var testZoneSpec = new AsyncTestZoneSpec(function () {\n      // Need to restore the original zone.\n      currentZone.run(function () {\n        if (proxyZoneSpec.getDelegate() == testZoneSpec) {\n          // Only reset the zone spec if it's sill this one. Otherwise, assume it's OK.\n          proxyZoneSpec.setDelegate(previousDelegate);\n        }\n\n        finishCallback();\n      });\n    }, function (error) {\n      // Need to restore the original zone.\n      currentZone.run(function () {\n        if (proxyZoneSpec.getDelegate() == testZoneSpec) {\n          // Only reset the zone spec if it's sill this one. Otherwise, assume it's OK.\n          proxyZoneSpec.setDelegate(previousDelegate);\n        }\n\n        failCallback(error);\n      });\n    }, 'test');\n    proxyZoneSpec.setDelegate(testZoneSpec);\n  });\n  return Zone.current.runGuarded(fn, context);\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Wraps a test function in an asynchronous test zone. The test will automatically\n * complete when all asynchronous calls within this zone are done. Can be used\n * to wrap an {@link inject} call.\n *\n * Example:\n *\n * ```\n * it('...', waitForAsync(inject([AClass], (object) => {\n *   object.doSomething.then(() => {\n *     expect(...);\n *   })\n * });\n * ```\n *\n * @publicApi\n */\n\n\nfunction waitForAsync(fn) {\n  var _Zone = typeof Zone !== 'undefined' ? Zone : null;\n\n  if (!_Zone) {\n    return function () {\n      return Promise.reject('Zone is needed for the waitForAsync() test helper but could not be found. ' + 'Please make sure that your environment includes zone.js/dist/zone.js');\n    };\n  }\n\n  var asyncTest = _Zone && _Zone[_Zone.__symbol__('asyncTest')];\n\n  if (typeof asyncTest === 'function') {\n    return asyncTest(fn);\n  } // not using new version of zone.js\n  // TODO @JiaLiPassion, remove this after all library updated to\n  // newest version of zone.js(0.8.25)\n\n\n  return asyncFallback(fn);\n}\n/**\n * @deprecated use `waitForAsync()`, (expected removal in v12)\n * @see {@link waitForAsync}\n * @publicApi\n * */\n\n\nfunction async(fn) {\n  return waitForAsync(fn);\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Fixture for debugging and testing a component.\n *\n * @publicApi\n */\n\n\nvar ComponentFixture = /*#__PURE__*/function () {\n  function ComponentFixture(componentRef, ngZone, _autoDetect) {\n    var _this2 = this;\n\n    _classCallCheck(this, ComponentFixture);\n\n    this.componentRef = componentRef;\n    this.ngZone = ngZone;\n    this._autoDetect = _autoDetect;\n    this._isStable = true;\n    this._isDestroyed = false;\n    this._resolve = null;\n    this._promise = null;\n    this._onUnstableSubscription = null;\n    this._onStableSubscription = null;\n    this._onMicrotaskEmptySubscription = null;\n    this._onErrorSubscription = null;\n    this.changeDetectorRef = componentRef.changeDetectorRef;\n    this.elementRef = componentRef.location;\n    this.debugElement = getDebugNode(this.elementRef.nativeElement);\n    this.componentInstance = componentRef.instance;\n    this.nativeElement = this.elementRef.nativeElement;\n    this.componentRef = componentRef;\n    this.ngZone = ngZone;\n\n    if (ngZone) {\n      // Create subscriptions outside the NgZone so that the callbacks run oustide\n      // of NgZone.\n      ngZone.runOutsideAngular(function () {\n        _this2._onUnstableSubscription = ngZone.onUnstable.subscribe({\n          next: function next() {\n            _this2._isStable = false;\n          }\n        });\n        _this2._onMicrotaskEmptySubscription = ngZone.onMicrotaskEmpty.subscribe({\n          next: function next() {\n            if (_this2._autoDetect) {\n              // Do a change detection run with checkNoChanges set to true to check\n              // there are no changes on the second run.\n              _this2.detectChanges(true);\n            }\n          }\n        });\n        _this2._onStableSubscription = ngZone.onStable.subscribe({\n          next: function next() {\n            _this2._isStable = true; // Check whether there is a pending whenStable() completer to resolve.\n\n            if (_this2._promise !== null) {\n              // If so check whether there are no pending macrotasks before resolving.\n              // Do this check in the next tick so that ngZone gets a chance to update the state of\n              // pending macrotasks.\n              scheduleMicroTask(function () {\n                if (!ngZone.hasPendingMacrotasks) {\n                  if (_this2._promise !== null) {\n                    _this2._resolve(true);\n\n                    _this2._resolve = null;\n                    _this2._promise = null;\n                  }\n                }\n              });\n            }\n          }\n        });\n        _this2._onErrorSubscription = ngZone.onError.subscribe({\n          next: function next(error) {\n            throw error;\n          }\n        });\n      });\n    }\n  }\n\n  _createClass(ComponentFixture, [{\n    key: \"_tick\",\n    value: function _tick(checkNoChanges) {\n      this.changeDetectorRef.detectChanges();\n\n      if (checkNoChanges) {\n        this.checkNoChanges();\n      }\n    }\n    /**\n     * Trigger a change detection cycle for the component.\n     */\n\n  }, {\n    key: \"detectChanges\",\n    value: function detectChanges() {\n      var _this3 = this;\n\n      var checkNoChanges = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n\n      if (this.ngZone != null) {\n        // Run the change detection inside the NgZone so that any async tasks as part of the change\n        // detection are captured by the zone and can be waited for in isStable.\n        this.ngZone.run(function () {\n          _this3._tick(checkNoChanges);\n        });\n      } else {\n        // Running without zone. Just do the change detection.\n        this._tick(checkNoChanges);\n      }\n    }\n    /**\n     * Do a change detection run to make sure there were no changes.\n     */\n\n  }, {\n    key: \"checkNoChanges\",\n    value: function checkNoChanges() {\n      this.changeDetectorRef.checkNoChanges();\n    }\n    /**\n     * Set whether the fixture should autodetect changes.\n     *\n     * Also runs detectChanges once so that any existing change is detected.\n     */\n\n  }, {\n    key: \"autoDetectChanges\",\n    value: function autoDetectChanges() {\n      var autoDetect = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n\n      if (this.ngZone == null) {\n        throw new Error('Cannot call autoDetectChanges when ComponentFixtureNoNgZone is set');\n      }\n\n      this._autoDetect = autoDetect;\n      this.detectChanges();\n    }\n    /**\n     * Return whether the fixture is currently stable or has async tasks that have not been completed\n     * yet.\n     */\n\n  }, {\n    key: \"isStable\",\n    value: function isStable() {\n      return this._isStable && !this.ngZone.hasPendingMacrotasks;\n    }\n    /**\n     * Get a promise that resolves when the fixture is stable.\n     *\n     * This can be used to resume testing after events have triggered asynchronous activity or\n     * asynchronous change detection.\n     */\n\n  }, {\n    key: \"whenStable\",\n    value: function whenStable() {\n      var _this4 = this;\n\n      if (this.isStable()) {\n        return Promise.resolve(false);\n      } else if (this._promise !== null) {\n        return this._promise;\n      } else {\n        this._promise = new Promise(function (res) {\n          _this4._resolve = res;\n        });\n        return this._promise;\n      }\n    }\n  }, {\n    key: \"_getRenderer\",\n    value: function _getRenderer() {\n      if (this._renderer === undefined) {\n        this._renderer = this.componentRef.injector.get(RendererFactory2, null);\n      }\n\n      return this._renderer;\n    }\n    /**\n     * Get a promise that resolves when the ui state is stable following animations.\n     */\n\n  }, {\n    key: \"whenRenderingDone\",\n    value: function whenRenderingDone() {\n      var renderer = this._getRenderer();\n\n      if (renderer && renderer.whenRenderingDone) {\n        return renderer.whenRenderingDone();\n      }\n\n      return this.whenStable();\n    }\n    /**\n     * Trigger component destruction.\n     */\n\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      if (!this._isDestroyed) {\n        this.componentRef.destroy();\n\n        if (this._onUnstableSubscription != null) {\n          this._onUnstableSubscription.unsubscribe();\n\n          this._onUnstableSubscription = null;\n        }\n\n        if (this._onStableSubscription != null) {\n          this._onStableSubscription.unsubscribe();\n\n          this._onStableSubscription = null;\n        }\n\n        if (this._onMicrotaskEmptySubscription != null) {\n          this._onMicrotaskEmptySubscription.unsubscribe();\n\n          this._onMicrotaskEmptySubscription = null;\n        }\n\n        if (this._onErrorSubscription != null) {\n          this._onErrorSubscription.unsubscribe();\n\n          this._onErrorSubscription = null;\n        }\n\n        this._isDestroyed = true;\n      }\n    }\n  }]);\n\n  return ComponentFixture;\n}();\n\nfunction scheduleMicroTask(fn) {\n  Zone.current.scheduleMicroTask('scheduleMicrotask', fn);\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * fakeAsync has been moved to zone.js\n * this file is for fallback in case old version of zone.js is used\n */\n\n\nvar _Zone = typeof Zone !== 'undefined' ? Zone : null;\n\nvar FakeAsyncTestZoneSpec = _Zone && _Zone['FakeAsyncTestZoneSpec'];\nvar ProxyZoneSpec = _Zone && _Zone['ProxyZoneSpec'];\nvar _fakeAsyncTestZoneSpec = null;\n/**\n * Clears out the shared fake async zone for a test.\n * To be called in a global `beforeEach`.\n *\n * @publicApi\n */\n\nfunction resetFakeAsyncZoneFallback() {\n  if (_fakeAsyncTestZoneSpec) {\n    _fakeAsyncTestZoneSpec.unlockDatePatch();\n  }\n\n  _fakeAsyncTestZoneSpec = null; // in node.js testing we may not have ProxyZoneSpec in which case there is nothing to reset.\n\n  ProxyZoneSpec && ProxyZoneSpec.assertPresent().resetDelegate();\n}\n\nvar _inFakeAsyncCall = false;\n/**\n * Wraps a function to be executed in the fakeAsync zone:\n * - microtasks are manually executed by calling `flushMicrotasks()`,\n * - timers are synchronous, `tick()` simulates the asynchronous passage of time.\n *\n * If there are any pending timers at the end of the function, an exception will be thrown.\n *\n * Can be used to wrap inject() calls.\n *\n * @usageNotes\n * ### Example\n *\n * {@example core/testing/ts/fake_async.ts region='basic'}\n *\n * @param fn\n * @returns The function wrapped to be executed in the fakeAsync zone\n *\n * @publicApi\n */\n\nfunction fakeAsyncFallback(fn) {\n  // Not using an arrow function to preserve context passed from call site\n  return function () {\n    var proxyZoneSpec = ProxyZoneSpec.assertPresent();\n\n    if (_inFakeAsyncCall) {\n      throw new Error('fakeAsync() calls can not be nested');\n    }\n\n    _inFakeAsyncCall = true;\n\n    try {\n      if (!_fakeAsyncTestZoneSpec) {\n        if (proxyZoneSpec.getDelegate() instanceof FakeAsyncTestZoneSpec) {\n          throw new Error('fakeAsync() calls can not be nested');\n        }\n\n        _fakeAsyncTestZoneSpec = new FakeAsyncTestZoneSpec();\n      }\n\n      var res;\n      var lastProxyZoneSpec = proxyZoneSpec.getDelegate();\n      proxyZoneSpec.setDelegate(_fakeAsyncTestZoneSpec);\n\n      _fakeAsyncTestZoneSpec.lockDatePatch();\n\n      try {\n        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n\n        res = fn.apply(this, args);\n        flushMicrotasksFallback();\n      } finally {\n        proxyZoneSpec.setDelegate(lastProxyZoneSpec);\n      }\n\n      if (_fakeAsyncTestZoneSpec.pendingPeriodicTimers.length > 0) {\n        throw new Error(\"\".concat(_fakeAsyncTestZoneSpec.pendingPeriodicTimers.length, \" \") + \"periodic timer(s) still in the queue.\");\n      }\n\n      if (_fakeAsyncTestZoneSpec.pendingTimers.length > 0) {\n        throw new Error(\"\".concat(_fakeAsyncTestZoneSpec.pendingTimers.length, \" timer(s) still in the queue.\"));\n      }\n\n      return res;\n    } finally {\n      _inFakeAsyncCall = false;\n      resetFakeAsyncZoneFallback();\n    }\n  };\n}\n\nfunction _getFakeAsyncZoneSpec() {\n  if (_fakeAsyncTestZoneSpec == null) {\n    throw new Error('The code should be running in the fakeAsync zone to call this function');\n  }\n\n  return _fakeAsyncTestZoneSpec;\n}\n/**\n * Simulates the asynchronous passage of time for the timers in the fakeAsync zone.\n *\n * The microtasks queue is drained at the very start of this function and after any timer callback\n * has been executed.\n *\n * @usageNotes\n * ### Example\n *\n * {@example core/testing/ts/fake_async.ts region='basic'}\n *\n * @publicApi\n */\n\n\nfunction tickFallback() {\n  var millis = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n  var tickOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n    processNewMacroTasksSynchronously: true\n  };\n\n  _getFakeAsyncZoneSpec().tick(millis, null, tickOptions);\n}\n/**\n * Simulates the asynchronous passage of time for the timers in the fakeAsync zone by\n * draining the macrotask queue until it is empty. The returned value is the milliseconds\n * of time that would have been elapsed.\n *\n * @param maxTurns\n * @returns The simulated time elapsed, in millis.\n *\n * @publicApi\n */\n\n\nfunction flushFallback(maxTurns) {\n  return _getFakeAsyncZoneSpec().flush(maxTurns);\n}\n/**\n * Discard all remaining periodic tasks.\n *\n * @publicApi\n */\n\n\nfunction discardPeriodicTasksFallback() {\n  var zoneSpec = _getFakeAsyncZoneSpec();\n\n  zoneSpec.pendingPeriodicTimers.length = 0;\n}\n/**\n * Flush any pending microtasks.\n *\n * @publicApi\n */\n\n\nfunction flushMicrotasksFallback() {\n  _getFakeAsyncZoneSpec().flushMicrotasks();\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nvar _Zone$1 = typeof Zone !== 'undefined' ? Zone : null;\n\nvar fakeAsyncTestModule = _Zone$1 && _Zone$1[_Zone$1.__symbol__('fakeAsyncTest')];\n/**\n * Clears out the shared fake async zone for a test.\n * To be called in a global `beforeEach`.\n *\n * @publicApi\n */\n\n\nfunction resetFakeAsyncZone() {\n  if (fakeAsyncTestModule) {\n    return fakeAsyncTestModule.resetFakeAsyncZone();\n  } else {\n    return resetFakeAsyncZoneFallback();\n  }\n}\n/**\n * Wraps a function to be executed in the fakeAsync zone:\n * - microtasks are manually executed by calling `flushMicrotasks()`,\n * - timers are synchronous, `tick()` simulates the asynchronous passage of time.\n *\n * If there are any pending timers at the end of the function, an exception will be thrown.\n *\n * Can be used to wrap inject() calls.\n *\n * @usageNotes\n * ### Example\n *\n * {@example core/testing/ts/fake_async.ts region='basic'}\n *\n * @param fn\n * @returns The function wrapped to be executed in the fakeAsync zone\n *\n * @publicApi\n */\n\n\nfunction fakeAsync(fn) {\n  if (fakeAsyncTestModule) {\n    return fakeAsyncTestModule.fakeAsync(fn);\n  } else {\n    return fakeAsyncFallback(fn);\n  }\n}\n/**\n * Simulates the asynchronous passage of time for the timers in the fakeAsync zone.\n *\n * The microtasks queue is drained at the very start of this function and after any timer callback\n * has been executed.\n *\n * @usageNotes\n * ### Example\n *\n * {@example core/testing/ts/fake_async.ts region='basic'}\n *\n * @param millis, the number of millisecond to advance the virtual timer\n * @param tickOptions, the options of tick with a flag called\n * processNewMacroTasksSynchronously, whether to invoke the new macroTasks, by default is\n * false, means the new macroTasks will be invoked\n *\n * For example,\n *\n * it ('test with nested setTimeout', fakeAsync(() => {\n *   let nestedTimeoutInvoked = false;\n *   function funcWithNestedTimeout() {\n *     setTimeout(() => {\n *       nestedTimeoutInvoked = true;\n *     });\n *   };\n *   setTimeout(funcWithNestedTimeout);\n *   tick();\n *   expect(nestedTimeoutInvoked).toBe(true);\n * }));\n *\n * in this case, we have a nested timeout (new macroTask), when we tick, both the\n * funcWithNestedTimeout and the nested timeout both will be invoked.\n *\n * it ('test with nested setTimeout', fakeAsync(() => {\n *   let nestedTimeoutInvoked = false;\n *   function funcWithNestedTimeout() {\n *     setTimeout(() => {\n *       nestedTimeoutInvoked = true;\n *     });\n *   };\n *   setTimeout(funcWithNestedTimeout);\n *   tick(0, {processNewMacroTasksSynchronously: false});\n *   expect(nestedTimeoutInvoked).toBe(false);\n * }));\n *\n * if we pass the tickOptions with processNewMacroTasksSynchronously to be false, the nested timeout\n * will not be invoked.\n *\n *\n * @publicApi\n */\n\n\nfunction tick() {\n  var millis = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n  var tickOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n    processNewMacroTasksSynchronously: true\n  };\n\n  if (fakeAsyncTestModule) {\n    return fakeAsyncTestModule.tick(millis, tickOptions);\n  } else {\n    return tickFallback(millis, tickOptions);\n  }\n}\n/**\n * Simulates the asynchronous passage of time for the timers in the fakeAsync zone by\n * draining the macrotask queue until it is empty. The returned value is the milliseconds\n * of time that would have been elapsed.\n *\n * @param maxTurns\n * @returns The simulated time elapsed, in millis.\n *\n * @publicApi\n */\n\n\nfunction flush(maxTurns) {\n  if (fakeAsyncTestModule) {\n    return fakeAsyncTestModule.flush(maxTurns);\n  } else {\n    return flushFallback(maxTurns);\n  }\n}\n/**\n * Discard all remaining periodic tasks.\n *\n * @publicApi\n */\n\n\nfunction discardPeriodicTasks() {\n  if (fakeAsyncTestModule) {\n    return fakeAsyncTestModule.discardPeriodicTasks();\n  } else {\n    discardPeriodicTasksFallback();\n  }\n}\n/**\n * Flush any pending microtasks.\n *\n * @publicApi\n */\n\n\nfunction flushMicrotasks() {\n  if (fakeAsyncTestModule) {\n    return fakeAsyncTestModule.flushMicrotasks();\n  } else {\n    return flushMicrotasksFallback();\n  }\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Injectable completer that allows signaling completion of an asynchronous test. Used internally.\n */\n\n\nvar AsyncTestCompleter = /*#__PURE__*/function () {\n  function AsyncTestCompleter() {\n    var _this5 = this;\n\n    _classCallCheck(this, AsyncTestCompleter);\n\n    this._promise = new Promise(function (res, rej) {\n      _this5._resolve = res;\n      _this5._reject = rej;\n    });\n  }\n\n  _createClass(AsyncTestCompleter, [{\n    key: \"done\",\n    value: function done(value) {\n      this._resolve(value);\n    }\n  }, {\n    key: \"fail\",\n    value: function fail(error, stackTrace) {\n      this._reject(error);\n    }\n  }, {\n    key: \"promise\",\n    get: function get() {\n      return this._promise;\n    }\n  }]);\n\n  return AsyncTestCompleter;\n}();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Used to resolve resource URLs on `@Component` when used with JIT compilation.\n *\n * Example:\n * ```\n * @Component({\n *   selector: 'my-comp',\n *   templateUrl: 'my-comp.html', // This requires asynchronous resolution\n * })\n * class MyComponent{\n * }\n *\n * // Calling `renderComponent` will fail because `renderComponent` is a synchronous process\n * // and `MyComponent`'s `@Component.templateUrl` needs to be resolved asynchronously.\n *\n * // Calling `resolveComponentResources()` will resolve `@Component.templateUrl` into\n * // `@Component.template`, which allows `renderComponent` to proceed in a synchronous manner.\n *\n * // Use browser's `fetch()` function as the default resource resolution strategy.\n * resolveComponentResources(fetch).then(() => {\n *   // After resolution all URLs have been converted into `template` strings.\n *   renderComponent(MyComponent);\n * });\n *\n * ```\n *\n * NOTE: In AOT the resolution happens during compilation, and so there should be no need\n * to call this method outside JIT mode.\n *\n * @param resourceResolver a function which is responsible for returning a `Promise` to the\n * contents of the resolved URL. Browser's `fetch()` method is a good default implementation.\n */\n\n\nfunction resolveComponentResources(resourceResolver) {\n  // Store all promises which are fetching the resources.\n  var componentResolved = []; // Cache so that we don't fetch the same resource more than once.\n\n  var urlMap = new Map();\n\n  function cachedResourceResolve(url) {\n    var promise = urlMap.get(url);\n\n    if (!promise) {\n      var resp = resourceResolver(url);\n      urlMap.set(url, promise = resp.then(unwrapResponse));\n    }\n\n    return promise;\n  }\n\n  componentResourceResolutionQueue.forEach(function (component, type) {\n    var promises = [];\n\n    if (component.templateUrl) {\n      promises.push(cachedResourceResolve(component.templateUrl).then(function (template) {\n        component.template = template;\n      }));\n    }\n\n    var styleUrls = component.styleUrls;\n    var styles = component.styles || (component.styles = []);\n    var styleOffset = component.styles.length;\n    styleUrls && styleUrls.forEach(function (styleUrl, index) {\n      styles.push(''); // pre-allocate array.\n\n      promises.push(cachedResourceResolve(styleUrl).then(function (style) {\n        styles[styleOffset + index] = style;\n        styleUrls.splice(styleUrls.indexOf(styleUrl), 1);\n\n        if (styleUrls.length == 0) {\n          component.styleUrls = undefined;\n        }\n      }));\n    });\n    var fullyResolved = Promise.all(promises).then(function () {\n      return componentDefResolved(type);\n    });\n    componentResolved.push(fullyResolved);\n  });\n  clearResolutionOfComponentResourcesQueue();\n  return Promise.all(componentResolved).then(function () {\n    return undefined;\n  });\n}\n\nvar componentResourceResolutionQueue = new Map(); // Track when existing ɵcmp for a Type is waiting on resources.\n\nvar componentDefPendingResolution = new Set();\n\nfunction maybeQueueResolutionOfComponentResources(type, metadata) {\n  if (componentNeedsResolution(metadata)) {\n    componentResourceResolutionQueue.set(type, metadata);\n    componentDefPendingResolution.add(type);\n  }\n}\n\nfunction isComponentDefPendingResolution(type) {\n  return componentDefPendingResolution.has(type);\n}\n\nfunction componentNeedsResolution(component) {\n  return !!(component.templateUrl && !component.hasOwnProperty('template') || component.styleUrls && component.styleUrls.length);\n}\n\nfunction clearResolutionOfComponentResourcesQueue() {\n  var old = componentResourceResolutionQueue;\n  componentResourceResolutionQueue = new Map();\n  return old;\n}\n\nfunction _restoreComponentResolutionQueue(queue) {\n  componentDefPendingResolution.clear();\n  queue.forEach(function (_, type) {\n    return componentDefPendingResolution.add(type);\n  });\n  componentResourceResolutionQueue = queue;\n}\n\nfunction isComponentResourceResolutionQueueEmpty() {\n  return componentResourceResolutionQueue.size === 0;\n}\n\nfunction unwrapResponse(response) {\n  return typeof response == 'string' ? response : response.text();\n}\n\nfunction componentDefResolved(type) {\n  componentDefPendingResolution.delete(type);\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nvar _nextReferenceId = 0;\n\nvar MetadataOverrider = /*#__PURE__*/function () {\n  function MetadataOverrider() {\n    _classCallCheck(this, MetadataOverrider);\n\n    this._references = new Map();\n  }\n  /**\n   * Creates a new instance for the given metadata class\n   * based on an old instance and overrides.\n   */\n\n\n  _createClass(MetadataOverrider, [{\n    key: \"overrideMetadata\",\n    value: function overrideMetadata(metadataClass, oldMetadata, override) {\n      var props = {};\n\n      if (oldMetadata) {\n        _valueProps(oldMetadata).forEach(function (prop) {\n          return props[prop] = oldMetadata[prop];\n        });\n      }\n\n      if (override.set) {\n        if (override.remove || override.add) {\n          throw new Error(\"Cannot set and add/remove \".concat(ɵstringify(metadataClass), \" at the same time!\"));\n        }\n\n        setMetadata(props, override.set);\n      }\n\n      if (override.remove) {\n        removeMetadata(props, override.remove, this._references);\n      }\n\n      if (override.add) {\n        addMetadata(props, override.add);\n      }\n\n      return new metadataClass(props);\n    }\n  }]);\n\n  return MetadataOverrider;\n}();\n\nfunction removeMetadata(metadata, remove, references) {\n  var removeObjects = new Set();\n\n  var _loop = function _loop(prop) {\n    var removeValue = remove[prop];\n\n    if (Array.isArray(removeValue)) {\n      removeValue.forEach(function (value) {\n        removeObjects.add(_propHashKey(prop, value, references));\n      });\n    } else {\n      removeObjects.add(_propHashKey(prop, removeValue, references));\n    }\n  };\n\n  for (var prop in remove) {\n    _loop(prop);\n  }\n\n  var _loop2 = function _loop2(_prop) {\n    var propValue = metadata[_prop];\n\n    if (Array.isArray(propValue)) {\n      metadata[_prop] = propValue.filter(function (value) {\n        return !removeObjects.has(_propHashKey(_prop, value, references));\n      });\n    } else {\n      if (removeObjects.has(_propHashKey(_prop, propValue, references))) {\n        metadata[_prop] = undefined;\n      }\n    }\n  };\n\n  for (var _prop in metadata) {\n    _loop2(_prop);\n  }\n}\n\nfunction addMetadata(metadata, add) {\n  for (var prop in add) {\n    var addValue = add[prop];\n    var propValue = metadata[prop];\n\n    if (propValue != null && Array.isArray(propValue)) {\n      metadata[prop] = propValue.concat(addValue);\n    } else {\n      metadata[prop] = addValue;\n    }\n  }\n}\n\nfunction setMetadata(metadata, set) {\n  for (var prop in set) {\n    metadata[prop] = set[prop];\n  }\n}\n\nfunction _propHashKey(propName, propValue, references) {\n  var replacer = function replacer(key, value) {\n    if (typeof value === 'function') {\n      value = _serializeReference(value, references);\n    }\n\n    return value;\n  };\n\n  return \"\".concat(propName, \":\").concat(JSON.stringify(propValue, replacer));\n}\n\nfunction _serializeReference(ref, references) {\n  var id = references.get(ref);\n\n  if (!id) {\n    id = \"\".concat(ɵstringify(ref)).concat(_nextReferenceId++);\n    references.set(ref, id);\n  }\n\n  return id;\n}\n\nfunction _valueProps(obj) {\n  var props = []; // regular public props\n\n  Object.keys(obj).forEach(function (prop) {\n    if (!prop.startsWith('_')) {\n      props.push(prop);\n    }\n  }); // getters\n\n  var proto = obj;\n\n  while (proto = Object.getPrototypeOf(proto)) {\n    Object.keys(proto).forEach(function (protoProp) {\n      var desc = Object.getOwnPropertyDescriptor(proto, protoProp);\n\n      if (!protoProp.startsWith('_') && desc && 'get' in desc) {\n        props.push(protoProp);\n      }\n    });\n  }\n\n  return props;\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nvar reflection = new ɵReflectionCapabilities();\n/**\n * Allows to override ivy metadata for tests (via the `TestBed`).\n */\n\nvar OverrideResolver = /*#__PURE__*/function () {\n  function OverrideResolver() {\n    _classCallCheck(this, OverrideResolver);\n\n    this.overrides = new Map();\n    this.resolved = new Map();\n  }\n\n  _createClass(OverrideResolver, [{\n    key: \"addOverride\",\n    value: function addOverride(type, override) {\n      var overrides = this.overrides.get(type) || [];\n      overrides.push(override);\n      this.overrides.set(type, overrides);\n      this.resolved.delete(type);\n    }\n  }, {\n    key: \"setOverrides\",\n    value: function setOverrides(overrides) {\n      var _this6 = this;\n\n      this.overrides.clear();\n      overrides.forEach(function (_ref) {\n        var _ref2 = _slicedToArray(_ref, 2),\n            type = _ref2[0],\n            override = _ref2[1];\n\n        _this6.addOverride(type, override);\n      });\n    }\n  }, {\n    key: \"getAnnotation\",\n    value: function getAnnotation(type) {\n      var annotations = reflection.annotations(type); // Try to find the nearest known Type annotation and make sure that this annotation is an\n      // instance of the type we are looking for, so we can use it for resolution. Note: there might\n      // be multiple known annotations found due to the fact that Components can extend Directives (so\n      // both Directive and Component annotations would be present), so we always check if the known\n      // annotation has the right type.\n\n      for (var i = annotations.length - 1; i >= 0; i--) {\n        var annotation = annotations[i];\n        var isKnownType = annotation instanceof Directive || annotation instanceof Component || annotation instanceof Pipe || annotation instanceof NgModule;\n\n        if (isKnownType) {\n          return annotation instanceof this.type ? annotation : null;\n        }\n      }\n\n      return null;\n    }\n  }, {\n    key: \"resolve\",\n    value: function resolve(type) {\n      var _this7 = this;\n\n      var resolved = this.resolved.get(type) || null;\n\n      if (!resolved) {\n        resolved = this.getAnnotation(type);\n\n        if (resolved) {\n          var overrides = this.overrides.get(type);\n\n          if (overrides) {\n            var overrider = new MetadataOverrider();\n            overrides.forEach(function (override) {\n              resolved = overrider.overrideMetadata(_this7.type, resolved, override);\n            });\n          }\n        }\n\n        this.resolved.set(type, resolved);\n      }\n\n      return resolved;\n    }\n  }]);\n\n  return OverrideResolver;\n}();\n\nvar DirectiveResolver = /*#__PURE__*/function (_OverrideResolver) {\n  _inherits(DirectiveResolver, _OverrideResolver);\n\n  var _super = _createSuper(DirectiveResolver);\n\n  function DirectiveResolver() {\n    _classCallCheck(this, DirectiveResolver);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(DirectiveResolver, [{\n    key: \"type\",\n    get: function get() {\n      return Directive;\n    }\n  }]);\n\n  return DirectiveResolver;\n}(OverrideResolver);\n\nvar ComponentResolver = /*#__PURE__*/function (_OverrideResolver2) {\n  _inherits(ComponentResolver, _OverrideResolver2);\n\n  var _super2 = _createSuper(ComponentResolver);\n\n  function ComponentResolver() {\n    _classCallCheck(this, ComponentResolver);\n\n    return _super2.apply(this, arguments);\n  }\n\n  _createClass(ComponentResolver, [{\n    key: \"type\",\n    get: function get() {\n      return Component;\n    }\n  }]);\n\n  return ComponentResolver;\n}(OverrideResolver);\n\nvar PipeResolver = /*#__PURE__*/function (_OverrideResolver3) {\n  _inherits(PipeResolver, _OverrideResolver3);\n\n  var _super3 = _createSuper(PipeResolver);\n\n  function PipeResolver() {\n    _classCallCheck(this, PipeResolver);\n\n    return _super3.apply(this, arguments);\n  }\n\n  _createClass(PipeResolver, [{\n    key: \"type\",\n    get: function get() {\n      return Pipe;\n    }\n  }]);\n\n  return PipeResolver;\n}(OverrideResolver);\n\nvar NgModuleResolver = /*#__PURE__*/function (_OverrideResolver4) {\n  _inherits(NgModuleResolver, _OverrideResolver4);\n\n  var _super4 = _createSuper(NgModuleResolver);\n\n  function NgModuleResolver() {\n    _classCallCheck(this, NgModuleResolver);\n\n    return _super4.apply(this, arguments);\n  }\n\n  _createClass(NgModuleResolver, [{\n    key: \"type\",\n    get: function get() {\n      return NgModule;\n    }\n  }]);\n\n  return NgModuleResolver;\n}(OverrideResolver);\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nvar TestingModuleOverride;\n\n(function (TestingModuleOverride) {\n  TestingModuleOverride[TestingModuleOverride[\"DECLARATION\"] = 0] = \"DECLARATION\";\n  TestingModuleOverride[TestingModuleOverride[\"OVERRIDE_TEMPLATE\"] = 1] = \"OVERRIDE_TEMPLATE\";\n})(TestingModuleOverride || (TestingModuleOverride = {}));\n\nfunction isTestingModuleOverride(value) {\n  return value === TestingModuleOverride.DECLARATION || value === TestingModuleOverride.OVERRIDE_TEMPLATE;\n}\n\nvar R3TestBedCompiler = /*#__PURE__*/function () {\n  function R3TestBedCompiler(platform, additionalModuleTypes) {\n    _classCallCheck(this, R3TestBedCompiler);\n\n    this.platform = platform;\n    this.additionalModuleTypes = additionalModuleTypes;\n    this.originalComponentResolutionQueue = null; // Testing module configuration\n\n    this.declarations = [];\n    this.imports = [];\n    this.providers = [];\n    this.schemas = []; // Queues of components/directives/pipes that should be recompiled.\n\n    this.pendingComponents = new Set();\n    this.pendingDirectives = new Set();\n    this.pendingPipes = new Set(); // Keep track of all components and directives, so we can patch Providers onto defs later.\n\n    this.seenComponents = new Set();\n    this.seenDirectives = new Set(); // Keep track of overridden modules, so that we can collect all affected ones in the module tree.\n\n    this.overriddenModules = new Set(); // Store resolved styles for Components that have template overrides present and `styleUrls`\n    // defined at the same time.\n\n    this.existingComponentStyles = new Map();\n    this.resolvers = initResolvers();\n    this.componentToModuleScope = new Map(); // Map that keeps initial version of component/directive/pipe defs in case\n    // we compile a Type again, thus overriding respective static fields. This is\n    // required to make sure we restore defs to their initial states between test runs\n    // TODO: we should support the case with multiple defs on a type\n\n    this.initialNgDefs = new Map(); // Array that keeps cleanup operations for initial versions of component/directive/pipe/module\n    // defs in case TestBed makes changes to the originals.\n\n    this.defCleanupOps = [];\n    this._injector = null;\n    this.compilerProviders = null;\n    this.providerOverrides = [];\n    this.rootProviderOverrides = []; // Overrides for injectables with `{providedIn: SomeModule}` need to be tracked and added to that\n    // module's provider list.\n\n    this.providerOverridesByModule = new Map();\n    this.providerOverridesByToken = new Map();\n    this.moduleProvidersOverridden = new Set();\n    this.testModuleRef = null;\n\n    var DynamicTestModule = /*#__PURE__*/_createClass(function DynamicTestModule() {\n      _classCallCheck(this, DynamicTestModule);\n    });\n\n    this.testModuleType = DynamicTestModule;\n  }\n\n  _createClass(R3TestBedCompiler, [{\n    key: \"setCompilerProviders\",\n    value: function setCompilerProviders(providers) {\n      this.compilerProviders = providers;\n      this._injector = null;\n    }\n  }, {\n    key: \"configureTestingModule\",\n    value: function configureTestingModule(moduleDef) {\n      // Enqueue any compilation tasks for the directly declared component.\n      if (moduleDef.declarations !== undefined) {\n        var _this$declarations;\n\n        this.queueTypeArray(moduleDef.declarations, TestingModuleOverride.DECLARATION);\n\n        (_this$declarations = this.declarations).push.apply(_this$declarations, _toConsumableArray(moduleDef.declarations));\n      } // Enqueue any compilation tasks for imported modules.\n\n\n      if (moduleDef.imports !== undefined) {\n        var _this$imports;\n\n        this.queueTypesFromModulesArray(moduleDef.imports);\n\n        (_this$imports = this.imports).push.apply(_this$imports, _toConsumableArray(moduleDef.imports));\n      }\n\n      if (moduleDef.providers !== undefined) {\n        var _this$providers;\n\n        (_this$providers = this.providers).push.apply(_this$providers, _toConsumableArray(moduleDef.providers));\n      }\n\n      if (moduleDef.schemas !== undefined) {\n        var _this$schemas;\n\n        (_this$schemas = this.schemas).push.apply(_this$schemas, _toConsumableArray(moduleDef.schemas));\n      }\n    }\n  }, {\n    key: \"overrideModule\",\n    value: function overrideModule(ngModule, override) {\n      this.overriddenModules.add(ngModule); // Compile the module right away.\n\n      this.resolvers.module.addOverride(ngModule, override);\n      var metadata = this.resolvers.module.resolve(ngModule);\n\n      if (metadata === null) {\n        throw invalidTypeError(ngModule.name, 'NgModule');\n      }\n\n      this.recompileNgModule(ngModule, metadata); // At this point, the module has a valid module def (ɵmod), but the override may have introduced\n      // new declarations or imported modules. Ingest any possible new types and add them to the\n      // current queue.\n\n      this.queueTypesFromModulesArray([ngModule]);\n    }\n  }, {\n    key: \"overrideComponent\",\n    value: function overrideComponent(component, override) {\n      this.resolvers.component.addOverride(component, override);\n      this.pendingComponents.add(component);\n    }\n  }, {\n    key: \"overrideDirective\",\n    value: function overrideDirective(directive, override) {\n      this.resolvers.directive.addOverride(directive, override);\n      this.pendingDirectives.add(directive);\n    }\n  }, {\n    key: \"overridePipe\",\n    value: function overridePipe(pipe, override) {\n      this.resolvers.pipe.addOverride(pipe, override);\n      this.pendingPipes.add(pipe);\n    }\n  }, {\n    key: \"overrideProvider\",\n    value: function overrideProvider(token, provider) {\n      var providerDef;\n\n      if (provider.useFactory !== undefined) {\n        providerDef = {\n          provide: token,\n          useFactory: provider.useFactory,\n          deps: provider.deps || [],\n          multi: provider.multi\n        };\n      } else if (provider.useValue !== undefined) {\n        providerDef = {\n          provide: token,\n          useValue: provider.useValue,\n          multi: provider.multi\n        };\n      } else {\n        providerDef = {\n          provide: token\n        };\n      }\n\n      var injectableDef = typeof token !== 'string' ? ɵgetInjectableDef(token) : null;\n      var isRoot = injectableDef !== null && injectableDef.providedIn === 'root';\n      var overridesBucket = isRoot ? this.rootProviderOverrides : this.providerOverrides;\n      overridesBucket.push(providerDef); // Keep overrides grouped by token as well for fast lookups using token\n\n      this.providerOverridesByToken.set(token, providerDef);\n\n      if (injectableDef !== null && injectableDef.providedIn !== null && typeof injectableDef.providedIn !== 'string') {\n        var existingOverrides = this.providerOverridesByModule.get(injectableDef.providedIn);\n\n        if (existingOverrides !== undefined) {\n          existingOverrides.push(providerDef);\n        } else {\n          this.providerOverridesByModule.set(injectableDef.providedIn, [providerDef]);\n        }\n      }\n    }\n  }, {\n    key: \"overrideTemplateUsingTestingModule\",\n    value: function overrideTemplateUsingTestingModule(type, template) {\n      var _this8 = this;\n\n      var def = type[ɵNG_COMP_DEF];\n\n      var hasStyleUrls = function hasStyleUrls() {\n        var metadata = _this8.resolvers.component.resolve(type);\n\n        return !!metadata.styleUrls && metadata.styleUrls.length > 0;\n      };\n\n      var overrideStyleUrls = !!def && !isComponentDefPendingResolution(type) && hasStyleUrls(); // In Ivy, compiling a component does not require knowing the module providing the\n      // component's scope, so overrideTemplateUsingTestingModule can be implemented purely via\n      // overrideComponent. Important: overriding template requires full Component re-compilation,\n      // which may fail in case styleUrls are also present (thus Component is considered as required\n      // resolution). In order to avoid this, we preemptively set styleUrls to an empty array,\n      // preserve current styles available on Component def and restore styles back once compilation\n      // is complete.\n\n      var override = overrideStyleUrls ? {\n        template: template,\n        styles: [],\n        styleUrls: []\n      } : {\n        template: template\n      };\n      this.overrideComponent(type, {\n        set: override\n      });\n\n      if (overrideStyleUrls && def.styles && def.styles.length > 0) {\n        this.existingComponentStyles.set(type, def.styles);\n      } // Set the component's scope to be the testing module.\n\n\n      this.componentToModuleScope.set(type, TestingModuleOverride.OVERRIDE_TEMPLATE);\n    }\n  }, {\n    key: \"compileComponents\",\n    value: function compileComponents() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var _this9 = this;\n\n        var needsAsyncResources, resourceLoader, resolver;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                this.clearComponentResolutionQueue(); // Run compilers for all queued types.\n\n                needsAsyncResources = this.compileTypesSync(); // compileComponents() should not be async unless it needs to be.\n\n                if (!needsAsyncResources) {\n                  _context.next = 6;\n                  break;\n                }\n\n                resolver = function resolver(url) {\n                  if (!resourceLoader) {\n                    resourceLoader = _this9.injector.get(ResourceLoader);\n                  }\n\n                  return Promise.resolve(resourceLoader.get(url));\n                };\n\n                _context.next = 6;\n                return resolveComponentResources(resolver);\n\n              case 6:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n    }\n  }, {\n    key: \"finalize\",\n    value: function finalize() {\n      // One last compile\n      this.compileTypesSync(); // Create the testing module itself.\n\n      this.compileTestModule();\n      this.applyTransitiveScopes();\n      this.applyProviderOverrides(); // Patch previously stored `styles` Component values (taken from ɵcmp), in case these\n      // Components have `styleUrls` fields defined and template override was requested.\n\n      this.patchComponentsWithExistingStyles(); // Clear the componentToModuleScope map, so that future compilations don't reset the scope of\n      // every component.\n\n      this.componentToModuleScope.clear();\n      var parentInjector = this.platform.injector;\n      this.testModuleRef = new ɵRender3NgModuleRef(this.testModuleType, parentInjector); // ApplicationInitStatus.runInitializers() is marked @internal to core.\n      // Cast it to any before accessing it.\n\n      this.testModuleRef.injector.get(ApplicationInitStatus).runInitializers(); // Set locale ID after running app initializers, since locale information might be updated while\n      // running initializers. This is also consistent with the execution order while bootstrapping an\n      // app (see `packages/core/src/application_ref.ts` file).\n\n      var localeId = this.testModuleRef.injector.get(LOCALE_ID, ɵDEFAULT_LOCALE_ID);\n      ɵsetLocaleId(localeId);\n      return this.testModuleRef;\n    }\n    /**\n     * @internal\n     */\n\n  }, {\n    key: \"_compileNgModuleSync\",\n    value: function _compileNgModuleSync(moduleType) {\n      this.queueTypesFromModulesArray([moduleType]);\n      this.compileTypesSync();\n      this.applyProviderOverrides();\n      this.applyProviderOverridesToModule(moduleType);\n      this.applyTransitiveScopes();\n    }\n    /**\n     * @internal\n     */\n\n  }, {\n    key: \"_compileNgModuleAsync\",\n    value: function _compileNgModuleAsync(moduleType) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                this.queueTypesFromModulesArray([moduleType]);\n                _context2.next = 3;\n                return this.compileComponents();\n\n              case 3:\n                this.applyProviderOverrides();\n                this.applyProviderOverridesToModule(moduleType);\n                this.applyTransitiveScopes();\n\n              case 6:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n    }\n    /**\n     * @internal\n     */\n\n  }, {\n    key: \"_getModuleResolver\",\n    value: function _getModuleResolver() {\n      return this.resolvers.module;\n    }\n    /**\n     * @internal\n     */\n\n  }, {\n    key: \"_getComponentFactories\",\n    value: function _getComponentFactories(moduleType) {\n      var _this10 = this;\n\n      return maybeUnwrapFn(moduleType.ɵmod.declarations).reduce(function (factories, declaration) {\n        var componentDef = declaration.ɵcmp;\n        componentDef && factories.push(new ɵRender3ComponentFactory(componentDef, _this10.testModuleRef));\n        return factories;\n      }, []);\n    }\n  }, {\n    key: \"compileTypesSync\",\n    value: function compileTypesSync() {\n      var _this11 = this;\n\n      // Compile all queued components, directives, pipes.\n      var needsAsyncResources = false;\n      this.pendingComponents.forEach(function (declaration) {\n        needsAsyncResources = needsAsyncResources || isComponentDefPendingResolution(declaration);\n\n        var metadata = _this11.resolvers.component.resolve(declaration);\n\n        if (metadata === null) {\n          throw invalidTypeError(declaration.name, 'Component');\n        }\n\n        _this11.maybeStoreNgDef(ɵNG_COMP_DEF, declaration);\n\n        ɵcompileComponent(declaration, metadata);\n      });\n      this.pendingComponents.clear();\n      this.pendingDirectives.forEach(function (declaration) {\n        var metadata = _this11.resolvers.directive.resolve(declaration);\n\n        if (metadata === null) {\n          throw invalidTypeError(declaration.name, 'Directive');\n        }\n\n        _this11.maybeStoreNgDef(ɵNG_DIR_DEF, declaration);\n\n        ɵcompileDirective(declaration, metadata);\n      });\n      this.pendingDirectives.clear();\n      this.pendingPipes.forEach(function (declaration) {\n        var metadata = _this11.resolvers.pipe.resolve(declaration);\n\n        if (metadata === null) {\n          throw invalidTypeError(declaration.name, 'Pipe');\n        }\n\n        _this11.maybeStoreNgDef(ɵNG_PIPE_DEF, declaration);\n\n        ɵcompilePipe(declaration, metadata);\n      });\n      this.pendingPipes.clear();\n      return needsAsyncResources;\n    }\n  }, {\n    key: \"applyTransitiveScopes\",\n    value: function applyTransitiveScopes() {\n      var _this12 = this;\n\n      if (this.overriddenModules.size > 0) {\n        // Module overrides (via `TestBed.overrideModule`) might affect scopes that were previously\n        // calculated and stored in `transitiveCompileScopes`. If module overrides are present,\n        // collect all affected modules and reset scopes to force their re-calculatation.\n        var testingModuleDef = this.testModuleType[ɵNG_MOD_DEF];\n        var affectedModules = this.collectModulesAffectedByOverrides(testingModuleDef.imports);\n\n        if (affectedModules.size > 0) {\n          affectedModules.forEach(function (moduleType) {\n            _this12.storeFieldOfDefOnType(moduleType, ɵNG_MOD_DEF, 'transitiveCompileScopes');\n\n            moduleType[ɵNG_MOD_DEF].transitiveCompileScopes = null;\n          });\n        }\n      }\n\n      var moduleToScope = new Map();\n\n      var getScopeOfModule = function getScopeOfModule(moduleType) {\n        if (!moduleToScope.has(moduleType)) {\n          var isTestingModule = isTestingModuleOverride(moduleType);\n          var realType = isTestingModule ? _this12.testModuleType : moduleType;\n          moduleToScope.set(moduleType, ɵtransitiveScopesFor(realType));\n        }\n\n        return moduleToScope.get(moduleType);\n      };\n\n      this.componentToModuleScope.forEach(function (moduleType, componentType) {\n        var moduleScope = getScopeOfModule(moduleType);\n\n        _this12.storeFieldOfDefOnType(componentType, ɵNG_COMP_DEF, 'directiveDefs');\n\n        _this12.storeFieldOfDefOnType(componentType, ɵNG_COMP_DEF, 'pipeDefs'); // `tView` that is stored on component def contains information about directives and pipes\n        // that are in the scope of this component. Patching component scope will cause `tView` to be\n        // changed. Store original `tView` before patching scope, so the `tView` (including scope\n        // information) is restored back to its previous/original state before running next test.\n\n\n        _this12.storeFieldOfDefOnType(componentType, ɵNG_COMP_DEF, 'tView');\n\n        ɵpatchComponentDefWithScope(componentType.ɵcmp, moduleScope);\n      });\n      this.componentToModuleScope.clear();\n    }\n  }, {\n    key: \"applyProviderOverrides\",\n    value: function applyProviderOverrides() {\n      var _this13 = this;\n\n      var maybeApplyOverrides = function maybeApplyOverrides(field) {\n        return function (type) {\n          var resolver = field === ɵNG_COMP_DEF ? _this13.resolvers.component : _this13.resolvers.directive;\n          var metadata = resolver.resolve(type);\n\n          if (_this13.hasProviderOverrides(metadata.providers)) {\n            _this13.patchDefWithProviderOverrides(type, field);\n          }\n        };\n      };\n\n      this.seenComponents.forEach(maybeApplyOverrides(ɵNG_COMP_DEF));\n      this.seenDirectives.forEach(maybeApplyOverrides(ɵNG_DIR_DEF));\n      this.seenComponents.clear();\n      this.seenDirectives.clear();\n    }\n  }, {\n    key: \"applyProviderOverridesToModule\",\n    value: function applyProviderOverridesToModule(moduleType) {\n      if (this.moduleProvidersOverridden.has(moduleType)) {\n        return;\n      }\n\n      this.moduleProvidersOverridden.add(moduleType);\n      var injectorDef = moduleType[ɵNG_INJ_DEF];\n\n      if (this.providerOverridesByToken.size > 0) {\n        var providers = [].concat(_toConsumableArray(injectorDef.providers), _toConsumableArray(this.providerOverridesByModule.get(moduleType) || []));\n\n        if (this.hasProviderOverrides(providers)) {\n          this.maybeStoreNgDef(ɵNG_INJ_DEF, moduleType);\n          this.storeFieldOfDefOnType(moduleType, ɵNG_INJ_DEF, 'providers');\n          injectorDef.providers = this.getOverriddenProviders(providers);\n        } // Apply provider overrides to imported modules recursively\n\n\n        var moduleDef = moduleType[ɵNG_MOD_DEF];\n        var imports = maybeUnwrapFn(moduleDef.imports);\n\n        var _iterator = _createForOfIteratorHelper(imports),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var importedModule = _step.value;\n            this.applyProviderOverridesToModule(importedModule);\n          } // Also override the providers on any ModuleWithProviders imports since those don't appear in\n          // the moduleDef.\n\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n\n        var _iterator2 = _createForOfIteratorHelper(flatten(injectorDef.imports)),\n            _step2;\n\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var _importedModule = _step2.value;\n\n            if (isModuleWithProviders(_importedModule)) {\n              this.defCleanupOps.push({\n                object: _importedModule,\n                fieldName: 'providers',\n                originalValue: _importedModule.providers\n              });\n              _importedModule.providers = this.getOverriddenProviders(_importedModule.providers);\n            }\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n      }\n    }\n  }, {\n    key: \"patchComponentsWithExistingStyles\",\n    value: function patchComponentsWithExistingStyles() {\n      this.existingComponentStyles.forEach(function (styles, type) {\n        return type[ɵNG_COMP_DEF].styles = styles;\n      });\n      this.existingComponentStyles.clear();\n    }\n  }, {\n    key: \"queueTypeArray\",\n    value: function queueTypeArray(arr, moduleType) {\n      var _iterator3 = _createForOfIteratorHelper(arr),\n          _step3;\n\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var value = _step3.value;\n\n          if (Array.isArray(value)) {\n            this.queueTypeArray(value, moduleType);\n          } else {\n            this.queueType(value, moduleType);\n          }\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n    }\n  }, {\n    key: \"recompileNgModule\",\n    value: function recompileNgModule(ngModule, metadata) {\n      // Cache the initial ngModuleDef as it will be overwritten.\n      this.maybeStoreNgDef(ɵNG_MOD_DEF, ngModule);\n      this.maybeStoreNgDef(ɵNG_INJ_DEF, ngModule);\n      ɵcompileNgModuleDefs(ngModule, metadata);\n    }\n  }, {\n    key: \"queueType\",\n    value: function queueType(type, moduleType) {\n      var component = this.resolvers.component.resolve(type);\n\n      if (component) {\n        // Check whether a give Type has respective NG def (ɵcmp) and compile if def is\n        // missing. That might happen in case a class without any Angular decorators extends another\n        // class where Component/Directive/Pipe decorator is defined.\n        if (isComponentDefPendingResolution(type) || !type.hasOwnProperty(ɵNG_COMP_DEF)) {\n          this.pendingComponents.add(type);\n        }\n\n        this.seenComponents.add(type); // Keep track of the module which declares this component, so later the component's scope\n        // can be set correctly. If the component has already been recorded here, then one of several\n        // cases is true:\n        // * the module containing the component was imported multiple times (common).\n        // * the component is declared in multiple modules (which is an error).\n        // * the component was in 'declarations' of the testing module, and also in an imported module\n        //   in which case the module scope will be TestingModuleOverride.DECLARATION.\n        // * overrideTemplateUsingTestingModule was called for the component in which case the module\n        //   scope will be TestingModuleOverride.OVERRIDE_TEMPLATE.\n        //\n        // If the component was previously in the testing module's 'declarations' (meaning the\n        // current value is TestingModuleOverride.DECLARATION), then `moduleType` is the component's\n        // real module, which was imported. This pattern is understood to mean that the component\n        // should use its original scope, but that the testing module should also contain the\n        // component in its scope.\n\n        if (!this.componentToModuleScope.has(type) || this.componentToModuleScope.get(type) === TestingModuleOverride.DECLARATION) {\n          this.componentToModuleScope.set(type, moduleType);\n        }\n\n        return;\n      }\n\n      var directive = this.resolvers.directive.resolve(type);\n\n      if (directive) {\n        if (!type.hasOwnProperty(ɵNG_DIR_DEF)) {\n          this.pendingDirectives.add(type);\n        }\n\n        this.seenDirectives.add(type);\n        return;\n      }\n\n      var pipe = this.resolvers.pipe.resolve(type);\n\n      if (pipe && !type.hasOwnProperty(ɵNG_PIPE_DEF)) {\n        this.pendingPipes.add(type);\n        return;\n      }\n    }\n  }, {\n    key: \"queueTypesFromModulesArray\",\n    value: function queueTypesFromModulesArray(arr) {\n      var _this14 = this;\n\n      // Because we may encounter the same NgModule while processing the imports and exports of an\n      // NgModule tree, we cache them in this set so we can skip ones that have already been seen\n      // encountered. In some test setups, this caching resulted in 10X runtime improvement.\n      var processedNgModuleDefs = new Set();\n\n      var queueTypesFromModulesArrayRecur = function queueTypesFromModulesArrayRecur(arr) {\n        var _iterator4 = _createForOfIteratorHelper(arr),\n            _step4;\n\n        try {\n          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n            var value = _step4.value;\n\n            if (Array.isArray(value)) {\n              queueTypesFromModulesArrayRecur(value);\n            } else if (hasNgModuleDef(value)) {\n              var def = value.ɵmod;\n\n              if (processedNgModuleDefs.has(def)) {\n                continue;\n              }\n\n              processedNgModuleDefs.add(def); // Look through declarations, imports, and exports, and queue\n              // everything found there.\n\n              _this14.queueTypeArray(maybeUnwrapFn(def.declarations), value);\n\n              queueTypesFromModulesArrayRecur(maybeUnwrapFn(def.imports));\n              queueTypesFromModulesArrayRecur(maybeUnwrapFn(def.exports));\n            }\n          }\n        } catch (err) {\n          _iterator4.e(err);\n        } finally {\n          _iterator4.f();\n        }\n      };\n\n      queueTypesFromModulesArrayRecur(arr);\n    } // When module overrides (via `TestBed.overrideModule`) are present, it might affect all modules\n    // that import (even transitively) an overridden one. For all affected modules we need to\n    // recalculate their scopes for a given test run and restore original scopes at the end. The goal\n    // of this function is to collect all affected modules in a set for further processing. Example:\n    // if we have the following module hierarchy: A -> B -> C (where `->` means `imports`) and module\n    // `C` is overridden, we consider `A` and `B` as affected, since their scopes might become\n    // invalidated with the override.\n\n  }, {\n    key: \"collectModulesAffectedByOverrides\",\n    value: function collectModulesAffectedByOverrides(arr) {\n      var _this15 = this;\n\n      var seenModules = new Set();\n      var affectedModules = new Set();\n\n      var calcAffectedModulesRecur = function calcAffectedModulesRecur(arr, path) {\n        var _iterator5 = _createForOfIteratorHelper(arr),\n            _step5;\n\n        try {\n          for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n            var value = _step5.value;\n\n            if (Array.isArray(value)) {\n              // If the value is an array, just flatten it (by invoking this function recursively),\n              // keeping \"path\" the same.\n              calcAffectedModulesRecur(value, path);\n            } else if (hasNgModuleDef(value)) {\n              if (seenModules.has(value)) {\n                // If we've seen this module before and it's included into \"affected modules\" list, mark\n                // the whole path that leads to that module as affected, but do not descend into its\n                // imports, since we already examined them before.\n                if (affectedModules.has(value)) {\n                  path.forEach(function (item) {\n                    return affectedModules.add(item);\n                  });\n                }\n\n                continue;\n              }\n\n              seenModules.add(value);\n\n              if (_this15.overriddenModules.has(value)) {\n                path.forEach(function (item) {\n                  return affectedModules.add(item);\n                });\n              } // Examine module imports recursively to look for overridden modules.\n\n\n              var moduleDef = value[ɵNG_MOD_DEF];\n              calcAffectedModulesRecur(maybeUnwrapFn(moduleDef.imports), path.concat(value));\n            }\n          }\n        } catch (err) {\n          _iterator5.e(err);\n        } finally {\n          _iterator5.f();\n        }\n      };\n\n      calcAffectedModulesRecur(arr, []);\n      return affectedModules;\n    }\n  }, {\n    key: \"maybeStoreNgDef\",\n    value: function maybeStoreNgDef(prop, type) {\n      if (!this.initialNgDefs.has(type)) {\n        var currentDef = Object.getOwnPropertyDescriptor(type, prop);\n        this.initialNgDefs.set(type, [prop, currentDef]);\n      }\n    }\n  }, {\n    key: \"storeFieldOfDefOnType\",\n    value: function storeFieldOfDefOnType(type, defField, fieldName) {\n      var def = type[defField];\n      var originalValue = def[fieldName];\n      this.defCleanupOps.push({\n        object: def,\n        fieldName: fieldName,\n        originalValue: originalValue\n      });\n    }\n    /**\n     * Clears current components resolution queue, but stores the state of the queue, so we can\n     * restore it later. Clearing the queue is required before we try to compile components (via\n     * `TestBed.compileComponents`), so that component defs are in sync with the resolution queue.\n     */\n\n  }, {\n    key: \"clearComponentResolutionQueue\",\n    value: function clearComponentResolutionQueue() {\n      var _this16 = this;\n\n      if (this.originalComponentResolutionQueue === null) {\n        this.originalComponentResolutionQueue = new Map();\n      }\n\n      clearResolutionOfComponentResourcesQueue().forEach(function (value, key) {\n        return _this16.originalComponentResolutionQueue.set(key, value);\n      });\n    }\n    /*\n     * Restores component resolution queue to the previously saved state. This operation is performed\n     * as a part of restoring the state after completion of the current set of tests (that might\n     * potentially mutate the state).\n     */\n\n  }, {\n    key: \"restoreComponentResolutionQueue\",\n    value: function restoreComponentResolutionQueue() {\n      if (this.originalComponentResolutionQueue !== null) {\n        _restoreComponentResolutionQueue(this.originalComponentResolutionQueue);\n\n        this.originalComponentResolutionQueue = null;\n      }\n    }\n  }, {\n    key: \"restoreOriginalState\",\n    value: function restoreOriginalState() {\n      // Process cleanup ops in reverse order so the field's original value is restored correctly (in\n      // case there were multiple overrides for the same field).\n      forEachRight(this.defCleanupOps, function (op) {\n        op.object[op.fieldName] = op.originalValue;\n      }); // Restore initial component/directive/pipe defs\n\n      this.initialNgDefs.forEach(function (value, type) {\n        var _value = _slicedToArray(value, 2),\n            prop = _value[0],\n            descriptor = _value[1];\n\n        if (!descriptor) {\n          // Delete operations are generally undesirable since they have performance implications\n          // on objects they were applied to. In this particular case, situations where this code\n          // is invoked should be quite rare to cause any noticeable impact, since it's applied\n          // only to some test cases (for example when class with no annotations extends some\n          // @Component) when we need to clear 'ɵcmp' field on a given class to restore\n          // its original state (before applying overrides and running tests).\n          delete type[prop];\n        } else {\n          Object.defineProperty(type, prop, descriptor);\n        }\n      });\n      this.initialNgDefs.clear();\n      this.moduleProvidersOverridden.clear();\n      this.restoreComponentResolutionQueue(); // Restore the locale ID to the default value, this shouldn't be necessary but we never know\n\n      ɵsetLocaleId(ɵDEFAULT_LOCALE_ID);\n    }\n  }, {\n    key: \"compileTestModule\",\n    value: function compileTestModule() {\n      var _this17 = this;\n\n      var RootScopeModule = /*#__PURE__*/_createClass(function RootScopeModule() {\n        _classCallCheck(this, RootScopeModule);\n      });\n\n      ɵcompileNgModuleDefs(RootScopeModule, {\n        providers: _toConsumableArray(this.rootProviderOverrides)\n      });\n      var ngZone = new NgZone({\n        enableLongStackTrace: true\n      });\n      var providers = [{\n        provide: NgZone,\n        useValue: ngZone\n      }, {\n        provide: Compiler,\n        useFactory: function useFactory() {\n          return new R3TestCompiler(_this17);\n        }\n      }].concat(_toConsumableArray(this.providers), _toConsumableArray(this.providerOverrides));\n      var imports = [RootScopeModule, this.additionalModuleTypes, this.imports || []]; // clang-format off\n\n      ɵcompileNgModuleDefs(this.testModuleType, {\n        declarations: this.declarations,\n        imports: imports,\n        schemas: this.schemas,\n        providers: providers\n      },\n      /* allowDuplicateDeclarationsInRoot */\n      true); // clang-format on\n\n      this.applyProviderOverridesToModule(this.testModuleType);\n    }\n  }, {\n    key: \"injector\",\n    get: function get() {\n      if (this._injector !== null) {\n        return this._injector;\n      }\n\n      var providers = [];\n      var compilerOptions = this.platform.injector.get(COMPILER_OPTIONS);\n      compilerOptions.forEach(function (opts) {\n        if (opts.providers) {\n          providers.push(opts.providers);\n        }\n      });\n\n      if (this.compilerProviders !== null) {\n        providers.push.apply(providers, _toConsumableArray(this.compilerProviders));\n      } // TODO(ocombe): make this work with an Injector directly instead of creating a module for it\n\n\n      var CompilerModule = /*#__PURE__*/_createClass(function CompilerModule() {\n        _classCallCheck(this, CompilerModule);\n      });\n\n      ɵcompileNgModuleDefs(CompilerModule, {\n        providers: providers\n      });\n      var CompilerModuleFactory = new ɵNgModuleFactory(CompilerModule);\n      this._injector = CompilerModuleFactory.create(this.platform.injector).injector;\n      return this._injector;\n    } // get overrides for a specific provider (if any)\n\n  }, {\n    key: \"getSingleProviderOverrides\",\n    value: function getSingleProviderOverrides(provider) {\n      var token = getProviderToken(provider);\n      return this.providerOverridesByToken.get(token) || null;\n    }\n  }, {\n    key: \"getProviderOverrides\",\n    value: function getProviderOverrides(providers) {\n      var _this18 = this;\n\n      if (!providers || !providers.length || this.providerOverridesByToken.size === 0) return []; // There are two flattening operations here. The inner flatten() operates on the metadata's\n      // providers and applies a mapping function which retrieves overrides for each incoming\n      // provider. The outer flatten() then flattens the produced overrides array. If this is not\n      // done, the array can contain other empty arrays (e.g. `[[], []]`) which leak into the\n      // providers array and contaminate any error messages that might be generated.\n\n      return flatten(flatten(providers, function (provider) {\n        return _this18.getSingleProviderOverrides(provider) || [];\n      }));\n    }\n  }, {\n    key: \"getOverriddenProviders\",\n    value: function getOverriddenProviders(providers) {\n      var _this19 = this;\n\n      if (!providers || !providers.length || this.providerOverridesByToken.size === 0) return [];\n      var flattenedProviders = flatten(providers);\n      var overrides = this.getProviderOverrides(flattenedProviders);\n      var overriddenProviders = [].concat(_toConsumableArray(flattenedProviders), _toConsumableArray(overrides));\n      var final = [];\n      var seenOverriddenProviders = new Set(); // We iterate through the list of providers in reverse order to make sure provider overrides\n      // take precedence over the values defined in provider list. We also filter out all providers\n      // that have overrides, keeping overridden values only. This is needed, since presence of a\n      // provider with `ngOnDestroy` hook will cause this hook to be registered and invoked later.\n\n      forEachRight(overriddenProviders, function (provider) {\n        var token = getProviderToken(provider);\n\n        if (_this19.providerOverridesByToken.has(token)) {\n          if (!seenOverriddenProviders.has(token)) {\n            seenOverriddenProviders.add(token); // Treat all overridden providers as `{multi: false}` (even if it's a multi-provider) to\n            // make sure that provided override takes highest precedence and is not combined with\n            // other instances of the same multi provider.\n\n            final.unshift(Object.assign(Object.assign({}, provider), {\n              multi: false\n            }));\n          }\n        } else {\n          final.unshift(provider);\n        }\n      });\n      return final;\n    }\n  }, {\n    key: \"hasProviderOverrides\",\n    value: function hasProviderOverrides(providers) {\n      return this.getProviderOverrides(providers).length > 0;\n    }\n  }, {\n    key: \"patchDefWithProviderOverrides\",\n    value: function patchDefWithProviderOverrides(declaration, field) {\n      var _this20 = this;\n\n      var def = declaration[field];\n\n      if (def && def.providersResolver) {\n        this.maybeStoreNgDef(field, declaration);\n        var resolver = def.providersResolver;\n\n        var processProvidersFn = function processProvidersFn(providers) {\n          return _this20.getOverriddenProviders(providers);\n        };\n\n        this.storeFieldOfDefOnType(declaration, field, 'providersResolver');\n\n        def.providersResolver = function (ngDef) {\n          return resolver(ngDef, processProvidersFn);\n        };\n      }\n    }\n  }]);\n\n  return R3TestBedCompiler;\n}();\n\nfunction initResolvers() {\n  return {\n    module: new NgModuleResolver(),\n    component: new ComponentResolver(),\n    directive: new DirectiveResolver(),\n    pipe: new PipeResolver()\n  };\n}\n\nfunction hasNgModuleDef(value) {\n  return value.hasOwnProperty('ɵmod');\n}\n\nfunction maybeUnwrapFn(maybeFn) {\n  return maybeFn instanceof Function ? maybeFn() : maybeFn;\n}\n\nfunction flatten(values, mapFn) {\n  var out = [];\n  values.forEach(function (value) {\n    if (Array.isArray(value)) {\n      out.push.apply(out, _toConsumableArray(flatten(value, mapFn)));\n    } else {\n      out.push(mapFn ? mapFn(value) : value);\n    }\n  });\n  return out;\n}\n\nfunction getProviderField(provider, field) {\n  return provider && typeof provider === 'object' && provider[field];\n}\n\nfunction getProviderToken(provider) {\n  return getProviderField(provider, 'provide') || provider;\n}\n\nfunction isModuleWithProviders(value) {\n  return value.hasOwnProperty('ngModule');\n}\n\nfunction forEachRight(values, fn) {\n  for (var idx = values.length - 1; idx >= 0; idx--) {\n    fn(values[idx], idx);\n  }\n}\n\nfunction invalidTypeError(name, expectedType) {\n  return new Error(\"\".concat(name, \" class doesn't have @\").concat(expectedType, \" decorator or is missing metadata.\"));\n}\n\nvar R3TestCompiler = /*#__PURE__*/function () {\n  function R3TestCompiler(testBed) {\n    _classCallCheck(this, R3TestCompiler);\n\n    this.testBed = testBed;\n  }\n\n  _createClass(R3TestCompiler, [{\n    key: \"compileModuleSync\",\n    value: function compileModuleSync(moduleType) {\n      this.testBed._compileNgModuleSync(moduleType);\n\n      return new ɵNgModuleFactory(moduleType);\n    }\n  }, {\n    key: \"compileModuleAsync\",\n    value: function compileModuleAsync(moduleType) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.next = 2;\n                return this.testBed._compileNgModuleAsync(moduleType);\n\n              case 2:\n                return _context3.abrupt(\"return\", new ɵNgModuleFactory(moduleType));\n\n              case 3:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n    }\n  }, {\n    key: \"compileModuleAndAllComponentsSync\",\n    value: function compileModuleAndAllComponentsSync(moduleType) {\n      var ngModuleFactory = this.compileModuleSync(moduleType);\n\n      var componentFactories = this.testBed._getComponentFactories(moduleType);\n\n      return new ModuleWithComponentFactories(ngModuleFactory, componentFactories);\n    }\n  }, {\n    key: \"compileModuleAndAllComponentsAsync\",\n    value: function compileModuleAndAllComponentsAsync(moduleType) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {\n        var ngModuleFactory, componentFactories;\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                _context4.next = 2;\n                return this.compileModuleAsync(moduleType);\n\n              case 2:\n                ngModuleFactory = _context4.sent;\n                componentFactories = this.testBed._getComponentFactories(moduleType);\n                return _context4.abrupt(\"return\", new ModuleWithComponentFactories(ngModuleFactory, componentFactories));\n\n              case 5:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n    }\n  }, {\n    key: \"clearCache\",\n    value: function clearCache() {}\n  }, {\n    key: \"clearCacheFor\",\n    value: function clearCacheFor(type) {}\n  }, {\n    key: \"getModuleId\",\n    value: function getModuleId(moduleType) {\n      var meta = this.testBed._getModuleResolver().resolve(moduleType);\n\n      return meta && meta.id || undefined;\n    }\n  }]);\n\n  return R3TestCompiler;\n}();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * An abstract class for inserting the root test component element in a platform independent way.\n *\n * @publicApi\n */\n\n\nvar TestComponentRenderer = /*#__PURE__*/function () {\n  function TestComponentRenderer() {\n    _classCallCheck(this, TestComponentRenderer);\n  }\n\n  _createClass(TestComponentRenderer, [{\n    key: \"insertRootElement\",\n    value: function insertRootElement(rootElementId) {}\n  }]);\n\n  return TestComponentRenderer;\n}();\n/**\n * @publicApi\n */\n\n\nvar ComponentFixtureAutoDetect = new InjectionToken('ComponentFixtureAutoDetect');\n/**\n * @publicApi\n */\n\nvar ComponentFixtureNoNgZone = new InjectionToken('ComponentFixtureNoNgZone');\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nvar _nextRootElementId = 0;\n/**\n * @description\n * Configures and initializes environment for unit testing and provides methods for\n * creating components and services in unit tests.\n *\n * TestBed is the primary api for writing unit tests for Angular applications and libraries.\n *\n * Note: Use `TestBed` in tests. It will be set to either `TestBedViewEngine` or `TestBedRender3`\n * according to the compiler used.\n */\n\nvar TestBedRender3 = /*#__PURE__*/function () {\n  function TestBedRender3() {\n    _classCallCheck(this, TestBedRender3);\n\n    // Properties\n    this.platform = null;\n    this.ngModule = null;\n    this._compiler = null;\n    this._testModuleRef = null;\n    this._activeFixtures = [];\n    this._globalCompilationChecked = false;\n  }\n  /**\n   * Initialize the environment for testing with a compiler factory, a PlatformRef, and an\n   * angular module. These are common to every test in the suite.\n   *\n   * This may only be called once, to set up the common providers for the current test\n   * suite on the current platform. If you absolutely need to change the providers,\n   * first use `resetTestEnvironment`.\n   *\n   * Test modules and platforms for individual platforms are available from\n   * '@angular/<platform_name>/testing'.\n   *\n   * @publicApi\n   */\n\n\n  _createClass(TestBedRender3, [{\n    key: \"initTestEnvironment\",\n    value:\n    /**\n     * Initialize the environment for testing with a compiler factory, a PlatformRef, and an\n     * angular module. These are common to every test in the suite.\n     *\n     * This may only be called once, to set up the common providers for the current test\n     * suite on the current platform. If you absolutely need to change the providers,\n     * first use `resetTestEnvironment`.\n     *\n     * Test modules and platforms for individual platforms are available from\n     * '@angular/<platform_name>/testing'.\n     *\n     * @publicApi\n     */\n    function initTestEnvironment(ngModule, platform, aotSummaries) {\n      if (this.platform || this.ngModule) {\n        throw new Error('Cannot set base providers because it has already been called');\n      }\n\n      this.platform = platform;\n      this.ngModule = ngModule;\n      this._compiler = new R3TestBedCompiler(this.platform, this.ngModule);\n    }\n    /**\n     * Reset the providers for the test injector.\n     *\n     * @publicApi\n     */\n\n  }, {\n    key: \"resetTestEnvironment\",\n    value: function resetTestEnvironment() {\n      this.resetTestingModule();\n      this._compiler = null;\n      this.platform = null;\n      this.ngModule = null;\n    }\n  }, {\n    key: \"resetTestingModule\",\n    value: function resetTestingModule() {\n      this.checkGlobalCompilationFinished();\n      ɵresetCompiledComponents();\n\n      if (this._compiler !== null) {\n        this.compiler.restoreOriginalState();\n      }\n\n      this._compiler = new R3TestBedCompiler(this.platform, this.ngModule);\n      this._testModuleRef = null;\n      this.destroyActiveFixtures();\n    }\n  }, {\n    key: \"configureCompiler\",\n    value: function configureCompiler(config) {\n      if (config.useJit != null) {\n        throw new Error('the Render3 compiler JiT mode is not configurable !');\n      }\n\n      if (config.providers !== undefined) {\n        this.compiler.setCompilerProviders(config.providers);\n      }\n    }\n  }, {\n    key: \"configureTestingModule\",\n    value: function configureTestingModule(moduleDef) {\n      this.assertNotInstantiated('R3TestBed.configureTestingModule', 'configure the test module');\n      this.compiler.configureTestingModule(moduleDef);\n    }\n  }, {\n    key: \"compileComponents\",\n    value: function compileComponents() {\n      return this.compiler.compileComponents();\n    }\n  }, {\n    key: \"inject\",\n    value: function inject(token, notFoundValue, flags) {\n      if (token === TestBedRender3) {\n        return this;\n      }\n\n      var UNDEFINED = {};\n      var result = this.testModuleRef.injector.get(token, UNDEFINED, flags);\n      return result === UNDEFINED ? this.compiler.injector.get(token, notFoundValue, flags) : result;\n    }\n    /** @deprecated from v9.0.0 use TestBed.inject */\n\n  }, {\n    key: \"get\",\n    value: function get(token) {\n      var notFoundValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Injector.THROW_IF_NOT_FOUND;\n      var flags = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : InjectFlags.Default;\n      return this.inject(token, notFoundValue, flags);\n    }\n  }, {\n    key: \"execute\",\n    value: function execute(tokens, fn, context) {\n      var _this21 = this;\n\n      var params = tokens.map(function (t) {\n        return _this21.inject(t);\n      });\n      return fn.apply(context, params);\n    }\n  }, {\n    key: \"overrideModule\",\n    value: function overrideModule(ngModule, override) {\n      this.assertNotInstantiated('overrideModule', 'override module metadata');\n      this.compiler.overrideModule(ngModule, override);\n    }\n  }, {\n    key: \"overrideComponent\",\n    value: function overrideComponent(component, override) {\n      this.assertNotInstantiated('overrideComponent', 'override component metadata');\n      this.compiler.overrideComponent(component, override);\n    }\n  }, {\n    key: \"overrideTemplateUsingTestingModule\",\n    value: function overrideTemplateUsingTestingModule(component, template) {\n      this.assertNotInstantiated('R3TestBed.overrideTemplateUsingTestingModule', 'Cannot override template when the test module has already been instantiated');\n      this.compiler.overrideTemplateUsingTestingModule(component, template);\n    }\n  }, {\n    key: \"overrideDirective\",\n    value: function overrideDirective(directive, override) {\n      this.assertNotInstantiated('overrideDirective', 'override directive metadata');\n      this.compiler.overrideDirective(directive, override);\n    }\n  }, {\n    key: \"overridePipe\",\n    value: function overridePipe(pipe, override) {\n      this.assertNotInstantiated('overridePipe', 'override pipe metadata');\n      this.compiler.overridePipe(pipe, override);\n    }\n    /**\n     * Overwrites all providers for the given token with the given provider definition.\n     */\n\n  }, {\n    key: \"overrideProvider\",\n    value: function overrideProvider(token, provider) {\n      this.compiler.overrideProvider(token, provider);\n    }\n  }, {\n    key: \"createComponent\",\n    value: function createComponent(type) {\n      var _this22 = this;\n\n      var testComponentRenderer = this.inject(TestComponentRenderer);\n      var rootElId = \"root\".concat(_nextRootElementId++);\n      testComponentRenderer.insertRootElement(rootElId);\n      var componentDef = type.ɵcmp;\n\n      if (!componentDef) {\n        throw new Error(\"It looks like '\".concat(ɵstringify(type), \"' has not been IVY compiled - it has no '\\u0275cmp' field\"));\n      } // TODO: Don't cast as `InjectionToken<boolean>`, proper type is boolean[]\n\n\n      var noNgZone = this.inject(ComponentFixtureNoNgZone, false); // TODO: Don't cast as `InjectionToken<boolean>`, proper type is boolean[]\n\n      var autoDetect = this.inject(ComponentFixtureAutoDetect, false);\n      var ngZone = noNgZone ? null : this.inject(NgZone, null);\n      var componentFactory = new ɵRender3ComponentFactory(componentDef);\n\n      var initComponent = function initComponent() {\n        var componentRef = componentFactory.create(Injector.NULL, [], \"#\".concat(rootElId), _this22.testModuleRef);\n        return new ComponentFixture(componentRef, ngZone, autoDetect);\n      };\n\n      var fixture = ngZone ? ngZone.run(initComponent) : initComponent();\n\n      this._activeFixtures.push(fixture);\n\n      return fixture;\n    }\n    /**\n     * @internal strip this from published d.ts files due to\n     * https://github.com/microsoft/TypeScript/issues/36216\n     */\n\n  }, {\n    key: \"compiler\",\n    get: function get() {\n      if (this._compiler === null) {\n        throw new Error(\"Need to call TestBed.initTestEnvironment() first\");\n      }\n\n      return this._compiler;\n    }\n    /**\n     * @internal strip this from published d.ts files due to\n     * https://github.com/microsoft/TypeScript/issues/36216\n     */\n\n  }, {\n    key: \"testModuleRef\",\n    get: function get() {\n      if (this._testModuleRef === null) {\n        this._testModuleRef = this.compiler.finalize();\n      }\n\n      return this._testModuleRef;\n    }\n  }, {\n    key: \"assertNotInstantiated\",\n    value: function assertNotInstantiated(methodName, methodDescription) {\n      if (this._testModuleRef !== null) {\n        throw new Error(\"Cannot \".concat(methodDescription, \" when the test module has already been instantiated. \") + \"Make sure you are not using `inject` before `\".concat(methodName, \"`.\"));\n      }\n    }\n    /**\n     * Check whether the module scoping queue should be flushed, and flush it if needed.\n     *\n     * When the TestBed is reset, it clears the JIT module compilation queue, cancelling any\n     * in-progress module compilation. This creates a potential hazard - the very first time the\n     * TestBed is initialized (or if it's reset without being initialized), there may be pending\n     * compilations of modules declared in global scope. These compilations should be finished.\n     *\n     * To ensure that globally declared modules have their components scoped properly, this function\n     * is called whenever TestBed is initialized or reset. The _first_ time that this happens, prior\n     * to any other operations, the scoping queue is flushed.\n     */\n\n  }, {\n    key: \"checkGlobalCompilationFinished\",\n    value: function checkGlobalCompilationFinished() {\n      // Checking _testNgModuleRef is null should not be necessary, but is left in as an additional\n      // guard that compilations queued in tests (after instantiation) are never flushed accidentally.\n      if (!this._globalCompilationChecked && this._testModuleRef === null) {\n        ɵflushModuleScopingQueueAsMuchAsPossible();\n      }\n\n      this._globalCompilationChecked = true;\n    }\n  }, {\n    key: \"destroyActiveFixtures\",\n    value: function destroyActiveFixtures() {\n      this._activeFixtures.forEach(function (fixture) {\n        try {\n          fixture.destroy();\n        } catch (e) {\n          console.error('Error during cleanup of component', {\n            component: fixture.componentInstance,\n            stacktrace: e\n          });\n        }\n      });\n\n      this._activeFixtures = [];\n    }\n  }], [{\n    key: \"initTestEnvironment\",\n    value: function initTestEnvironment(ngModule, platform, aotSummaries) {\n      var testBed = _getTestBedRender3();\n\n      testBed.initTestEnvironment(ngModule, platform, aotSummaries);\n      return testBed;\n    }\n    /**\n     * Reset the providers for the test injector.\n     *\n     * @publicApi\n     */\n\n  }, {\n    key: \"resetTestEnvironment\",\n    value: function resetTestEnvironment() {\n      _getTestBedRender3().resetTestEnvironment();\n    }\n  }, {\n    key: \"configureCompiler\",\n    value: function configureCompiler(config) {\n      _getTestBedRender3().configureCompiler(config);\n\n      return TestBedRender3;\n    }\n    /**\n     * Allows overriding default providers, directives, pipes, modules of the test injector,\n     * which are defined in test_injector.js\n     */\n\n  }, {\n    key: \"configureTestingModule\",\n    value: function configureTestingModule(moduleDef) {\n      _getTestBedRender3().configureTestingModule(moduleDef);\n\n      return TestBedRender3;\n    }\n    /**\n     * Compile components with a `templateUrl` for the test's NgModule.\n     * It is necessary to call this function\n     * as fetching urls is asynchronous.\n     */\n\n  }, {\n    key: \"compileComponents\",\n    value: function compileComponents() {\n      return _getTestBedRender3().compileComponents();\n    }\n  }, {\n    key: \"overrideModule\",\n    value: function overrideModule(ngModule, override) {\n      _getTestBedRender3().overrideModule(ngModule, override);\n\n      return TestBedRender3;\n    }\n  }, {\n    key: \"overrideComponent\",\n    value: function overrideComponent(component, override) {\n      _getTestBedRender3().overrideComponent(component, override);\n\n      return TestBedRender3;\n    }\n  }, {\n    key: \"overrideDirective\",\n    value: function overrideDirective(directive, override) {\n      _getTestBedRender3().overrideDirective(directive, override);\n\n      return TestBedRender3;\n    }\n  }, {\n    key: \"overridePipe\",\n    value: function overridePipe(pipe, override) {\n      _getTestBedRender3().overridePipe(pipe, override);\n\n      return TestBedRender3;\n    }\n  }, {\n    key: \"overrideTemplate\",\n    value: function overrideTemplate(component, template) {\n      _getTestBedRender3().overrideComponent(component, {\n        set: {\n          template: template,\n          templateUrl: null\n        }\n      });\n\n      return TestBedRender3;\n    }\n    /**\n     * Overrides the template of the given component, compiling the template\n     * in the context of the TestingModule.\n     *\n     * Note: This works for JIT and AOTed components as well.\n     */\n\n  }, {\n    key: \"overrideTemplateUsingTestingModule\",\n    value: function overrideTemplateUsingTestingModule(component, template) {\n      _getTestBedRender3().overrideTemplateUsingTestingModule(component, template);\n\n      return TestBedRender3;\n    }\n  }, {\n    key: \"overrideProvider\",\n    value: function overrideProvider(token, provider) {\n      _getTestBedRender3().overrideProvider(token, provider);\n\n      return TestBedRender3;\n    }\n  }, {\n    key: \"inject\",\n    value: function inject(token, notFoundValue, flags) {\n      return _getTestBedRender3().inject(token, notFoundValue, flags);\n    }\n    /** @deprecated from v9.0.0 use TestBed.inject */\n\n  }, {\n    key: \"get\",\n    value: function get(token) {\n      var notFoundValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Injector.THROW_IF_NOT_FOUND;\n      var flags = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : InjectFlags.Default;\n      return _getTestBedRender3().inject(token, notFoundValue, flags);\n    }\n  }, {\n    key: \"createComponent\",\n    value: function createComponent(component) {\n      return _getTestBedRender3().createComponent(component);\n    }\n  }, {\n    key: \"resetTestingModule\",\n    value: function resetTestingModule() {\n      _getTestBedRender3().resetTestingModule();\n\n      return TestBedRender3;\n    }\n  }]);\n\n  return TestBedRender3;\n}();\n\nvar testBed;\n\nfunction _getTestBedRender3() {\n  return testBed = testBed || new TestBedRender3();\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nfunction unimplemented() {\n  throw Error('unimplemented');\n}\n/**\n * Special interface to the compiler only used by testing\n *\n * @publicApi\n */\n\n\nvar TestingCompiler = /*#__PURE__*/function (_Compiler) {\n  _inherits(TestingCompiler, _Compiler);\n\n  var _super5 = _createSuper(TestingCompiler);\n\n  function TestingCompiler() {\n    _classCallCheck(this, TestingCompiler);\n\n    return _super5.apply(this, arguments);\n  }\n\n  _createClass(TestingCompiler, [{\n    key: \"injector\",\n    get: function get() {\n      throw unimplemented();\n    }\n  }, {\n    key: \"overrideModule\",\n    value: function overrideModule(module, overrides) {\n      throw unimplemented();\n    }\n  }, {\n    key: \"overrideDirective\",\n    value: function overrideDirective(directive, overrides) {\n      throw unimplemented();\n    }\n  }, {\n    key: \"overrideComponent\",\n    value: function overrideComponent(component, overrides) {\n      throw unimplemented();\n    }\n  }, {\n    key: \"overridePipe\",\n    value: function overridePipe(directive, overrides) {\n      throw unimplemented();\n    }\n    /**\n     * Allows to pass the compile summary from AOT compilation to the JIT compiler,\n     * so that it can use the code generated by AOT.\n     */\n\n  }, {\n    key: \"loadAotSummaries\",\n    value: function loadAotSummaries(summaries) {\n      throw unimplemented();\n    }\n    /**\n     * Gets the component factory for the given component.\n     * This assumes that the component has been compiled before calling this call using\n     * `compileModuleAndAllComponents*`.\n     */\n\n  }, {\n    key: \"getComponentFactory\",\n    value: function getComponentFactory(component) {\n      throw unimplemented();\n    }\n    /**\n     * Returns the component type that is stored in the given error.\n     * This can be used for errors created by compileModule...\n     */\n\n  }, {\n    key: \"getComponentFromError\",\n    value: function getComponentFromError(error) {\n      throw unimplemented();\n    }\n  }]);\n\n  return TestingCompiler;\n}(Compiler);\n\nTestingCompiler.ɵfac = function TestingCompiler_Factory(t) {\n  return ɵTestingCompiler_BaseFactory(t || TestingCompiler);\n};\n\nTestingCompiler.ɵprov = ɵngcc0.ɵɵdefineInjectable({\n  token: TestingCompiler,\n  factory: TestingCompiler.ɵfac\n});\nvar ɵTestingCompiler_BaseFactory = /*@__PURE__*/ɵngcc0.ɵɵgetInheritedFactory(TestingCompiler);\n/*@__PURE__*/\n\n(function () {\n  ɵngcc0.ɵsetClassMetadata(TestingCompiler, [{\n    type: Injectable\n  }], null, null);\n})();\n/**\n * A factory for creating a Compiler\n *\n * @publicApi\n */\n\n\nvar TestingCompilerFactory = /*#__PURE__*/_createClass(function TestingCompilerFactory() {\n  _classCallCheck(this, TestingCompilerFactory);\n});\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nvar _nextRootElementId$1 = 0;\n/**\n * @description\n * Configures and initializes environment for unit testing and provides methods for\n * creating components and services in unit tests.\n *\n * `TestBed` is the primary api for writing unit tests for Angular applications and libraries.\n *\n * Note: Use `TestBed` in tests. It will be set to either `TestBedViewEngine` or `TestBedRender3`\n * according to the compiler used.\n */\n\nvar TestBedViewEngine = /*#__PURE__*/function () {\n  function TestBedViewEngine() {\n    _classCallCheck(this, TestBedViewEngine);\n\n    this._instantiated = false;\n    this._compiler = null;\n    this._moduleRef = null;\n    this._moduleFactory = null;\n    this._compilerOptions = [];\n    this._moduleOverrides = [];\n    this._componentOverrides = [];\n    this._directiveOverrides = [];\n    this._pipeOverrides = [];\n    this._providers = [];\n    this._declarations = [];\n    this._imports = [];\n    this._schemas = [];\n    this._activeFixtures = [];\n\n    this._testEnvAotSummaries = function () {\n      return [];\n    };\n\n    this._aotSummaries = [];\n    this._templateOverrides = [];\n    this._isRoot = true;\n    this._rootProviderOverrides = [];\n    this.platform = null;\n    this.ngModule = null;\n  }\n  /**\n   * Initialize the environment for testing with a compiler factory, a PlatformRef, and an\n   * angular module. These are common to every test in the suite.\n   *\n   * This may only be called once, to set up the common providers for the current test\n   * suite on the current platform. If you absolutely need to change the providers,\n   * first use `resetTestEnvironment`.\n   *\n   * Test modules and platforms for individual platforms are available from\n   * '@angular/<platform_name>/testing'.\n   */\n\n\n  _createClass(TestBedViewEngine, [{\n    key: \"initTestEnvironment\",\n    value:\n    /**\n     * Initialize the environment for testing with a compiler factory, a PlatformRef, and an\n     * angular module. These are common to every test in the suite.\n     *\n     * This may only be called once, to set up the common providers for the current test\n     * suite on the current platform. If you absolutely need to change the providers,\n     * first use `resetTestEnvironment`.\n     *\n     * Test modules and platforms for individual platforms are available from\n     * '@angular/<platform_name>/testing'.\n     */\n    function initTestEnvironment(ngModule, platform, aotSummaries) {\n      if (this.platform || this.ngModule) {\n        throw new Error('Cannot set base providers because it has already been called');\n      }\n\n      this.platform = platform;\n      this.ngModule = ngModule;\n\n      if (aotSummaries) {\n        this._testEnvAotSummaries = aotSummaries;\n      }\n    }\n    /**\n     * Reset the providers for the test injector.\n     */\n\n  }, {\n    key: \"resetTestEnvironment\",\n    value: function resetTestEnvironment() {\n      this.resetTestingModule();\n      this.platform = null;\n      this.ngModule = null;\n\n      this._testEnvAotSummaries = function () {\n        return [];\n      };\n    }\n  }, {\n    key: \"resetTestingModule\",\n    value: function resetTestingModule() {\n      ɵclearOverrides();\n      this._aotSummaries = [];\n      this._templateOverrides = [];\n      this._compiler = null;\n      this._moduleOverrides = [];\n      this._componentOverrides = [];\n      this._directiveOverrides = [];\n      this._pipeOverrides = [];\n      this._isRoot = true;\n      this._rootProviderOverrides = [];\n      this._moduleRef = null;\n      this._moduleFactory = null;\n      this._compilerOptions = [];\n      this._providers = [];\n      this._declarations = [];\n      this._imports = [];\n      this._schemas = [];\n      this._instantiated = false;\n\n      this._activeFixtures.forEach(function (fixture) {\n        try {\n          fixture.destroy();\n        } catch (e) {\n          console.error('Error during cleanup of component', {\n            component: fixture.componentInstance,\n            stacktrace: e\n          });\n        }\n      });\n\n      this._activeFixtures = [];\n    }\n  }, {\n    key: \"configureCompiler\",\n    value: function configureCompiler(config) {\n      this._assertNotInstantiated('TestBed.configureCompiler', 'configure the compiler');\n\n      this._compilerOptions.push(config);\n    }\n  }, {\n    key: \"configureTestingModule\",\n    value: function configureTestingModule(moduleDef) {\n      this._assertNotInstantiated('TestBed.configureTestingModule', 'configure the test module');\n\n      if (moduleDef.providers) {\n        var _this$_providers;\n\n        (_this$_providers = this._providers).push.apply(_this$_providers, _toConsumableArray(moduleDef.providers));\n      }\n\n      if (moduleDef.declarations) {\n        var _this$_declarations;\n\n        (_this$_declarations = this._declarations).push.apply(_this$_declarations, _toConsumableArray(moduleDef.declarations));\n      }\n\n      if (moduleDef.imports) {\n        var _this$_imports;\n\n        (_this$_imports = this._imports).push.apply(_this$_imports, _toConsumableArray(moduleDef.imports));\n      }\n\n      if (moduleDef.schemas) {\n        var _this$_schemas;\n\n        (_this$_schemas = this._schemas).push.apply(_this$_schemas, _toConsumableArray(moduleDef.schemas));\n      }\n\n      if (moduleDef.aotSummaries) {\n        this._aotSummaries.push(moduleDef.aotSummaries);\n      }\n    }\n  }, {\n    key: \"compileComponents\",\n    value: function compileComponents() {\n      var _this23 = this;\n\n      if (this._moduleFactory || this._instantiated) {\n        return Promise.resolve(null);\n      }\n\n      var moduleType = this._createCompilerAndModule();\n\n      return this._compiler.compileModuleAndAllComponentsAsync(moduleType).then(function (moduleAndComponentFactories) {\n        _this23._moduleFactory = moduleAndComponentFactories.ngModuleFactory;\n      });\n    }\n  }, {\n    key: \"_initIfNeeded\",\n    value: function _initIfNeeded() {\n      if (this._instantiated) {\n        return;\n      }\n\n      if (!this._moduleFactory) {\n        try {\n          var moduleType = this._createCompilerAndModule();\n\n          this._moduleFactory = this._compiler.compileModuleAndAllComponentsSync(moduleType).ngModuleFactory;\n        } catch (e) {\n          var errorCompType = this._compiler.getComponentFromError(e);\n\n          if (errorCompType) {\n            throw new Error(\"This test module uses the component \".concat(ɵstringify(errorCompType), \" which is using a \\\"templateUrl\\\" or \\\"styleUrls\\\", but they were never compiled. \") + \"Please call \\\"TestBed.compileComponents\\\" before your test.\");\n          } else {\n            throw e;\n          }\n        }\n      }\n\n      var _iterator6 = _createForOfIteratorHelper(this._templateOverrides),\n          _step6;\n\n      try {\n        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n          var _step6$value = _step6.value,\n              component = _step6$value.component,\n              templateOf = _step6$value.templateOf;\n\n          var compFactory = this._compiler.getComponentFactory(templateOf);\n\n          ɵoverrideComponentView(component, compFactory);\n        }\n      } catch (err) {\n        _iterator6.e(err);\n      } finally {\n        _iterator6.f();\n      }\n\n      var ngZone = new NgZone({\n        enableLongStackTrace: true,\n        shouldCoalesceEventChangeDetection: false\n      });\n      var providers = [{\n        provide: NgZone,\n        useValue: ngZone\n      }];\n      var ngZoneInjector = Injector.create({\n        providers: providers,\n        parent: this.platform.injector,\n        name: this._moduleFactory.moduleType.name\n      });\n      this._moduleRef = this._moduleFactory.create(ngZoneInjector); // ApplicationInitStatus.runInitializers() is marked @internal to core. So casting to any\n      // before accessing it.\n\n      this._moduleRef.injector.get(ApplicationInitStatus).runInitializers();\n\n      this._instantiated = true;\n    }\n  }, {\n    key: \"_createCompilerAndModule\",\n    value: function _createCompilerAndModule() {\n      var _this24 = this;\n\n      var providers = this._providers.concat([{\n        provide: TestBed,\n        useValue: this\n      }]);\n\n      var declarations = [].concat(_toConsumableArray(this._declarations), _toConsumableArray(this._templateOverrides.map(function (entry) {\n        return entry.templateOf;\n      })));\n      var rootScopeImports = [];\n      var rootProviderOverrides = this._rootProviderOverrides;\n\n      if (this._isRoot) {\n        var RootScopeModule = /*#__PURE__*/_createClass(function RootScopeModule() {\n          _classCallCheck(this, RootScopeModule);\n        });\n\n        RootScopeModule.decorators = [{\n          type: NgModule,\n          args: [{\n            providers: _toConsumableArray(rootProviderOverrides),\n            jit: true\n          }]\n        }];\n        rootScopeImports.push(RootScopeModule);\n      }\n\n      providers.push({\n        provide: ɵINJECTOR_SCOPE,\n        useValue: this._isRoot ? 'root' : null\n      });\n      var imports = [rootScopeImports, this.ngModule, this._imports];\n      var schemas = this._schemas;\n\n      var DynamicTestModule = /*#__PURE__*/_createClass(function DynamicTestModule() {\n        _classCallCheck(this, DynamicTestModule);\n      });\n\n      DynamicTestModule.decorators = [{\n        type: NgModule,\n        args: [{\n          providers: providers,\n          declarations: declarations,\n          imports: imports,\n          schemas: schemas,\n          jit: true\n        }]\n      }];\n      var compilerFactory = this.platform.injector.get(TestingCompilerFactory);\n      this._compiler = compilerFactory.createTestingCompiler(this._compilerOptions);\n\n      for (var _i = 0, _arr = [this._testEnvAotSummaries].concat(_toConsumableArray(this._aotSummaries)); _i < _arr.length; _i++) {\n        var summary = _arr[_i];\n\n        this._compiler.loadAotSummaries(summary);\n      }\n\n      this._moduleOverrides.forEach(function (entry) {\n        return _this24._compiler.overrideModule(entry[0], entry[1]);\n      });\n\n      this._componentOverrides.forEach(function (entry) {\n        return _this24._compiler.overrideComponent(entry[0], entry[1]);\n      });\n\n      this._directiveOverrides.forEach(function (entry) {\n        return _this24._compiler.overrideDirective(entry[0], entry[1]);\n      });\n\n      this._pipeOverrides.forEach(function (entry) {\n        return _this24._compiler.overridePipe(entry[0], entry[1]);\n      });\n\n      return DynamicTestModule;\n    }\n  }, {\n    key: \"_assertNotInstantiated\",\n    value: function _assertNotInstantiated(methodName, methodDescription) {\n      if (this._instantiated) {\n        throw new Error(\"Cannot \".concat(methodDescription, \" when the test module has already been instantiated. \") + \"Make sure you are not using `inject` before `\".concat(methodName, \"`.\"));\n      }\n    }\n  }, {\n    key: \"inject\",\n    value: function inject(token, notFoundValue, flags) {\n      this._initIfNeeded();\n\n      if (token === TestBed) {\n        return this;\n      } // Tests can inject things from the ng module and from the compiler,\n      // but the ng module can't inject things from the compiler and vice versa.\n\n\n      var UNDEFINED = {};\n\n      var result = this._moduleRef.injector.get(token, UNDEFINED, flags);\n\n      return result === UNDEFINED ? this._compiler.injector.get(token, notFoundValue, flags) : result;\n    }\n    /** @deprecated from v9.0.0 use TestBed.inject */\n\n  }, {\n    key: \"get\",\n    value: function get(token) {\n      var notFoundValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Injector.THROW_IF_NOT_FOUND;\n      var flags = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : InjectFlags.Default;\n      return this.inject(token, notFoundValue, flags);\n    }\n  }, {\n    key: \"execute\",\n    value: function execute(tokens, fn, context) {\n      var _this25 = this;\n\n      this._initIfNeeded();\n\n      var params = tokens.map(function (t) {\n        return _this25.inject(t);\n      });\n      return fn.apply(context, params);\n    }\n  }, {\n    key: \"overrideModule\",\n    value: function overrideModule(ngModule, override) {\n      this._assertNotInstantiated('overrideModule', 'override module metadata');\n\n      this._moduleOverrides.push([ngModule, override]);\n    }\n  }, {\n    key: \"overrideComponent\",\n    value: function overrideComponent(component, override) {\n      this._assertNotInstantiated('overrideComponent', 'override component metadata');\n\n      this._componentOverrides.push([component, override]);\n    }\n  }, {\n    key: \"overrideDirective\",\n    value: function overrideDirective(directive, override) {\n      this._assertNotInstantiated('overrideDirective', 'override directive metadata');\n\n      this._directiveOverrides.push([directive, override]);\n    }\n  }, {\n    key: \"overridePipe\",\n    value: function overridePipe(pipe, override) {\n      this._assertNotInstantiated('overridePipe', 'override pipe metadata');\n\n      this._pipeOverrides.push([pipe, override]);\n    }\n  }, {\n    key: \"overrideProvider\",\n    value: function overrideProvider(token, provider) {\n      this.overrideProviderImpl(token, provider);\n    }\n  }, {\n    key: \"overrideProviderImpl\",\n    value: function overrideProviderImpl(token, provider) {\n      var deprecated = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      var def = null;\n\n      if (typeof token !== 'string' && (def = ɵgetInjectableDef(token)) && def.providedIn === 'root') {\n        if (provider.useFactory) {\n          this._rootProviderOverrides.push({\n            provide: token,\n            useFactory: provider.useFactory,\n            deps: provider.deps || []\n          });\n        } else {\n          this._rootProviderOverrides.push({\n            provide: token,\n            useValue: provider.useValue\n          });\n        }\n      }\n\n      var flags = 0;\n      var value;\n\n      if (provider.useFactory) {\n        flags |= 1024\n        /* TypeFactoryProvider */\n        ;\n        value = provider.useFactory;\n      } else {\n        flags |= 256\n        /* TypeValueProvider */\n        ;\n        value = provider.useValue;\n      }\n\n      var deps = (provider.deps || []).map(function (dep) {\n        var depFlags = 0\n        /* None */\n        ;\n        var depToken;\n\n        if (Array.isArray(dep)) {\n          dep.forEach(function (entry) {\n            if (entry instanceof Optional) {\n              depFlags |= 2\n              /* Optional */\n              ;\n            } else if (entry instanceof SkipSelf) {\n              depFlags |= 1\n              /* SkipSelf */\n              ;\n            } else {\n              depToken = entry;\n            }\n          });\n        } else {\n          depToken = dep;\n        }\n\n        return [depFlags, depToken];\n      });\n      ɵoverrideProvider({\n        token: token,\n        flags: flags,\n        deps: deps,\n        value: value,\n        deprecatedBehavior: deprecated\n      });\n    }\n  }, {\n    key: \"overrideTemplateUsingTestingModule\",\n    value: function overrideTemplateUsingTestingModule(component, template) {\n      this._assertNotInstantiated('overrideTemplateUsingTestingModule', 'override template');\n\n      var OverrideComponent = /*#__PURE__*/_createClass(function OverrideComponent() {\n        _classCallCheck(this, OverrideComponent);\n      });\n\n      OverrideComponent.decorators = [{\n        type: Component,\n        args: [{\n          selector: 'empty',\n          template: template,\n          jit: true\n        }]\n      }];\n\n      this._templateOverrides.push({\n        component: component,\n        templateOf: OverrideComponent\n      });\n    }\n  }, {\n    key: \"createComponent\",\n    value: function createComponent(component) {\n      var _this26 = this;\n\n      this._initIfNeeded();\n\n      var componentFactory = this._compiler.getComponentFactory(component);\n\n      if (!componentFactory) {\n        throw new Error(\"Cannot create the component \".concat(ɵstringify(component), \" as it was not imported into the testing module!\"));\n      } // TODO: Don't cast as `InjectionToken<boolean>`, declared type is boolean[]\n\n\n      var noNgZone = this.inject(ComponentFixtureNoNgZone, false); // TODO: Don't cast as `InjectionToken<boolean>`, declared type is boolean[]\n\n      var autoDetect = this.inject(ComponentFixtureAutoDetect, false);\n      var ngZone = noNgZone ? null : this.inject(NgZone, null);\n      var testComponentRenderer = this.inject(TestComponentRenderer);\n      var rootElId = \"root\".concat(_nextRootElementId$1++);\n      testComponentRenderer.insertRootElement(rootElId);\n\n      var initComponent = function initComponent() {\n        var componentRef = componentFactory.create(Injector.NULL, [], \"#\".concat(rootElId), _this26._moduleRef);\n        return new ComponentFixture(componentRef, ngZone, autoDetect);\n      };\n\n      var fixture = !ngZone ? initComponent() : ngZone.run(initComponent);\n\n      this._activeFixtures.push(fixture);\n\n      return fixture;\n    }\n  }], [{\n    key: \"initTestEnvironment\",\n    value: function initTestEnvironment(ngModule, platform, aotSummaries) {\n      var testBed = _getTestBedViewEngine();\n\n      testBed.initTestEnvironment(ngModule, platform, aotSummaries);\n      return testBed;\n    }\n    /**\n     * Reset the providers for the test injector.\n     */\n\n  }, {\n    key: \"resetTestEnvironment\",\n    value: function resetTestEnvironment() {\n      _getTestBedViewEngine().resetTestEnvironment();\n    }\n  }, {\n    key: \"resetTestingModule\",\n    value: function resetTestingModule() {\n      _getTestBedViewEngine().resetTestingModule();\n\n      return TestBedViewEngine;\n    }\n    /**\n     * Allows overriding default compiler providers and settings\n     * which are defined in test_injector.js\n     */\n\n  }, {\n    key: \"configureCompiler\",\n    value: function configureCompiler(config) {\n      _getTestBedViewEngine().configureCompiler(config);\n\n      return TestBedViewEngine;\n    }\n    /**\n     * Allows overriding default providers, directives, pipes, modules of the test injector,\n     * which are defined in test_injector.js\n     */\n\n  }, {\n    key: \"configureTestingModule\",\n    value: function configureTestingModule(moduleDef) {\n      _getTestBedViewEngine().configureTestingModule(moduleDef);\n\n      return TestBedViewEngine;\n    }\n    /**\n     * Compile components with a `templateUrl` for the test's NgModule.\n     * It is necessary to call this function\n     * as fetching urls is asynchronous.\n     */\n\n  }, {\n    key: \"compileComponents\",\n    value: function compileComponents() {\n      return getTestBed().compileComponents();\n    }\n  }, {\n    key: \"overrideModule\",\n    value: function overrideModule(ngModule, override) {\n      _getTestBedViewEngine().overrideModule(ngModule, override);\n\n      return TestBedViewEngine;\n    }\n  }, {\n    key: \"overrideComponent\",\n    value: function overrideComponent(component, override) {\n      _getTestBedViewEngine().overrideComponent(component, override);\n\n      return TestBedViewEngine;\n    }\n  }, {\n    key: \"overrideDirective\",\n    value: function overrideDirective(directive, override) {\n      _getTestBedViewEngine().overrideDirective(directive, override);\n\n      return TestBedViewEngine;\n    }\n  }, {\n    key: \"overridePipe\",\n    value: function overridePipe(pipe, override) {\n      _getTestBedViewEngine().overridePipe(pipe, override);\n\n      return TestBedViewEngine;\n    }\n  }, {\n    key: \"overrideTemplate\",\n    value: function overrideTemplate(component, template) {\n      _getTestBedViewEngine().overrideComponent(component, {\n        set: {\n          template: template,\n          templateUrl: null\n        }\n      });\n\n      return TestBedViewEngine;\n    }\n    /**\n     * Overrides the template of the given component, compiling the template\n     * in the context of the TestingModule.\n     *\n     * Note: This works for JIT and AOTed components as well.\n     */\n\n  }, {\n    key: \"overrideTemplateUsingTestingModule\",\n    value: function overrideTemplateUsingTestingModule(component, template) {\n      _getTestBedViewEngine().overrideTemplateUsingTestingModule(component, template);\n\n      return TestBedViewEngine;\n    }\n  }, {\n    key: \"overrideProvider\",\n    value: function overrideProvider(token, provider) {\n      _getTestBedViewEngine().overrideProvider(token, provider);\n\n      return TestBedViewEngine;\n    }\n  }, {\n    key: \"inject\",\n    value: function inject(token, notFoundValue, flags) {\n      return _getTestBedViewEngine().inject(token, notFoundValue, flags);\n    }\n    /** @deprecated from v9.0.0 use TestBed.inject */\n\n  }, {\n    key: \"get\",\n    value: function get(token) {\n      var notFoundValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Injector.THROW_IF_NOT_FOUND;\n      var flags = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : InjectFlags.Default;\n      return _getTestBedViewEngine().inject(token, notFoundValue, flags);\n    }\n  }, {\n    key: \"createComponent\",\n    value: function createComponent(component) {\n      return _getTestBedViewEngine().createComponent(component);\n    }\n  }]);\n\n  return TestBedViewEngine;\n}();\n/**\n * @description\n * Configures and initializes environment for unit testing and provides methods for\n * creating components and services in unit tests.\n *\n * `TestBed` is the primary api for writing unit tests for Angular applications and libraries.\n *\n * Note: Use `TestBed` in tests. It will be set to either `TestBedViewEngine` or `TestBedRender3`\n * according to the compiler used.\n *\n * @publicApi\n */\n\n\nvar TestBed = ɵivyEnabled ? TestBedRender3 : TestBedViewEngine;\n/**\n * Returns a singleton of the applicable `TestBed`.\n *\n * It will be either an instance of `TestBedViewEngine` or `TestBedRender3`.\n *\n * @publicApi\n */\n\nvar getTestBed = ɵivyEnabled ? _getTestBedRender3 : _getTestBedViewEngine;\nvar testBed$1;\n\nfunction _getTestBedViewEngine() {\n  return testBed$1 = testBed$1 || new TestBedViewEngine();\n}\n/**\n * Allows injecting dependencies in `beforeEach()` and `it()`.\n *\n * Example:\n *\n * ```\n * beforeEach(inject([Dependency, AClass], (dep, object) => {\n *   // some code that uses `dep` and `object`\n *   // ...\n * }));\n *\n * it('...', inject([AClass], (object) => {\n *   object.doSomething();\n *   expect(...);\n * })\n * ```\n *\n * Notes:\n * - inject is currently a function because of some Traceur limitation the syntax should\n * eventually\n *   becomes `it('...', @Inject (object: AClass, async: AsyncTestCompleter) => { ... });`\n *\n * @publicApi\n */\n\n\nfunction _inject(tokens, fn) {\n  var testBed = getTestBed();\n\n  if (tokens.indexOf(AsyncTestCompleter) >= 0) {\n    // Not using an arrow function to preserve context passed from call site\n    return function () {\n      var _this27 = this;\n\n      // Return an async test method that returns a Promise if AsyncTestCompleter is one of\n      // the injected tokens.\n      return testBed.compileComponents().then(function () {\n        var completer = testBed.inject(AsyncTestCompleter);\n        testBed.execute(tokens, fn, _this27);\n        return completer.promise;\n      });\n    };\n  } else {\n    // Not using an arrow function to preserve context passed from call site\n    return function () {\n      return testBed.execute(tokens, fn, this);\n    };\n  }\n}\n/**\n * @publicApi\n */\n\n\nvar InjectSetupWrapper = /*#__PURE__*/function () {\n  function InjectSetupWrapper(_moduleDef) {\n    _classCallCheck(this, InjectSetupWrapper);\n\n    this._moduleDef = _moduleDef;\n  }\n\n  _createClass(InjectSetupWrapper, [{\n    key: \"_addModule\",\n    value: function _addModule() {\n      var moduleDef = this._moduleDef();\n\n      if (moduleDef) {\n        getTestBed().configureTestingModule(moduleDef);\n      }\n    }\n  }, {\n    key: \"inject\",\n    value: function inject(tokens, fn) {\n      var self = this; // Not using an arrow function to preserve context passed from call site\n\n      return function () {\n        self._addModule();\n\n        return _inject(tokens, fn).call(this);\n      };\n    }\n  }]);\n\n  return InjectSetupWrapper;\n}();\n\nfunction withModule(moduleDef, fn) {\n  if (fn) {\n    // Not using an arrow function to preserve context passed from call site\n    return function () {\n      var testBed = getTestBed();\n\n      if (moduleDef) {\n        testBed.configureTestingModule(moduleDef);\n      }\n\n      return fn.apply(this);\n    };\n  }\n\n  return new InjectSetupWrapper(function () {\n    return moduleDef;\n  });\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nvar _global$1 = typeof window === 'undefined' ? global : window; // Reset the test providers and the fake async zone before each test.\n\n\nif (_global$1.beforeEach) {\n  _global$1.beforeEach(function () {\n    TestBed.resetTestingModule();\n    resetFakeAsyncZone();\n  });\n}\n/**\n * This API should be removed. But doing so seems to break `google3` and so it requires a bit of\n * investigation.\n *\n * A work around is to mark it as `@codeGenApi` for now and investigate later.\n *\n * @codeGenApi\n */\n// TODO(iminar): Remove this code in a safe way.\n\n\nvar __core_private_testing_placeholder__ = '';\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n// This file only reexports content of the `src` folder. Keep it that way.\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { ComponentFixture, ComponentFixtureAutoDetect, ComponentFixtureNoNgZone, InjectSetupWrapper, TestBed, TestComponentRenderer, __core_private_testing_placeholder__, async, discardPeriodicTasks, fakeAsync, flush, flushMicrotasks, getTestBed, _inject as inject, resetFakeAsyncZone, tick, waitForAsync, withModule, MetadataOverrider as ɵMetadataOverrider, TestingCompiler as ɵTestingCompiler, TestingCompilerFactory as ɵTestingCompilerFactory, TestBedViewEngine as ɵangular_packages_core_testing_testing_a, TestBedRender3 as ɵangular_packages_core_testing_testing_b, _getTestBedRender3 as ɵangular_packages_core_testing_testing_c };","map":{"version":3,"sources":["../../../../../../packages/core/testing/src/async_fallback.ts","../../../../../../packages/core/testing/src/async.ts","../../../../../../packages/core/testing/src/component_fixture.ts","../../../../../../packages/core/testing/src/fake_async_fallback.ts","../../../../../../packages/core/testing/src/fake_async.ts","../../../../../../packages/core/testing/src/async_test_completer.ts","../../../../../../packages/core/src/metadata/resource_loading.ts","../../../../../../packages/core/testing/src/metadata_overrider.ts","../../../../../../packages/core/testing/src/resolvers.ts","../../../../../../packages/core/testing/src/r3_test_bed_compiler.ts","../../../../../../packages/core/testing/src/test_bed_common.ts","../../../../../../packages/core/testing/src/r3_test_bed.ts","../../../../../../packages/core/testing/src/test_compiler.ts","../../../../../../packages/core/testing/src/test_bed.ts","../../../../../../packages/core/testing/src/before_each.ts","../../../../../../packages/core/testing/src/metadata_override.ts","../../../../../../packages/core/testing/src/private_export_testing.ts","../../../../../../packages/core/testing/src/testing.ts","../../../../../../packages/core/testing/public_api.ts","../../../../../../packages/core/testing/index.ts","../../../../../../packages/core/testing/testing.ts"],"names":["_Zone","stringify","ReflectionCapabilities","getInjectableDef","NG_COMP_DEF","NgModuleRef","DEFAULT_LOCALE_ID","setLocaleId","ComponentFactory","compileComponent","NG_DIR_DEF","compileDirective","NG_PIPE_DEF","compilePipe","NG_MOD_DEF","transitiveScopesFor","patchComponentDefWithScope","NG_INJ_DEF","compileNgModuleDefs","R3NgModuleFactory","resetCompiledComponents","flushModuleScopingQueueAsMuchAsPossible","_nextRootElementId","clearOverrides","overrideComponentView","INJECTOR_SCOPE","overrideProvider","ivyEnabled","testBed","_global"],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * async has been moved to zone.js\n * this file is for fallback in case old version of zone.js is used\n */\ndeclare var global: any;\n\nconst _global = <any>(typeof window === 'undefined' ? global : window);\n\n/**\n * Wraps a test function in an asynchronous test zone. The test will automatically\n * complete when all asynchronous calls within this zone are done. Can be used\n * to wrap an {@link inject} call.\n *\n * Example:\n *\n * ```\n * it('...', async(inject([AClass], (object) => {\n *   object.doSomething.then(() => {\n *     expect(...);\n *   })\n * });\n * ```\n *\n *\n */\nexport function asyncFallback(fn: Function): (done: any) => any {\n  // If we're running using the Jasmine test framework, adapt to call the 'done'\n  // function when asynchronous activity is finished.\n  if (_global.jasmine) {\n    // Not using an arrow function to preserve context passed from call site\n    return function(this: unknown, done: any) {\n      if (!done) {\n        // if we run beforeEach in @angular/core/testing/testing_internal then we get no done\n        // fake it here and assume sync.\n        done = function() {};\n        done.fail = function(e: any) {\n          throw e;\n        };\n      }\n      runInTestZone(fn, this, done, (err: any) => {\n        if (typeof err === 'string') {\n          return done.fail(new Error(err));\n        } else {\n          done.fail(err);\n        }\n      });\n    };\n  }\n  // Otherwise, return a promise which will resolve when asynchronous activity\n  // is finished. This will be correctly consumed by the Mocha framework with\n  // it('...', async(myFn)); or can be used in a custom framework.\n  // Not using an arrow function to preserve context passed from call site\n  return function(this: unknown) {\n    return new Promise<void>((finishCallback, failCallback) => {\n      runInTestZone(fn, this, finishCallback, failCallback);\n    });\n  };\n}\n\nfunction runInTestZone(\n    fn: Function, context: any, finishCallback: Function, failCallback: Function) {\n  const currentZone = Zone.current;\n  const AsyncTestZoneSpec = (Zone as any)['AsyncTestZoneSpec'];\n  if (AsyncTestZoneSpec === undefined) {\n    throw new Error(\n        'AsyncTestZoneSpec is needed for the async() test helper but could not be found. ' +\n        'Please make sure that your environment includes zone.js/dist/async-test.js');\n  }\n  const ProxyZoneSpec = (Zone as any)['ProxyZoneSpec'] as {\n    get(): {setDelegate(spec: ZoneSpec): void; getDelegate(): ZoneSpec;};\n    assertPresent: () => void;\n  };\n  if (ProxyZoneSpec === undefined) {\n    throw new Error(\n        'ProxyZoneSpec is needed for the async() test helper but could not be found. ' +\n        'Please make sure that your environment includes zone.js/dist/proxy.js');\n  }\n  const proxyZoneSpec = ProxyZoneSpec.get();\n  ProxyZoneSpec.assertPresent();\n  // We need to create the AsyncTestZoneSpec outside the ProxyZone.\n  // If we do it in ProxyZone then we will get to infinite recursion.\n  const proxyZone = Zone.current.getZoneWith('ProxyZoneSpec');\n  const previousDelegate = proxyZoneSpec.getDelegate();\n  proxyZone!.parent!.run(() => {\n    const testZoneSpec: ZoneSpec = new AsyncTestZoneSpec(\n        () => {\n          // Need to restore the original zone.\n          currentZone.run(() => {\n            if (proxyZoneSpec.getDelegate() == testZoneSpec) {\n              // Only reset the zone spec if it's sill this one. Otherwise, assume it's OK.\n              proxyZoneSpec.setDelegate(previousDelegate);\n            }\n            finishCallback();\n          });\n        },\n        (error: any) => {\n          // Need to restore the original zone.\n          currentZone.run(() => {\n            if (proxyZoneSpec.getDelegate() == testZoneSpec) {\n              // Only reset the zone spec if it's sill this one. Otherwise, assume it's OK.\n              proxyZoneSpec.setDelegate(previousDelegate);\n            }\n            failCallback(error);\n          });\n        },\n        'test');\n    proxyZoneSpec.setDelegate(testZoneSpec);\n  });\n  return Zone.current.runGuarded(fn, context);\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {asyncFallback} from './async_fallback';\n\n/**\n * Wraps a test function in an asynchronous test zone. The test will automatically\n * complete when all asynchronous calls within this zone are done. Can be used\n * to wrap an {@link inject} call.\n *\n * Example:\n *\n * ```\n * it('...', waitForAsync(inject([AClass], (object) => {\n *   object.doSomething.then(() => {\n *     expect(...);\n *   })\n * });\n * ```\n *\n * @publicApi\n */\nexport function waitForAsync(fn: Function): (done: any) => any {\n  const _Zone: any = typeof Zone !== 'undefined' ? Zone : null;\n  if (!_Zone) {\n    return function() {\n      return Promise.reject(\n          'Zone is needed for the waitForAsync() test helper but could not be found. ' +\n          'Please make sure that your environment includes zone.js/dist/zone.js');\n    };\n  }\n  const asyncTest = _Zone && _Zone[_Zone.__symbol__('asyncTest')];\n  if (typeof asyncTest === 'function') {\n    return asyncTest(fn);\n  }\n  // not using new version of zone.js\n  // TODO @JiaLiPassion, remove this after all library updated to\n  // newest version of zone.js(0.8.25)\n  return asyncFallback(fn);\n}\n\n/**\n * @deprecated use `waitForAsync()`, (expected removal in v12)\n * @see {@link waitForAsync}\n * @publicApi\n * */\nexport function async(fn: Function): (done: any) => any {\n  return waitForAsync(fn);\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ChangeDetectorRef, ComponentRef, DebugElement, ElementRef, getDebugNode, NgZone, RendererFactory2} from '@angular/core';\n\n\n/**\n * Fixture for debugging and testing a component.\n *\n * @publicApi\n */\nexport class ComponentFixture<T> {\n  /**\n   * The DebugElement associated with the root element of this component.\n   */\n  debugElement: DebugElement;\n\n  /**\n   * The instance of the root component class.\n   */\n  componentInstance: T;\n\n  /**\n   * The native element at the root of the component.\n   */\n  nativeElement: any;\n\n  /**\n   * The ElementRef for the element at the root of the component.\n   */\n  elementRef: ElementRef;\n\n  /**\n   * The ChangeDetectorRef for the component\n   */\n  changeDetectorRef: ChangeDetectorRef;\n\n  private _renderer: RendererFactory2|null|undefined;\n  private _isStable: boolean = true;\n  private _isDestroyed: boolean = false;\n  private _resolve: ((result: any) => void)|null = null;\n  private _promise: Promise<any>|null = null;\n  private _onUnstableSubscription: any /** TODO #9100 */ = null;\n  private _onStableSubscription: any /** TODO #9100 */ = null;\n  private _onMicrotaskEmptySubscription: any /** TODO #9100 */ = null;\n  private _onErrorSubscription: any /** TODO #9100 */ = null;\n\n  constructor(\n      public componentRef: ComponentRef<T>, public ngZone: NgZone|null,\n      private _autoDetect: boolean) {\n    this.changeDetectorRef = componentRef.changeDetectorRef;\n    this.elementRef = componentRef.location;\n    this.debugElement = <DebugElement>getDebugNode(this.elementRef.nativeElement);\n    this.componentInstance = componentRef.instance;\n    this.nativeElement = this.elementRef.nativeElement;\n    this.componentRef = componentRef;\n    this.ngZone = ngZone;\n\n    if (ngZone) {\n      // Create subscriptions outside the NgZone so that the callbacks run oustide\n      // of NgZone.\n      ngZone.runOutsideAngular(() => {\n        this._onUnstableSubscription = ngZone.onUnstable.subscribe({\n          next: () => {\n            this._isStable = false;\n          }\n        });\n        this._onMicrotaskEmptySubscription = ngZone.onMicrotaskEmpty.subscribe({\n          next: () => {\n            if (this._autoDetect) {\n              // Do a change detection run with checkNoChanges set to true to check\n              // there are no changes on the second run.\n              this.detectChanges(true);\n            }\n          }\n        });\n        this._onStableSubscription = ngZone.onStable.subscribe({\n          next: () => {\n            this._isStable = true;\n            // Check whether there is a pending whenStable() completer to resolve.\n            if (this._promise !== null) {\n              // If so check whether there are no pending macrotasks before resolving.\n              // Do this check in the next tick so that ngZone gets a chance to update the state of\n              // pending macrotasks.\n              scheduleMicroTask(() => {\n                if (!ngZone.hasPendingMacrotasks) {\n                  if (this._promise !== null) {\n                    this._resolve!(true);\n                    this._resolve = null;\n                    this._promise = null;\n                  }\n                }\n              });\n            }\n          }\n        });\n\n        this._onErrorSubscription = ngZone.onError.subscribe({\n          next: (error: any) => {\n            throw error;\n          }\n        });\n      });\n    }\n  }\n\n  private _tick(checkNoChanges: boolean) {\n    this.changeDetectorRef.detectChanges();\n    if (checkNoChanges) {\n      this.checkNoChanges();\n    }\n  }\n\n  /**\n   * Trigger a change detection cycle for the component.\n   */\n  detectChanges(checkNoChanges: boolean = true): void {\n    if (this.ngZone != null) {\n      // Run the change detection inside the NgZone so that any async tasks as part of the change\n      // detection are captured by the zone and can be waited for in isStable.\n      this.ngZone.run(() => {\n        this._tick(checkNoChanges);\n      });\n    } else {\n      // Running without zone. Just do the change detection.\n      this._tick(checkNoChanges);\n    }\n  }\n\n  /**\n   * Do a change detection run to make sure there were no changes.\n   */\n  checkNoChanges(): void {\n    this.changeDetectorRef.checkNoChanges();\n  }\n\n  /**\n   * Set whether the fixture should autodetect changes.\n   *\n   * Also runs detectChanges once so that any existing change is detected.\n   */\n  autoDetectChanges(autoDetect: boolean = true) {\n    if (this.ngZone == null) {\n      throw new Error('Cannot call autoDetectChanges when ComponentFixtureNoNgZone is set');\n    }\n    this._autoDetect = autoDetect;\n    this.detectChanges();\n  }\n\n  /**\n   * Return whether the fixture is currently stable or has async tasks that have not been completed\n   * yet.\n   */\n  isStable(): boolean {\n    return this._isStable && !this.ngZone!.hasPendingMacrotasks;\n  }\n\n  /**\n   * Get a promise that resolves when the fixture is stable.\n   *\n   * This can be used to resume testing after events have triggered asynchronous activity or\n   * asynchronous change detection.\n   */\n  whenStable(): Promise<any> {\n    if (this.isStable()) {\n      return Promise.resolve(false);\n    } else if (this._promise !== null) {\n      return this._promise;\n    } else {\n      this._promise = new Promise(res => {\n        this._resolve = res;\n      });\n      return this._promise;\n    }\n  }\n\n\n  private _getRenderer() {\n    if (this._renderer === undefined) {\n      this._renderer = this.componentRef.injector.get(RendererFactory2, null);\n    }\n    return this._renderer as RendererFactory2 | null;\n  }\n\n  /**\n   * Get a promise that resolves when the ui state is stable following animations.\n   */\n  whenRenderingDone(): Promise<any> {\n    const renderer = this._getRenderer();\n    if (renderer && renderer.whenRenderingDone) {\n      return renderer.whenRenderingDone();\n    }\n    return this.whenStable();\n  }\n\n  /**\n   * Trigger component destruction.\n   */\n  destroy(): void {\n    if (!this._isDestroyed) {\n      this.componentRef.destroy();\n      if (this._onUnstableSubscription != null) {\n        this._onUnstableSubscription.unsubscribe();\n        this._onUnstableSubscription = null;\n      }\n      if (this._onStableSubscription != null) {\n        this._onStableSubscription.unsubscribe();\n        this._onStableSubscription = null;\n      }\n      if (this._onMicrotaskEmptySubscription != null) {\n        this._onMicrotaskEmptySubscription.unsubscribe();\n        this._onMicrotaskEmptySubscription = null;\n      }\n      if (this._onErrorSubscription != null) {\n        this._onErrorSubscription.unsubscribe();\n        this._onErrorSubscription = null;\n      }\n      this._isDestroyed = true;\n    }\n  }\n}\n\nfunction scheduleMicroTask(fn: Function) {\n  Zone.current.scheduleMicroTask('scheduleMicrotask', fn);\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * fakeAsync has been moved to zone.js\n * this file is for fallback in case old version of zone.js is used\n */\nconst _Zone: any = typeof Zone !== 'undefined' ? Zone : null;\nconst FakeAsyncTestZoneSpec = _Zone && _Zone['FakeAsyncTestZoneSpec'];\ntype ProxyZoneSpec = {\n  setDelegate(delegateSpec: ZoneSpec): void; getDelegate(): ZoneSpec; resetDelegate(): void;\n};\nconst ProxyZoneSpec: {get(): ProxyZoneSpec; assertPresent: () => ProxyZoneSpec} =\n    _Zone && _Zone['ProxyZoneSpec'];\n\nlet _fakeAsyncTestZoneSpec: any = null;\n\n/**\n * Clears out the shared fake async zone for a test.\n * To be called in a global `beforeEach`.\n *\n * @publicApi\n */\nexport function resetFakeAsyncZoneFallback() {\n  if (_fakeAsyncTestZoneSpec) {\n    _fakeAsyncTestZoneSpec.unlockDatePatch();\n  }\n  _fakeAsyncTestZoneSpec = null;\n  // in node.js testing we may not have ProxyZoneSpec in which case there is nothing to reset.\n  ProxyZoneSpec && ProxyZoneSpec.assertPresent().resetDelegate();\n}\n\nlet _inFakeAsyncCall = false;\n\n/**\n * Wraps a function to be executed in the fakeAsync zone:\n * - microtasks are manually executed by calling `flushMicrotasks()`,\n * - timers are synchronous, `tick()` simulates the asynchronous passage of time.\n *\n * If there are any pending timers at the end of the function, an exception will be thrown.\n *\n * Can be used to wrap inject() calls.\n *\n * @usageNotes\n * ### Example\n *\n * {@example core/testing/ts/fake_async.ts region='basic'}\n *\n * @param fn\n * @returns The function wrapped to be executed in the fakeAsync zone\n *\n * @publicApi\n */\nexport function fakeAsyncFallback(fn: Function): (...args: any[]) => any {\n  // Not using an arrow function to preserve context passed from call site\n  return function(this: unknown, ...args: any[]) {\n    const proxyZoneSpec = ProxyZoneSpec.assertPresent();\n    if (_inFakeAsyncCall) {\n      throw new Error('fakeAsync() calls can not be nested');\n    }\n    _inFakeAsyncCall = true;\n    try {\n      if (!_fakeAsyncTestZoneSpec) {\n        if (proxyZoneSpec.getDelegate() instanceof FakeAsyncTestZoneSpec) {\n          throw new Error('fakeAsync() calls can not be nested');\n        }\n\n        _fakeAsyncTestZoneSpec = new FakeAsyncTestZoneSpec();\n      }\n\n      let res: any;\n      const lastProxyZoneSpec = proxyZoneSpec.getDelegate();\n      proxyZoneSpec.setDelegate(_fakeAsyncTestZoneSpec);\n      _fakeAsyncTestZoneSpec.lockDatePatch();\n      try {\n        res = fn.apply(this, args);\n        flushMicrotasksFallback();\n      } finally {\n        proxyZoneSpec.setDelegate(lastProxyZoneSpec);\n      }\n\n      if (_fakeAsyncTestZoneSpec.pendingPeriodicTimers.length > 0) {\n        throw new Error(\n            `${_fakeAsyncTestZoneSpec.pendingPeriodicTimers.length} ` +\n            `periodic timer(s) still in the queue.`);\n      }\n\n      if (_fakeAsyncTestZoneSpec.pendingTimers.length > 0) {\n        throw new Error(\n            `${_fakeAsyncTestZoneSpec.pendingTimers.length} timer(s) still in the queue.`);\n      }\n      return res;\n    } finally {\n      _inFakeAsyncCall = false;\n      resetFakeAsyncZoneFallback();\n    }\n  };\n}\n\nfunction _getFakeAsyncZoneSpec(): any {\n  if (_fakeAsyncTestZoneSpec == null) {\n    throw new Error('The code should be running in the fakeAsync zone to call this function');\n  }\n  return _fakeAsyncTestZoneSpec;\n}\n\n/**\n * Simulates the asynchronous passage of time for the timers in the fakeAsync zone.\n *\n * The microtasks queue is drained at the very start of this function and after any timer callback\n * has been executed.\n *\n * @usageNotes\n * ### Example\n *\n * {@example core/testing/ts/fake_async.ts region='basic'}\n *\n * @publicApi\n */\nexport function tickFallback(\n    millis: number = 0, tickOptions: {processNewMacroTasksSynchronously: boolean} = {\n      processNewMacroTasksSynchronously: true\n    }): void {\n  _getFakeAsyncZoneSpec().tick(millis, null, tickOptions);\n}\n\n/**\n * Simulates the asynchronous passage of time for the timers in the fakeAsync zone by\n * draining the macrotask queue until it is empty. The returned value is the milliseconds\n * of time that would have been elapsed.\n *\n * @param maxTurns\n * @returns The simulated time elapsed, in millis.\n *\n * @publicApi\n */\nexport function flushFallback(maxTurns?: number): number {\n  return _getFakeAsyncZoneSpec().flush(maxTurns);\n}\n\n/**\n * Discard all remaining periodic tasks.\n *\n * @publicApi\n */\nexport function discardPeriodicTasksFallback(): void {\n  const zoneSpec = _getFakeAsyncZoneSpec();\n  zoneSpec.pendingPeriodicTimers.length = 0;\n}\n\n/**\n * Flush any pending microtasks.\n *\n * @publicApi\n */\nexport function flushMicrotasksFallback(): void {\n  _getFakeAsyncZoneSpec().flushMicrotasks();\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {discardPeriodicTasksFallback, fakeAsyncFallback, flushFallback, flushMicrotasksFallback, resetFakeAsyncZoneFallback, tickFallback} from './fake_async_fallback';\n\nconst _Zone: any = typeof Zone !== 'undefined' ? Zone : null;\nconst fakeAsyncTestModule = _Zone && _Zone[_Zone.__symbol__('fakeAsyncTest')];\n\n/**\n * Clears out the shared fake async zone for a test.\n * To be called in a global `beforeEach`.\n *\n * @publicApi\n */\nexport function resetFakeAsyncZone(): void {\n  if (fakeAsyncTestModule) {\n    return fakeAsyncTestModule.resetFakeAsyncZone();\n  } else {\n    return resetFakeAsyncZoneFallback();\n  }\n}\n\n/**\n * Wraps a function to be executed in the fakeAsync zone:\n * - microtasks are manually executed by calling `flushMicrotasks()`,\n * - timers are synchronous, `tick()` simulates the asynchronous passage of time.\n *\n * If there are any pending timers at the end of the function, an exception will be thrown.\n *\n * Can be used to wrap inject() calls.\n *\n * @usageNotes\n * ### Example\n *\n * {@example core/testing/ts/fake_async.ts region='basic'}\n *\n * @param fn\n * @returns The function wrapped to be executed in the fakeAsync zone\n *\n * @publicApi\n */\nexport function fakeAsync(fn: Function): (...args: any[]) => any {\n  if (fakeAsyncTestModule) {\n    return fakeAsyncTestModule.fakeAsync(fn);\n  } else {\n    return fakeAsyncFallback(fn);\n  }\n}\n\n/**\n * Simulates the asynchronous passage of time for the timers in the fakeAsync zone.\n *\n * The microtasks queue is drained at the very start of this function and after any timer callback\n * has been executed.\n *\n * @usageNotes\n * ### Example\n *\n * {@example core/testing/ts/fake_async.ts region='basic'}\n *\n * @param millis, the number of millisecond to advance the virtual timer\n * @param tickOptions, the options of tick with a flag called\n * processNewMacroTasksSynchronously, whether to invoke the new macroTasks, by default is\n * false, means the new macroTasks will be invoked\n *\n * For example,\n *\n * it ('test with nested setTimeout', fakeAsync(() => {\n *   let nestedTimeoutInvoked = false;\n *   function funcWithNestedTimeout() {\n *     setTimeout(() => {\n *       nestedTimeoutInvoked = true;\n *     });\n *   };\n *   setTimeout(funcWithNestedTimeout);\n *   tick();\n *   expect(nestedTimeoutInvoked).toBe(true);\n * }));\n *\n * in this case, we have a nested timeout (new macroTask), when we tick, both the\n * funcWithNestedTimeout and the nested timeout both will be invoked.\n *\n * it ('test with nested setTimeout', fakeAsync(() => {\n *   let nestedTimeoutInvoked = false;\n *   function funcWithNestedTimeout() {\n *     setTimeout(() => {\n *       nestedTimeoutInvoked = true;\n *     });\n *   };\n *   setTimeout(funcWithNestedTimeout);\n *   tick(0, {processNewMacroTasksSynchronously: false});\n *   expect(nestedTimeoutInvoked).toBe(false);\n * }));\n *\n * if we pass the tickOptions with processNewMacroTasksSynchronously to be false, the nested timeout\n * will not be invoked.\n *\n *\n * @publicApi\n */\nexport function tick(\n    millis: number = 0, tickOptions: {processNewMacroTasksSynchronously: boolean} = {\n      processNewMacroTasksSynchronously: true\n    }): void {\n  if (fakeAsyncTestModule) {\n    return fakeAsyncTestModule.tick(millis, tickOptions);\n  } else {\n    return tickFallback(millis, tickOptions);\n  }\n}\n\n/**\n * Simulates the asynchronous passage of time for the timers in the fakeAsync zone by\n * draining the macrotask queue until it is empty. The returned value is the milliseconds\n * of time that would have been elapsed.\n *\n * @param maxTurns\n * @returns The simulated time elapsed, in millis.\n *\n * @publicApi\n */\nexport function flush(maxTurns?: number): number {\n  if (fakeAsyncTestModule) {\n    return fakeAsyncTestModule.flush(maxTurns);\n  } else {\n    return flushFallback(maxTurns);\n  }\n}\n\n/**\n * Discard all remaining periodic tasks.\n *\n * @publicApi\n */\nexport function discardPeriodicTasks(): void {\n  if (fakeAsyncTestModule) {\n    return fakeAsyncTestModule.discardPeriodicTasks();\n  } else {\n    discardPeriodicTasksFallback();\n  }\n}\n\n/**\n * Flush any pending microtasks.\n *\n * @publicApi\n */\nexport function flushMicrotasks(): void {\n  if (fakeAsyncTestModule) {\n    return fakeAsyncTestModule.flushMicrotasks();\n  } else {\n    return flushMicrotasksFallback();\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Injectable completer that allows signaling completion of an asynchronous test. Used internally.\n */\nexport class AsyncTestCompleter {\n  // TODO(issue/24571): remove '!'.\n  private _resolve!: (result: any) => void;\n  // TODO(issue/24571): remove '!'.\n  private _reject!: (err: any) => void;\n  private _promise: Promise<any> = new Promise((res, rej) => {\n    this._resolve = res;\n    this._reject = rej;\n  });\n  done(value?: any) {\n    this._resolve(value);\n  }\n\n  fail(error?: any, stackTrace?: string) {\n    this._reject(error);\n  }\n\n  get promise(): Promise<any> {\n    return this._promise;\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Type} from '../interface/type';\nimport {Component} from './directives';\n\n\n/**\n * Used to resolve resource URLs on `@Component` when used with JIT compilation.\n *\n * Example:\n * ```\n * @Component({\n *   selector: 'my-comp',\n *   templateUrl: 'my-comp.html', // This requires asynchronous resolution\n * })\n * class MyComponent{\n * }\n *\n * // Calling `renderComponent` will fail because `renderComponent` is a synchronous process\n * // and `MyComponent`'s `@Component.templateUrl` needs to be resolved asynchronously.\n *\n * // Calling `resolveComponentResources()` will resolve `@Component.templateUrl` into\n * // `@Component.template`, which allows `renderComponent` to proceed in a synchronous manner.\n *\n * // Use browser's `fetch()` function as the default resource resolution strategy.\n * resolveComponentResources(fetch).then(() => {\n *   // After resolution all URLs have been converted into `template` strings.\n *   renderComponent(MyComponent);\n * });\n *\n * ```\n *\n * NOTE: In AOT the resolution happens during compilation, and so there should be no need\n * to call this method outside JIT mode.\n *\n * @param resourceResolver a function which is responsible for returning a `Promise` to the\n * contents of the resolved URL. Browser's `fetch()` method is a good default implementation.\n */\nexport function resolveComponentResources(\n    resourceResolver: (url: string) => (Promise<string|{text(): Promise<string>}>)): Promise<void> {\n  // Store all promises which are fetching the resources.\n  const componentResolved: Promise<void>[] = [];\n\n  // Cache so that we don't fetch the same resource more than once.\n  const urlMap = new Map<string, Promise<string>>();\n  function cachedResourceResolve(url: string): Promise<string> {\n    let promise = urlMap.get(url);\n    if (!promise) {\n      const resp = resourceResolver(url);\n      urlMap.set(url, promise = resp.then(unwrapResponse));\n    }\n    return promise;\n  }\n\n  componentResourceResolutionQueue.forEach((component: Component, type: Type<any>) => {\n    const promises: Promise<void>[] = [];\n    if (component.templateUrl) {\n      promises.push(cachedResourceResolve(component.templateUrl).then((template) => {\n        component.template = template;\n      }));\n    }\n    const styleUrls = component.styleUrls;\n    const styles = component.styles || (component.styles = []);\n    const styleOffset = component.styles.length;\n    styleUrls && styleUrls.forEach((styleUrl, index) => {\n      styles.push('');  // pre-allocate array.\n      promises.push(cachedResourceResolve(styleUrl).then((style) => {\n        styles[styleOffset + index] = style;\n        styleUrls.splice(styleUrls.indexOf(styleUrl), 1);\n        if (styleUrls.length == 0) {\n          component.styleUrls = undefined;\n        }\n      }));\n    });\n    const fullyResolved = Promise.all(promises).then(() => componentDefResolved(type));\n    componentResolved.push(fullyResolved);\n  });\n  clearResolutionOfComponentResourcesQueue();\n  return Promise.all(componentResolved).then(() => undefined);\n}\n\nlet componentResourceResolutionQueue = new Map<Type<any>, Component>();\n\n// Track when existing ɵcmp for a Type is waiting on resources.\nconst componentDefPendingResolution = new Set<Type<any>>();\n\nexport function maybeQueueResolutionOfComponentResources(type: Type<any>, metadata: Component) {\n  if (componentNeedsResolution(metadata)) {\n    componentResourceResolutionQueue.set(type, metadata);\n    componentDefPendingResolution.add(type);\n  }\n}\n\nexport function isComponentDefPendingResolution(type: Type<any>): boolean {\n  return componentDefPendingResolution.has(type);\n}\n\nexport function componentNeedsResolution(component: Component): boolean {\n  return !!(\n      (component.templateUrl && !component.hasOwnProperty('template')) ||\n      component.styleUrls && component.styleUrls.length);\n}\nexport function clearResolutionOfComponentResourcesQueue(): Map<Type<any>, Component> {\n  const old = componentResourceResolutionQueue;\n  componentResourceResolutionQueue = new Map();\n  return old;\n}\n\nexport function restoreComponentResolutionQueue(queue: Map<Type<any>, Component>): void {\n  componentDefPendingResolution.clear();\n  queue.forEach((_, type) => componentDefPendingResolution.add(type));\n  componentResourceResolutionQueue = queue;\n}\n\nexport function isComponentResourceResolutionQueueEmpty() {\n  return componentResourceResolutionQueue.size === 0;\n}\n\nfunction unwrapResponse(response: string|{text(): Promise<string>}): string|Promise<string> {\n  return typeof response == 'string' ? response : response.text();\n}\n\nfunction componentDefResolved(type: Type<any>): void {\n  componentDefPendingResolution.delete(type);\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ɵstringify as stringify} from '@angular/core';\nimport {MetadataOverride} from './metadata_override';\n\ntype StringMap = {\n  [key: string]: any\n};\n\nlet _nextReferenceId = 0;\n\nexport class MetadataOverrider {\n  private _references = new Map<any, string>();\n  /**\n   * Creates a new instance for the given metadata class\n   * based on an old instance and overrides.\n   */\n  overrideMetadata<C extends T, T>(\n      metadataClass: {new(options: T): C;}, oldMetadata: C, override: MetadataOverride<T>): C {\n    const props: StringMap = {};\n    if (oldMetadata) {\n      _valueProps(oldMetadata).forEach((prop) => props[prop] = (<any>oldMetadata)[prop]);\n    }\n\n    if (override.set) {\n      if (override.remove || override.add) {\n        throw new Error(`Cannot set and add/remove ${stringify(metadataClass)} at the same time!`);\n      }\n      setMetadata(props, override.set);\n    }\n    if (override.remove) {\n      removeMetadata(props, override.remove, this._references);\n    }\n    if (override.add) {\n      addMetadata(props, override.add);\n    }\n    return new metadataClass(<any>props);\n  }\n}\n\nfunction removeMetadata(metadata: StringMap, remove: any, references: Map<any, string>) {\n  const removeObjects = new Set<string>();\n  for (const prop in remove) {\n    const removeValue = remove[prop];\n    if (Array.isArray(removeValue)) {\n      removeValue.forEach((value: any) => {\n        removeObjects.add(_propHashKey(prop, value, references));\n      });\n    } else {\n      removeObjects.add(_propHashKey(prop, removeValue, references));\n    }\n  }\n\n  for (const prop in metadata) {\n    const propValue = metadata[prop];\n    if (Array.isArray(propValue)) {\n      metadata[prop] = propValue.filter(\n          (value: any) => !removeObjects.has(_propHashKey(prop, value, references)));\n    } else {\n      if (removeObjects.has(_propHashKey(prop, propValue, references))) {\n        metadata[prop] = undefined;\n      }\n    }\n  }\n}\n\nfunction addMetadata(metadata: StringMap, add: any) {\n  for (const prop in add) {\n    const addValue = add[prop];\n    const propValue = metadata[prop];\n    if (propValue != null && Array.isArray(propValue)) {\n      metadata[prop] = propValue.concat(addValue);\n    } else {\n      metadata[prop] = addValue;\n    }\n  }\n}\n\nfunction setMetadata(metadata: StringMap, set: any) {\n  for (const prop in set) {\n    metadata[prop] = set[prop];\n  }\n}\n\nfunction _propHashKey(propName: any, propValue: any, references: Map<any, string>): string {\n  const replacer = (key: any, value: any) => {\n    if (typeof value === 'function') {\n      value = _serializeReference(value, references);\n    }\n    return value;\n  };\n\n  return `${propName}:${JSON.stringify(propValue, replacer)}`;\n}\n\nfunction _serializeReference(ref: any, references: Map<any, string>): string {\n  let id = references.get(ref);\n  if (!id) {\n    id = `${stringify(ref)}${_nextReferenceId++}`;\n    references.set(ref, id);\n  }\n  return id;\n}\n\n\nfunction _valueProps(obj: any): string[] {\n  const props: string[] = [];\n  // regular public props\n  Object.keys(obj).forEach((prop) => {\n    if (!prop.startsWith('_')) {\n      props.push(prop);\n    }\n  });\n\n  // getters\n  let proto = obj;\n  while (proto = Object.getPrototypeOf(proto)) {\n    Object.keys(proto).forEach((protoProp) => {\n      const desc = Object.getOwnPropertyDescriptor(proto, protoProp);\n      if (!protoProp.startsWith('_') && desc && 'get' in desc) {\n        props.push(protoProp);\n      }\n    });\n  }\n  return props;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Component, Directive, NgModule, Pipe, Type, ɵReflectionCapabilities as ReflectionCapabilities} from '@angular/core';\n\nimport {MetadataOverride} from './metadata_override';\nimport {MetadataOverrider} from './metadata_overrider';\n\nconst reflection = new ReflectionCapabilities();\n\n/**\n * Base interface to resolve `@Component`, `@Directive`, `@Pipe` and `@NgModule`.\n */\nexport interface Resolver<T> {\n  addOverride(type: Type<any>, override: MetadataOverride<T>): void;\n  setOverrides(overrides: Array<[Type<any>, MetadataOverride<T>]>): void;\n  resolve(type: Type<any>): T|null;\n}\n\n/**\n * Allows to override ivy metadata for tests (via the `TestBed`).\n */\nabstract class OverrideResolver<T> implements Resolver<T> {\n  private overrides = new Map<Type<any>, MetadataOverride<T>[]>();\n  private resolved = new Map<Type<any>, T|null>();\n\n  abstract get type(): any;\n\n  addOverride(type: Type<any>, override: MetadataOverride<T>) {\n    const overrides = this.overrides.get(type) || [];\n    overrides.push(override);\n    this.overrides.set(type, overrides);\n    this.resolved.delete(type);\n  }\n\n  setOverrides(overrides: Array<[Type<any>, MetadataOverride<T>]>) {\n    this.overrides.clear();\n    overrides.forEach(([type, override]) => {\n      this.addOverride(type, override);\n    });\n  }\n\n  getAnnotation(type: Type<any>): T|null {\n    const annotations = reflection.annotations(type);\n    // Try to find the nearest known Type annotation and make sure that this annotation is an\n    // instance of the type we are looking for, so we can use it for resolution. Note: there might\n    // be multiple known annotations found due to the fact that Components can extend Directives (so\n    // both Directive and Component annotations would be present), so we always check if the known\n    // annotation has the right type.\n    for (let i = annotations.length - 1; i >= 0; i--) {\n      const annotation = annotations[i];\n      const isKnownType = annotation instanceof Directive || annotation instanceof Component ||\n          annotation instanceof Pipe || annotation instanceof NgModule;\n      if (isKnownType) {\n        return annotation instanceof this.type ? annotation : null;\n      }\n    }\n    return null;\n  }\n\n  resolve(type: Type<any>): T|null {\n    let resolved = this.resolved.get(type) || null;\n\n    if (!resolved) {\n      resolved = this.getAnnotation(type);\n      if (resolved) {\n        const overrides = this.overrides.get(type);\n        if (overrides) {\n          const overrider = new MetadataOverrider();\n          overrides.forEach(override => {\n            resolved = overrider.overrideMetadata(this.type, resolved!, override);\n          });\n        }\n      }\n      this.resolved.set(type, resolved);\n    }\n\n    return resolved;\n  }\n}\n\n\nexport class DirectiveResolver extends OverrideResolver<Directive> {\n  get type() {\n    return Directive;\n  }\n}\n\nexport class ComponentResolver extends OverrideResolver<Component> {\n  get type() {\n    return Component;\n  }\n}\n\nexport class PipeResolver extends OverrideResolver<Pipe> {\n  get type() {\n    return Pipe;\n  }\n}\n\nexport class NgModuleResolver extends OverrideResolver<NgModule> {\n  get type() {\n    return NgModule;\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ResourceLoader} from '@angular/compiler';\nimport {ApplicationInitStatus, Compiler, COMPILER_OPTIONS, Component, Directive, Injector, InjectorType, LOCALE_ID, ModuleWithComponentFactories, ModuleWithProviders, NgModule, NgModuleFactory, NgZone, Pipe, PlatformRef, Provider, Type, ɵcompileComponent as compileComponent, ɵcompileDirective as compileDirective, ɵcompileNgModuleDefs as compileNgModuleDefs, ɵcompilePipe as compilePipe, ɵDEFAULT_LOCALE_ID as DEFAULT_LOCALE_ID, ɵDirectiveDef as DirectiveDef, ɵgetInjectableDef as getInjectableDef, ɵNG_COMP_DEF as NG_COMP_DEF, ɵNG_DIR_DEF as NG_DIR_DEF, ɵNG_INJ_DEF as NG_INJ_DEF, ɵNG_MOD_DEF as NG_MOD_DEF, ɵNG_PIPE_DEF as NG_PIPE_DEF, ɵNgModuleFactory as R3NgModuleFactory, ɵNgModuleTransitiveScopes as NgModuleTransitiveScopes, ɵNgModuleType as NgModuleType, ɵpatchComponentDefWithScope as patchComponentDefWithScope, ɵRender3ComponentFactory as ComponentFactory, ɵRender3NgModuleRef as NgModuleRef, ɵsetLocaleId as setLocaleId, ɵtransitiveScopesFor as transitiveScopesFor, ɵɵInjectableDef as InjectableDef} from '@angular/core';\n\nimport {clearResolutionOfComponentResourcesQueue, isComponentDefPendingResolution, resolveComponentResources, restoreComponentResolutionQueue} from '../../src/metadata/resource_loading';\n\nimport {MetadataOverride} from './metadata_override';\nimport {ComponentResolver, DirectiveResolver, NgModuleResolver, PipeResolver, Resolver} from './resolvers';\nimport {TestModuleMetadata} from './test_bed_common';\n\nenum TestingModuleOverride {\n  DECLARATION,\n  OVERRIDE_TEMPLATE,\n}\n\nfunction isTestingModuleOverride(value: unknown): value is TestingModuleOverride {\n  return value === TestingModuleOverride.DECLARATION ||\n      value === TestingModuleOverride.OVERRIDE_TEMPLATE;\n}\n\n// Resolvers for Angular decorators\ntype Resolvers = {\n  module: Resolver<NgModule>,\n  component: Resolver<Directive>,\n  directive: Resolver<Component>,\n  pipe: Resolver<Pipe>,\n};\n\ninterface CleanupOperation {\n  fieldName: string;\n  object: any;\n  originalValue: unknown;\n}\n\nexport class R3TestBedCompiler {\n  private originalComponentResolutionQueue: Map<Type<any>, Component>|null = null;\n\n  // Testing module configuration\n  private declarations: Type<any>[] = [];\n  private imports: Type<any>[] = [];\n  private providers: Provider[] = [];\n  private schemas: any[] = [];\n\n  // Queues of components/directives/pipes that should be recompiled.\n  private pendingComponents = new Set<Type<any>>();\n  private pendingDirectives = new Set<Type<any>>();\n  private pendingPipes = new Set<Type<any>>();\n\n  // Keep track of all components and directives, so we can patch Providers onto defs later.\n  private seenComponents = new Set<Type<any>>();\n  private seenDirectives = new Set<Type<any>>();\n\n  // Keep track of overridden modules, so that we can collect all affected ones in the module tree.\n  private overriddenModules = new Set<NgModuleType<any>>();\n\n  // Store resolved styles for Components that have template overrides present and `styleUrls`\n  // defined at the same time.\n  private existingComponentStyles = new Map<Type<any>, string[]>();\n\n  private resolvers: Resolvers = initResolvers();\n\n  private componentToModuleScope = new Map<Type<any>, Type<any>|TestingModuleOverride>();\n\n  // Map that keeps initial version of component/directive/pipe defs in case\n  // we compile a Type again, thus overriding respective static fields. This is\n  // required to make sure we restore defs to their initial states between test runs\n  // TODO: we should support the case with multiple defs on a type\n  private initialNgDefs = new Map<Type<any>, [string, PropertyDescriptor|undefined]>();\n\n  // Array that keeps cleanup operations for initial versions of component/directive/pipe/module\n  // defs in case TestBed makes changes to the originals.\n  private defCleanupOps: CleanupOperation[] = [];\n\n  private _injector: Injector|null = null;\n  private compilerProviders: Provider[]|null = null;\n\n  private providerOverrides: Provider[] = [];\n  private rootProviderOverrides: Provider[] = [];\n  // Overrides for injectables with `{providedIn: SomeModule}` need to be tracked and added to that\n  // module's provider list.\n  private providerOverridesByModule = new Map<InjectorType<any>, Provider[]>();\n  private providerOverridesByToken = new Map<any, Provider>();\n  private moduleProvidersOverridden = new Set<Type<any>>();\n\n  private testModuleType: NgModuleType<any>;\n  private testModuleRef: NgModuleRef<any>|null = null;\n\n  constructor(private platform: PlatformRef, private additionalModuleTypes: Type<any>|Type<any>[]) {\n    class DynamicTestModule {}\n    this.testModuleType = DynamicTestModule as any;\n  }\n\n  setCompilerProviders(providers: Provider[]|null): void {\n    this.compilerProviders = providers;\n    this._injector = null;\n  }\n\n  configureTestingModule(moduleDef: TestModuleMetadata): void {\n    // Enqueue any compilation tasks for the directly declared component.\n    if (moduleDef.declarations !== undefined) {\n      this.queueTypeArray(moduleDef.declarations, TestingModuleOverride.DECLARATION);\n      this.declarations.push(...moduleDef.declarations);\n    }\n\n    // Enqueue any compilation tasks for imported modules.\n    if (moduleDef.imports !== undefined) {\n      this.queueTypesFromModulesArray(moduleDef.imports);\n      this.imports.push(...moduleDef.imports);\n    }\n\n    if (moduleDef.providers !== undefined) {\n      this.providers.push(...moduleDef.providers);\n    }\n\n    if (moduleDef.schemas !== undefined) {\n      this.schemas.push(...moduleDef.schemas);\n    }\n  }\n\n  overrideModule(ngModule: Type<any>, override: MetadataOverride<NgModule>): void {\n    this.overriddenModules.add(ngModule as NgModuleType<any>);\n\n    // Compile the module right away.\n    this.resolvers.module.addOverride(ngModule, override);\n    const metadata = this.resolvers.module.resolve(ngModule);\n    if (metadata === null) {\n      throw invalidTypeError(ngModule.name, 'NgModule');\n    }\n\n    this.recompileNgModule(ngModule, metadata);\n\n    // At this point, the module has a valid module def (ɵmod), but the override may have introduced\n    // new declarations or imported modules. Ingest any possible new types and add them to the\n    // current queue.\n    this.queueTypesFromModulesArray([ngModule]);\n  }\n\n  overrideComponent(component: Type<any>, override: MetadataOverride<Component>): void {\n    this.resolvers.component.addOverride(component, override);\n    this.pendingComponents.add(component);\n  }\n\n  overrideDirective(directive: Type<any>, override: MetadataOverride<Directive>): void {\n    this.resolvers.directive.addOverride(directive, override);\n    this.pendingDirectives.add(directive);\n  }\n\n  overridePipe(pipe: Type<any>, override: MetadataOverride<Pipe>): void {\n    this.resolvers.pipe.addOverride(pipe, override);\n    this.pendingPipes.add(pipe);\n  }\n\n  overrideProvider(\n      token: any,\n      provider: {useFactory?: Function, useValue?: any, deps?: any[], multi?: boolean}): void {\n    let providerDef: Provider;\n    if (provider.useFactory !== undefined) {\n      providerDef = {\n        provide: token,\n        useFactory: provider.useFactory,\n        deps: provider.deps || [],\n        multi: provider.multi\n      };\n    } else if (provider.useValue !== undefined) {\n      providerDef = {provide: token, useValue: provider.useValue, multi: provider.multi};\n    } else {\n      providerDef = {provide: token};\n    }\n\n    const injectableDef: InjectableDef<any>|null =\n        typeof token !== 'string' ? getInjectableDef(token) : null;\n    const isRoot = injectableDef !== null && injectableDef.providedIn === 'root';\n    const overridesBucket = isRoot ? this.rootProviderOverrides : this.providerOverrides;\n    overridesBucket.push(providerDef);\n\n    // Keep overrides grouped by token as well for fast lookups using token\n    this.providerOverridesByToken.set(token, providerDef);\n    if (injectableDef !== null && injectableDef.providedIn !== null &&\n        typeof injectableDef.providedIn !== 'string') {\n      const existingOverrides = this.providerOverridesByModule.get(injectableDef.providedIn);\n      if (existingOverrides !== undefined) {\n        existingOverrides.push(providerDef);\n      } else {\n        this.providerOverridesByModule.set(injectableDef.providedIn, [providerDef]);\n      }\n    }\n  }\n\n  overrideTemplateUsingTestingModule(type: Type<any>, template: string): void {\n    const def = (type as any)[NG_COMP_DEF];\n    const hasStyleUrls = (): boolean => {\n      const metadata = this.resolvers.component.resolve(type)! as Component;\n      return !!metadata.styleUrls && metadata.styleUrls.length > 0;\n    };\n    const overrideStyleUrls = !!def && !isComponentDefPendingResolution(type) && hasStyleUrls();\n\n    // In Ivy, compiling a component does not require knowing the module providing the\n    // component's scope, so overrideTemplateUsingTestingModule can be implemented purely via\n    // overrideComponent. Important: overriding template requires full Component re-compilation,\n    // which may fail in case styleUrls are also present (thus Component is considered as required\n    // resolution). In order to avoid this, we preemptively set styleUrls to an empty array,\n    // preserve current styles available on Component def and restore styles back once compilation\n    // is complete.\n    const override = overrideStyleUrls ? {template, styles: [], styleUrls: []} : {template};\n    this.overrideComponent(type, {set: override});\n\n    if (overrideStyleUrls && def.styles && def.styles.length > 0) {\n      this.existingComponentStyles.set(type, def.styles);\n    }\n\n    // Set the component's scope to be the testing module.\n    this.componentToModuleScope.set(type, TestingModuleOverride.OVERRIDE_TEMPLATE);\n  }\n\n  async compileComponents(): Promise<void> {\n    this.clearComponentResolutionQueue();\n    // Run compilers for all queued types.\n    let needsAsyncResources = this.compileTypesSync();\n\n    // compileComponents() should not be async unless it needs to be.\n    if (needsAsyncResources) {\n      let resourceLoader: ResourceLoader;\n      let resolver = (url: string): Promise<string> => {\n        if (!resourceLoader) {\n          resourceLoader = this.injector.get(ResourceLoader);\n        }\n        return Promise.resolve(resourceLoader.get(url));\n      };\n      await resolveComponentResources(resolver);\n    }\n  }\n\n  finalize(): NgModuleRef<any> {\n    // One last compile\n    this.compileTypesSync();\n\n    // Create the testing module itself.\n    this.compileTestModule();\n\n    this.applyTransitiveScopes();\n\n    this.applyProviderOverrides();\n\n    // Patch previously stored `styles` Component values (taken from ɵcmp), in case these\n    // Components have `styleUrls` fields defined and template override was requested.\n    this.patchComponentsWithExistingStyles();\n\n    // Clear the componentToModuleScope map, so that future compilations don't reset the scope of\n    // every component.\n    this.componentToModuleScope.clear();\n\n    const parentInjector = this.platform.injector;\n    this.testModuleRef = new NgModuleRef(this.testModuleType, parentInjector);\n\n    // ApplicationInitStatus.runInitializers() is marked @internal to core.\n    // Cast it to any before accessing it.\n    (this.testModuleRef.injector.get(ApplicationInitStatus) as any).runInitializers();\n\n    // Set locale ID after running app initializers, since locale information might be updated while\n    // running initializers. This is also consistent with the execution order while bootstrapping an\n    // app (see `packages/core/src/application_ref.ts` file).\n    const localeId = this.testModuleRef.injector.get(LOCALE_ID, DEFAULT_LOCALE_ID);\n    setLocaleId(localeId);\n\n    return this.testModuleRef;\n  }\n\n  /**\n   * @internal\n   */\n  _compileNgModuleSync(moduleType: Type<any>): void {\n    this.queueTypesFromModulesArray([moduleType]);\n    this.compileTypesSync();\n    this.applyProviderOverrides();\n    this.applyProviderOverridesToModule(moduleType);\n    this.applyTransitiveScopes();\n  }\n\n  /**\n   * @internal\n   */\n  async _compileNgModuleAsync(moduleType: Type<any>): Promise<void> {\n    this.queueTypesFromModulesArray([moduleType]);\n    await this.compileComponents();\n    this.applyProviderOverrides();\n    this.applyProviderOverridesToModule(moduleType);\n    this.applyTransitiveScopes();\n  }\n\n  /**\n   * @internal\n   */\n  _getModuleResolver(): Resolver<NgModule> {\n    return this.resolvers.module;\n  }\n\n  /**\n   * @internal\n   */\n  _getComponentFactories(moduleType: NgModuleType): ComponentFactory<any>[] {\n    return maybeUnwrapFn(moduleType.ɵmod.declarations).reduce((factories, declaration) => {\n      const componentDef = (declaration as any).ɵcmp;\n      componentDef && factories.push(new ComponentFactory(componentDef, this.testModuleRef!));\n      return factories;\n    }, [] as ComponentFactory<any>[]);\n  }\n\n  private compileTypesSync(): boolean {\n    // Compile all queued components, directives, pipes.\n    let needsAsyncResources = false;\n    this.pendingComponents.forEach(declaration => {\n      needsAsyncResources = needsAsyncResources || isComponentDefPendingResolution(declaration);\n      const metadata = this.resolvers.component.resolve(declaration);\n      if (metadata === null) {\n        throw invalidTypeError(declaration.name, 'Component');\n      }\n      this.maybeStoreNgDef(NG_COMP_DEF, declaration);\n      compileComponent(declaration, metadata);\n    });\n    this.pendingComponents.clear();\n\n    this.pendingDirectives.forEach(declaration => {\n      const metadata = this.resolvers.directive.resolve(declaration);\n      if (metadata === null) {\n        throw invalidTypeError(declaration.name, 'Directive');\n      }\n      this.maybeStoreNgDef(NG_DIR_DEF, declaration);\n      compileDirective(declaration, metadata);\n    });\n    this.pendingDirectives.clear();\n\n    this.pendingPipes.forEach(declaration => {\n      const metadata = this.resolvers.pipe.resolve(declaration);\n      if (metadata === null) {\n        throw invalidTypeError(declaration.name, 'Pipe');\n      }\n      this.maybeStoreNgDef(NG_PIPE_DEF, declaration);\n      compilePipe(declaration, metadata);\n    });\n    this.pendingPipes.clear();\n\n    return needsAsyncResources;\n  }\n\n  private applyTransitiveScopes(): void {\n    if (this.overriddenModules.size > 0) {\n      // Module overrides (via `TestBed.overrideModule`) might affect scopes that were previously\n      // calculated and stored in `transitiveCompileScopes`. If module overrides are present,\n      // collect all affected modules and reset scopes to force their re-calculatation.\n      const testingModuleDef = (this.testModuleType as any)[NG_MOD_DEF];\n      const affectedModules = this.collectModulesAffectedByOverrides(testingModuleDef.imports);\n      if (affectedModules.size > 0) {\n        affectedModules.forEach(moduleType => {\n          this.storeFieldOfDefOnType(moduleType as any, NG_MOD_DEF, 'transitiveCompileScopes');\n          (moduleType as any)[NG_MOD_DEF].transitiveCompileScopes = null;\n        });\n      }\n    }\n\n    const moduleToScope = new Map<Type<any>|TestingModuleOverride, NgModuleTransitiveScopes>();\n    const getScopeOfModule =\n        (moduleType: Type<any>|TestingModuleOverride): NgModuleTransitiveScopes => {\n          if (!moduleToScope.has(moduleType)) {\n            const isTestingModule = isTestingModuleOverride(moduleType);\n            const realType = isTestingModule ? this.testModuleType : moduleType as Type<any>;\n            moduleToScope.set(moduleType, transitiveScopesFor(realType));\n          }\n          return moduleToScope.get(moduleType)!;\n        };\n\n    this.componentToModuleScope.forEach((moduleType, componentType) => {\n      const moduleScope = getScopeOfModule(moduleType);\n      this.storeFieldOfDefOnType(componentType, NG_COMP_DEF, 'directiveDefs');\n      this.storeFieldOfDefOnType(componentType, NG_COMP_DEF, 'pipeDefs');\n      // `tView` that is stored on component def contains information about directives and pipes\n      // that are in the scope of this component. Patching component scope will cause `tView` to be\n      // changed. Store original `tView` before patching scope, so the `tView` (including scope\n      // information) is restored back to its previous/original state before running next test.\n      this.storeFieldOfDefOnType(componentType, NG_COMP_DEF, 'tView');\n      patchComponentDefWithScope((componentType as any).ɵcmp, moduleScope);\n    });\n\n    this.componentToModuleScope.clear();\n  }\n\n  private applyProviderOverrides(): void {\n    const maybeApplyOverrides = (field: string) => (type: Type<any>) => {\n      const resolver = field === NG_COMP_DEF ? this.resolvers.component : this.resolvers.directive;\n      const metadata = resolver.resolve(type)!;\n      if (this.hasProviderOverrides(metadata.providers)) {\n        this.patchDefWithProviderOverrides(type, field);\n      }\n    };\n    this.seenComponents.forEach(maybeApplyOverrides(NG_COMP_DEF));\n    this.seenDirectives.forEach(maybeApplyOverrides(NG_DIR_DEF));\n\n    this.seenComponents.clear();\n    this.seenDirectives.clear();\n  }\n\n  private applyProviderOverridesToModule(moduleType: Type<any>): void {\n    if (this.moduleProvidersOverridden.has(moduleType)) {\n      return;\n    }\n    this.moduleProvidersOverridden.add(moduleType);\n\n    const injectorDef: any = (moduleType as any)[NG_INJ_DEF];\n    if (this.providerOverridesByToken.size > 0) {\n      const providers = [\n        ...injectorDef.providers,\n        ...(this.providerOverridesByModule.get(moduleType as InjectorType<any>) || [])\n      ];\n      if (this.hasProviderOverrides(providers)) {\n        this.maybeStoreNgDef(NG_INJ_DEF, moduleType);\n\n        this.storeFieldOfDefOnType(moduleType, NG_INJ_DEF, 'providers');\n        injectorDef.providers = this.getOverriddenProviders(providers);\n      }\n\n      // Apply provider overrides to imported modules recursively\n      const moduleDef = (moduleType as any)[NG_MOD_DEF];\n      const imports = maybeUnwrapFn(moduleDef.imports);\n      for (const importedModule of imports) {\n        this.applyProviderOverridesToModule(importedModule);\n      }\n      // Also override the providers on any ModuleWithProviders imports since those don't appear in\n      // the moduleDef.\n      for (const importedModule of flatten(injectorDef.imports)) {\n        if (isModuleWithProviders(importedModule)) {\n          this.defCleanupOps.push({\n            object: importedModule,\n            fieldName: 'providers',\n            originalValue: importedModule.providers\n          });\n          importedModule.providers = this.getOverriddenProviders(importedModule.providers);\n        }\n      }\n    }\n  }\n\n  private patchComponentsWithExistingStyles(): void {\n    this.existingComponentStyles.forEach(\n        (styles, type) => (type as any)[NG_COMP_DEF].styles = styles);\n    this.existingComponentStyles.clear();\n  }\n\n  private queueTypeArray(arr: any[], moduleType: Type<any>|TestingModuleOverride): void {\n    for (const value of arr) {\n      if (Array.isArray(value)) {\n        this.queueTypeArray(value, moduleType);\n      } else {\n        this.queueType(value, moduleType);\n      }\n    }\n  }\n\n  private recompileNgModule(ngModule: Type<any>, metadata: NgModule): void {\n    // Cache the initial ngModuleDef as it will be overwritten.\n    this.maybeStoreNgDef(NG_MOD_DEF, ngModule);\n    this.maybeStoreNgDef(NG_INJ_DEF, ngModule);\n\n    compileNgModuleDefs(ngModule as NgModuleType<any>, metadata);\n  }\n\n  private queueType(type: Type<any>, moduleType: Type<any>|TestingModuleOverride): void {\n    const component = this.resolvers.component.resolve(type);\n    if (component) {\n      // Check whether a give Type has respective NG def (ɵcmp) and compile if def is\n      // missing. That might happen in case a class without any Angular decorators extends another\n      // class where Component/Directive/Pipe decorator is defined.\n      if (isComponentDefPendingResolution(type) || !type.hasOwnProperty(NG_COMP_DEF)) {\n        this.pendingComponents.add(type);\n      }\n      this.seenComponents.add(type);\n\n      // Keep track of the module which declares this component, so later the component's scope\n      // can be set correctly. If the component has already been recorded here, then one of several\n      // cases is true:\n      // * the module containing the component was imported multiple times (common).\n      // * the component is declared in multiple modules (which is an error).\n      // * the component was in 'declarations' of the testing module, and also in an imported module\n      //   in which case the module scope will be TestingModuleOverride.DECLARATION.\n      // * overrideTemplateUsingTestingModule was called for the component in which case the module\n      //   scope will be TestingModuleOverride.OVERRIDE_TEMPLATE.\n      //\n      // If the component was previously in the testing module's 'declarations' (meaning the\n      // current value is TestingModuleOverride.DECLARATION), then `moduleType` is the component's\n      // real module, which was imported. This pattern is understood to mean that the component\n      // should use its original scope, but that the testing module should also contain the\n      // component in its scope.\n      if (!this.componentToModuleScope.has(type) ||\n          this.componentToModuleScope.get(type) === TestingModuleOverride.DECLARATION) {\n        this.componentToModuleScope.set(type, moduleType);\n      }\n      return;\n    }\n\n    const directive = this.resolvers.directive.resolve(type);\n    if (directive) {\n      if (!type.hasOwnProperty(NG_DIR_DEF)) {\n        this.pendingDirectives.add(type);\n      }\n      this.seenDirectives.add(type);\n      return;\n    }\n\n    const pipe = this.resolvers.pipe.resolve(type);\n    if (pipe && !type.hasOwnProperty(NG_PIPE_DEF)) {\n      this.pendingPipes.add(type);\n      return;\n    }\n  }\n\n  private queueTypesFromModulesArray(arr: any[]): void {\n    // Because we may encounter the same NgModule while processing the imports and exports of an\n    // NgModule tree, we cache them in this set so we can skip ones that have already been seen\n    // encountered. In some test setups, this caching resulted in 10X runtime improvement.\n    const processedNgModuleDefs = new Set();\n    const queueTypesFromModulesArrayRecur = (arr: any[]): void => {\n      for (const value of arr) {\n        if (Array.isArray(value)) {\n          queueTypesFromModulesArrayRecur(value);\n        } else if (hasNgModuleDef(value)) {\n          const def = value.ɵmod;\n          if (processedNgModuleDefs.has(def)) {\n            continue;\n          }\n          processedNgModuleDefs.add(def);\n          // Look through declarations, imports, and exports, and queue\n          // everything found there.\n          this.queueTypeArray(maybeUnwrapFn(def.declarations), value);\n          queueTypesFromModulesArrayRecur(maybeUnwrapFn(def.imports));\n          queueTypesFromModulesArrayRecur(maybeUnwrapFn(def.exports));\n        }\n      }\n    };\n    queueTypesFromModulesArrayRecur(arr);\n  }\n\n  // When module overrides (via `TestBed.overrideModule`) are present, it might affect all modules\n  // that import (even transitively) an overridden one. For all affected modules we need to\n  // recalculate their scopes for a given test run and restore original scopes at the end. The goal\n  // of this function is to collect all affected modules in a set for further processing. Example:\n  // if we have the following module hierarchy: A -> B -> C (where `->` means `imports`) and module\n  // `C` is overridden, we consider `A` and `B` as affected, since their scopes might become\n  // invalidated with the override.\n  private collectModulesAffectedByOverrides(arr: any[]): Set<NgModuleType<any>> {\n    const seenModules = new Set<NgModuleType<any>>();\n    const affectedModules = new Set<NgModuleType<any>>();\n    const calcAffectedModulesRecur = (arr: any[], path: NgModuleType<any>[]): void => {\n      for (const value of arr) {\n        if (Array.isArray(value)) {\n          // If the value is an array, just flatten it (by invoking this function recursively),\n          // keeping \"path\" the same.\n          calcAffectedModulesRecur(value, path);\n        } else if (hasNgModuleDef(value)) {\n          if (seenModules.has(value)) {\n            // If we've seen this module before and it's included into \"affected modules\" list, mark\n            // the whole path that leads to that module as affected, but do not descend into its\n            // imports, since we already examined them before.\n            if (affectedModules.has(value)) {\n              path.forEach(item => affectedModules.add(item));\n            }\n            continue;\n          }\n          seenModules.add(value);\n          if (this.overriddenModules.has(value)) {\n            path.forEach(item => affectedModules.add(item));\n          }\n          // Examine module imports recursively to look for overridden modules.\n          const moduleDef = (value as any)[NG_MOD_DEF];\n          calcAffectedModulesRecur(maybeUnwrapFn(moduleDef.imports), path.concat(value));\n        }\n      }\n    };\n    calcAffectedModulesRecur(arr, []);\n    return affectedModules;\n  }\n\n  private maybeStoreNgDef(prop: string, type: Type<any>) {\n    if (!this.initialNgDefs.has(type)) {\n      const currentDef = Object.getOwnPropertyDescriptor(type, prop);\n      this.initialNgDefs.set(type, [prop, currentDef]);\n    }\n  }\n\n  private storeFieldOfDefOnType(type: Type<any>, defField: string, fieldName: string): void {\n    const def: any = (type as any)[defField];\n    const originalValue: any = def[fieldName];\n    this.defCleanupOps.push({object: def, fieldName, originalValue});\n  }\n\n  /**\n   * Clears current components resolution queue, but stores the state of the queue, so we can\n   * restore it later. Clearing the queue is required before we try to compile components (via\n   * `TestBed.compileComponents`), so that component defs are in sync with the resolution queue.\n   */\n  private clearComponentResolutionQueue() {\n    if (this.originalComponentResolutionQueue === null) {\n      this.originalComponentResolutionQueue = new Map();\n    }\n    clearResolutionOfComponentResourcesQueue().forEach(\n        (value, key) => this.originalComponentResolutionQueue!.set(key, value));\n  }\n\n  /*\n   * Restores component resolution queue to the previously saved state. This operation is performed\n   * as a part of restoring the state after completion of the current set of tests (that might\n   * potentially mutate the state).\n   */\n  private restoreComponentResolutionQueue() {\n    if (this.originalComponentResolutionQueue !== null) {\n      restoreComponentResolutionQueue(this.originalComponentResolutionQueue);\n      this.originalComponentResolutionQueue = null;\n    }\n  }\n\n  restoreOriginalState(): void {\n    // Process cleanup ops in reverse order so the field's original value is restored correctly (in\n    // case there were multiple overrides for the same field).\n    forEachRight(this.defCleanupOps, (op: CleanupOperation) => {\n      op.object[op.fieldName] = op.originalValue;\n    });\n    // Restore initial component/directive/pipe defs\n    this.initialNgDefs.forEach((value: [string, PropertyDescriptor|undefined], type: Type<any>) => {\n      const [prop, descriptor] = value;\n      if (!descriptor) {\n        // Delete operations are generally undesirable since they have performance implications\n        // on objects they were applied to. In this particular case, situations where this code\n        // is invoked should be quite rare to cause any noticeable impact, since it's applied\n        // only to some test cases (for example when class with no annotations extends some\n        // @Component) when we need to clear 'ɵcmp' field on a given class to restore\n        // its original state (before applying overrides and running tests).\n        delete (type as any)[prop];\n      } else {\n        Object.defineProperty(type, prop, descriptor);\n      }\n    });\n    this.initialNgDefs.clear();\n    this.moduleProvidersOverridden.clear();\n    this.restoreComponentResolutionQueue();\n    // Restore the locale ID to the default value, this shouldn't be necessary but we never know\n    setLocaleId(DEFAULT_LOCALE_ID);\n  }\n\n  private compileTestModule(): void {\n    class RootScopeModule {}\n    compileNgModuleDefs(RootScopeModule as NgModuleType<any>, {\n      providers: [...this.rootProviderOverrides],\n    });\n\n    const ngZone = new NgZone({enableLongStackTrace: true});\n    const providers: Provider[] = [\n      {provide: NgZone, useValue: ngZone},\n      {provide: Compiler, useFactory: () => new R3TestCompiler(this)},\n      ...this.providers,\n      ...this.providerOverrides,\n    ];\n    const imports = [RootScopeModule, this.additionalModuleTypes, this.imports || []];\n\n    // clang-format off\n    compileNgModuleDefs(this.testModuleType, {\n      declarations: this.declarations,\n      imports,\n      schemas: this.schemas,\n      providers,\n    }, /* allowDuplicateDeclarationsInRoot */ true);\n    // clang-format on\n\n    this.applyProviderOverridesToModule(this.testModuleType);\n  }\n\n  get injector(): Injector {\n    if (this._injector !== null) {\n      return this._injector;\n    }\n\n    const providers: Provider[] = [];\n    const compilerOptions = this.platform.injector.get(COMPILER_OPTIONS);\n    compilerOptions.forEach(opts => {\n      if (opts.providers) {\n        providers.push(opts.providers);\n      }\n    });\n    if (this.compilerProviders !== null) {\n      providers.push(...this.compilerProviders);\n    }\n\n    // TODO(ocombe): make this work with an Injector directly instead of creating a module for it\n    class CompilerModule {}\n    compileNgModuleDefs(CompilerModule as NgModuleType<any>, {providers});\n\n    const CompilerModuleFactory = new R3NgModuleFactory(CompilerModule);\n    this._injector = CompilerModuleFactory.create(this.platform.injector).injector;\n    return this._injector;\n  }\n\n  // get overrides for a specific provider (if any)\n  private getSingleProviderOverrides(provider: Provider): Provider|null {\n    const token = getProviderToken(provider);\n    return this.providerOverridesByToken.get(token) || null;\n  }\n\n  private getProviderOverrides(providers?: Provider[]): Provider[] {\n    if (!providers || !providers.length || this.providerOverridesByToken.size === 0) return [];\n    // There are two flattening operations here. The inner flatten() operates on the metadata's\n    // providers and applies a mapping function which retrieves overrides for each incoming\n    // provider. The outer flatten() then flattens the produced overrides array. If this is not\n    // done, the array can contain other empty arrays (e.g. `[[], []]`) which leak into the\n    // providers array and contaminate any error messages that might be generated.\n    return flatten(flatten(\n        providers, (provider: Provider) => this.getSingleProviderOverrides(provider) || []));\n  }\n\n  private getOverriddenProviders(providers?: Provider[]): Provider[] {\n    if (!providers || !providers.length || this.providerOverridesByToken.size === 0) return [];\n\n    const flattenedProviders = flatten<Provider[]>(providers);\n    const overrides = this.getProviderOverrides(flattenedProviders);\n    const overriddenProviders = [...flattenedProviders, ...overrides];\n    const final: Provider[] = [];\n    const seenOverriddenProviders = new Set<Provider>();\n\n    // We iterate through the list of providers in reverse order to make sure provider overrides\n    // take precedence over the values defined in provider list. We also filter out all providers\n    // that have overrides, keeping overridden values only. This is needed, since presence of a\n    // provider with `ngOnDestroy` hook will cause this hook to be registered and invoked later.\n    forEachRight(overriddenProviders, (provider: any) => {\n      const token: any = getProviderToken(provider);\n      if (this.providerOverridesByToken.has(token)) {\n        if (!seenOverriddenProviders.has(token)) {\n          seenOverriddenProviders.add(token);\n          // Treat all overridden providers as `{multi: false}` (even if it's a multi-provider) to\n          // make sure that provided override takes highest precedence and is not combined with\n          // other instances of the same multi provider.\n          final.unshift({...provider, multi: false});\n        }\n      } else {\n        final.unshift(provider);\n      }\n    });\n    return final;\n  }\n\n  private hasProviderOverrides(providers?: Provider[]): boolean {\n    return this.getProviderOverrides(providers).length > 0;\n  }\n\n  private patchDefWithProviderOverrides(declaration: Type<any>, field: string): void {\n    const def = (declaration as any)[field];\n    if (def && def.providersResolver) {\n      this.maybeStoreNgDef(field, declaration);\n\n      const resolver = def.providersResolver;\n      const processProvidersFn = (providers: Provider[]) => this.getOverriddenProviders(providers);\n      this.storeFieldOfDefOnType(declaration, field, 'providersResolver');\n      def.providersResolver = (ngDef: DirectiveDef<any>) => resolver(ngDef, processProvidersFn);\n    }\n  }\n}\n\nfunction initResolvers(): Resolvers {\n  return {\n    module: new NgModuleResolver(),\n    component: new ComponentResolver(),\n    directive: new DirectiveResolver(),\n    pipe: new PipeResolver()\n  };\n}\n\nfunction hasNgModuleDef<T>(value: Type<T>): value is NgModuleType<T> {\n  return value.hasOwnProperty('ɵmod');\n}\n\nfunction maybeUnwrapFn<T>(maybeFn: (() => T)|T): T {\n  return maybeFn instanceof Function ? maybeFn() : maybeFn;\n}\n\nfunction flatten<T>(values: any[], mapFn?: (value: T) => any): T[] {\n  const out: T[] = [];\n  values.forEach(value => {\n    if (Array.isArray(value)) {\n      out.push(...flatten<T>(value, mapFn));\n    } else {\n      out.push(mapFn ? mapFn(value) : value);\n    }\n  });\n  return out;\n}\n\nfunction getProviderField(provider: Provider, field: string) {\n  return provider && typeof provider === 'object' && (provider as any)[field];\n}\n\nfunction getProviderToken(provider: Provider) {\n  return getProviderField(provider, 'provide') || provider;\n}\n\nfunction isModuleWithProviders(value: any): value is ModuleWithProviders<any> {\n  return value.hasOwnProperty('ngModule');\n}\n\nfunction forEachRight<T>(values: T[], fn: (value: T, idx: number) => void): void {\n  for (let idx = values.length - 1; idx >= 0; idx--) {\n    fn(values[idx], idx);\n  }\n}\n\nfunction invalidTypeError(name: string, expectedType: string): Error {\n  return new Error(`${name} class doesn't have @${expectedType} decorator or is missing metadata.`);\n}\n\nclass R3TestCompiler implements Compiler {\n  constructor(private testBed: R3TestBedCompiler) {}\n\n  compileModuleSync<T>(moduleType: Type<T>): NgModuleFactory<T> {\n    this.testBed._compileNgModuleSync(moduleType);\n    return new R3NgModuleFactory(moduleType);\n  }\n\n  async compileModuleAsync<T>(moduleType: Type<T>): Promise<NgModuleFactory<T>> {\n    await this.testBed._compileNgModuleAsync(moduleType);\n    return new R3NgModuleFactory(moduleType);\n  }\n\n  compileModuleAndAllComponentsSync<T>(moduleType: Type<T>): ModuleWithComponentFactories<T> {\n    const ngModuleFactory = this.compileModuleSync(moduleType);\n    const componentFactories = this.testBed._getComponentFactories(moduleType as NgModuleType<T>);\n    return new ModuleWithComponentFactories(ngModuleFactory, componentFactories);\n  }\n\n  async compileModuleAndAllComponentsAsync<T>(moduleType: Type<T>):\n      Promise<ModuleWithComponentFactories<T>> {\n    const ngModuleFactory = await this.compileModuleAsync(moduleType);\n    const componentFactories = this.testBed._getComponentFactories(moduleType as NgModuleType<T>);\n    return new ModuleWithComponentFactories(ngModuleFactory, componentFactories);\n  }\n\n  clearCache(): void {}\n\n  clearCacheFor(type: Type<any>): void {}\n\n  getModuleId(moduleType: Type<any>): string|undefined {\n    const meta = this.testBed._getModuleResolver().resolve(moduleType);\n    return meta && meta.id || undefined;\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {AbstractType, Component, Directive, InjectFlags, InjectionToken, NgModule, Pipe, PlatformRef, SchemaMetadata, Type} from '@angular/core';\n\nimport {ComponentFixture} from './component_fixture';\nimport {MetadataOverride} from './metadata_override';\nimport {TestBed} from './test_bed';\n\n/**\n * An abstract class for inserting the root test component element in a platform independent way.\n *\n * @publicApi\n */\nexport class TestComponentRenderer {\n  insertRootElement(rootElementId: string) {}\n}\n\n/**\n * @publicApi\n */\nexport const ComponentFixtureAutoDetect =\n    new InjectionToken<boolean[]>('ComponentFixtureAutoDetect');\n\n/**\n * @publicApi\n */\nexport const ComponentFixtureNoNgZone = new InjectionToken<boolean[]>('ComponentFixtureNoNgZone');\n\n/**\n * @publicApi\n */\nexport type TestModuleMetadata = {\n  providers?: any[],\n  declarations?: any[],\n  imports?: any[],\n  schemas?: Array<SchemaMetadata|any[]>,\n  aotSummaries?: () => any[],\n};\n\n/**\n * Static methods implemented by the `TestBedViewEngine` and `TestBedRender3`\n *\n * @publicApi\n */\nexport interface TestBedStatic {\n  new(...args: any[]): TestBed;\n\n  initTestEnvironment(\n      ngModule: Type<any>|Type<any>[], platform: PlatformRef, aotSummaries?: () => any[]): TestBed;\n\n  /**\n   * Reset the providers for the test injector.\n   */\n  resetTestEnvironment(): void;\n\n  resetTestingModule(): TestBedStatic;\n\n  /**\n   * Allows overriding default compiler providers and settings\n   * which are defined in test_injector.js\n   */\n  configureCompiler(config: {providers?: any[]; useJit?: boolean;}): TestBedStatic;\n\n  /**\n   * Allows overriding default providers, directives, pipes, modules of the test injector,\n   * which are defined in test_injector.js\n   */\n  configureTestingModule(moduleDef: TestModuleMetadata): TestBedStatic;\n\n  /**\n   * Compile components with a `templateUrl` for the test's NgModule.\n   * It is necessary to call this function\n   * as fetching urls is asynchronous.\n   */\n  compileComponents(): Promise<any>;\n\n  overrideModule(ngModule: Type<any>, override: MetadataOverride<NgModule>): TestBedStatic;\n\n  overrideComponent(component: Type<any>, override: MetadataOverride<Component>): TestBedStatic;\n\n  overrideDirective(directive: Type<any>, override: MetadataOverride<Directive>): TestBedStatic;\n\n  overridePipe(pipe: Type<any>, override: MetadataOverride<Pipe>): TestBedStatic;\n\n  overrideTemplate(component: Type<any>, template: string): TestBedStatic;\n\n  /**\n   * Overrides the template of the given component, compiling the template\n   * in the context of the TestingModule.\n   *\n   * Note: This works for JIT and AOTed components as well.\n   */\n  overrideTemplateUsingTestingModule(component: Type<any>, template: string): TestBedStatic;\n\n  /**\n   * Overwrites all providers for the given token with the given provider definition.\n   *\n   * Note: This works for JIT and AOTed components as well.\n   */\n  overrideProvider(token: any, provider: {\n    useFactory: Function,\n    deps: any[],\n  }): TestBedStatic;\n  overrideProvider(token: any, provider: {useValue: any;}): TestBedStatic;\n  overrideProvider(token: any, provider: {\n    useFactory?: Function,\n    useValue?: any,\n    deps?: any[],\n  }): TestBedStatic;\n\n  inject<T>(\n      token: Type<T>|InjectionToken<T>|AbstractType<T>, notFoundValue?: T, flags?: InjectFlags): T;\n  inject<T>(\n      token: Type<T>|InjectionToken<T>|AbstractType<T>, notFoundValue: null, flags?: InjectFlags): T\n      |null;\n\n  /** @deprecated from v9.0.0 use TestBed.inject */\n  get<T>(token: Type<T>|InjectionToken<T>, notFoundValue?: T, flags?: InjectFlags): any;\n  /** @deprecated from v9.0.0 use TestBed.inject */\n  get(token: any, notFoundValue?: any): any;\n\n  createComponent<T>(component: Type<T>): ComponentFixture<T>;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n// The formatter and CI disagree on how this import statement should be formatted. Both try to keep\n// it on one line, too, which has gotten very hard to read & manage. So disable the formatter for\n// this statement only.\n\n/* clang-format off */\nimport {\n  AbstractType,\n  Component,\n  Directive,\n  InjectFlags,\n  InjectionToken,\n  Injector,\n  NgModule,\n  NgZone,\n  Pipe,\n  PlatformRef,\n  Type,\n  ɵflushModuleScopingQueueAsMuchAsPossible as flushModuleScopingQueueAsMuchAsPossible,\n  ɵRender3ComponentFactory as ComponentFactory,\n  ɵRender3NgModuleRef as NgModuleRef,\n  ɵresetCompiledComponents as resetCompiledComponents,\n  ɵstringify as stringify,\n} from '@angular/core';\n\n/* clang-format on */\n\nimport {ComponentFixture} from './component_fixture';\nimport {MetadataOverride} from './metadata_override';\nimport {R3TestBedCompiler} from './r3_test_bed_compiler';\nimport {TestBed} from './test_bed';\nimport {ComponentFixtureAutoDetect, ComponentFixtureNoNgZone, TestBedStatic, TestComponentRenderer, TestModuleMetadata} from './test_bed_common';\n\nlet _nextRootElementId = 0;\n\n\n/**\n * @description\n * Configures and initializes environment for unit testing and provides methods for\n * creating components and services in unit tests.\n *\n * TestBed is the primary api for writing unit tests for Angular applications and libraries.\n *\n * Note: Use `TestBed` in tests. It will be set to either `TestBedViewEngine` or `TestBedRender3`\n * according to the compiler used.\n */\nexport class TestBedRender3 implements TestBed {\n  /**\n   * Initialize the environment for testing with a compiler factory, a PlatformRef, and an\n   * angular module. These are common to every test in the suite.\n   *\n   * This may only be called once, to set up the common providers for the current test\n   * suite on the current platform. If you absolutely need to change the providers,\n   * first use `resetTestEnvironment`.\n   *\n   * Test modules and platforms for individual platforms are available from\n   * '@angular/<platform_name>/testing'.\n   *\n   * @publicApi\n   */\n  static initTestEnvironment(\n      ngModule: Type<any>|Type<any>[], platform: PlatformRef, aotSummaries?: () => any[]): TestBed {\n    const testBed = _getTestBedRender3();\n    testBed.initTestEnvironment(ngModule, platform, aotSummaries);\n    return testBed;\n  }\n\n  /**\n   * Reset the providers for the test injector.\n   *\n   * @publicApi\n   */\n  static resetTestEnvironment(): void {\n    _getTestBedRender3().resetTestEnvironment();\n  }\n\n  static configureCompiler(config: {providers?: any[]; useJit?: boolean;}): TestBedStatic {\n    _getTestBedRender3().configureCompiler(config);\n    return TestBedRender3 as any as TestBedStatic;\n  }\n\n  /**\n   * Allows overriding default providers, directives, pipes, modules of the test injector,\n   * which are defined in test_injector.js\n   */\n  static configureTestingModule(moduleDef: TestModuleMetadata): TestBedStatic {\n    _getTestBedRender3().configureTestingModule(moduleDef);\n    return TestBedRender3 as any as TestBedStatic;\n  }\n\n  /**\n   * Compile components with a `templateUrl` for the test's NgModule.\n   * It is necessary to call this function\n   * as fetching urls is asynchronous.\n   */\n  static compileComponents(): Promise<any> {\n    return _getTestBedRender3().compileComponents();\n  }\n\n  static overrideModule(ngModule: Type<any>, override: MetadataOverride<NgModule>): TestBedStatic {\n    _getTestBedRender3().overrideModule(ngModule, override);\n    return TestBedRender3 as any as TestBedStatic;\n  }\n\n  static overrideComponent(component: Type<any>, override: MetadataOverride<Component>):\n      TestBedStatic {\n    _getTestBedRender3().overrideComponent(component, override);\n    return TestBedRender3 as any as TestBedStatic;\n  }\n\n  static overrideDirective(directive: Type<any>, override: MetadataOverride<Directive>):\n      TestBedStatic {\n    _getTestBedRender3().overrideDirective(directive, override);\n    return TestBedRender3 as any as TestBedStatic;\n  }\n\n  static overridePipe(pipe: Type<any>, override: MetadataOverride<Pipe>): TestBedStatic {\n    _getTestBedRender3().overridePipe(pipe, override);\n    return TestBedRender3 as any as TestBedStatic;\n  }\n\n  static overrideTemplate(component: Type<any>, template: string): TestBedStatic {\n    _getTestBedRender3().overrideComponent(component, {set: {template, templateUrl: null!}});\n    return TestBedRender3 as any as TestBedStatic;\n  }\n\n  /**\n   * Overrides the template of the given component, compiling the template\n   * in the context of the TestingModule.\n   *\n   * Note: This works for JIT and AOTed components as well.\n   */\n  static overrideTemplateUsingTestingModule(component: Type<any>, template: string): TestBedStatic {\n    _getTestBedRender3().overrideTemplateUsingTestingModule(component, template);\n    return TestBedRender3 as any as TestBedStatic;\n  }\n\n  static overrideProvider(token: any, provider: {\n    useFactory: Function,\n    deps: any[],\n  }): TestBedStatic;\n  static overrideProvider(token: any, provider: {useValue: any;}): TestBedStatic;\n  static overrideProvider(token: any, provider: {\n    useFactory?: Function,\n    useValue?: any,\n    deps?: any[],\n  }): TestBedStatic {\n    _getTestBedRender3().overrideProvider(token, provider);\n    return TestBedRender3 as any as TestBedStatic;\n  }\n\n  static inject<T>(\n      token: Type<T>|InjectionToken<T>|AbstractType<T>, notFoundValue?: T, flags?: InjectFlags): T;\n  static inject<T>(\n      token: Type<T>|InjectionToken<T>|AbstractType<T>, notFoundValue: null, flags?: InjectFlags): T\n      |null;\n  static inject<T>(\n      token: Type<T>|InjectionToken<T>|AbstractType<T>, notFoundValue?: T|null,\n      flags?: InjectFlags): T|null {\n    return _getTestBedRender3().inject(token, notFoundValue, flags);\n  }\n\n  /** @deprecated from v9.0.0 use TestBed.inject */\n  static get<T>(token: Type<T>|InjectionToken<T>, notFoundValue?: T, flags?: InjectFlags): any;\n  /** @deprecated from v9.0.0 use TestBed.inject */\n  static get(token: any, notFoundValue?: any): any;\n  /** @deprecated from v9.0.0 use TestBed.inject */\n  static get(\n      token: any, notFoundValue: any = Injector.THROW_IF_NOT_FOUND,\n      flags: InjectFlags = InjectFlags.Default): any {\n    return _getTestBedRender3().inject(token, notFoundValue, flags);\n  }\n\n  static createComponent<T>(component: Type<T>): ComponentFixture<T> {\n    return _getTestBedRender3().createComponent(component);\n  }\n\n  static resetTestingModule(): TestBedStatic {\n    _getTestBedRender3().resetTestingModule();\n    return TestBedRender3 as any as TestBedStatic;\n  }\n\n  // Properties\n\n  platform: PlatformRef = null!;\n  ngModule: Type<any>|Type<any>[] = null!;\n\n  private _compiler: R3TestBedCompiler|null = null;\n  private _testModuleRef: NgModuleRef<any>|null = null;\n\n  private _activeFixtures: ComponentFixture<any>[] = [];\n  private _globalCompilationChecked = false;\n\n  /**\n   * Initialize the environment for testing with a compiler factory, a PlatformRef, and an\n   * angular module. These are common to every test in the suite.\n   *\n   * This may only be called once, to set up the common providers for the current test\n   * suite on the current platform. If you absolutely need to change the providers,\n   * first use `resetTestEnvironment`.\n   *\n   * Test modules and platforms for individual platforms are available from\n   * '@angular/<platform_name>/testing'.\n   *\n   * @publicApi\n   */\n  initTestEnvironment(\n      ngModule: Type<any>|Type<any>[], platform: PlatformRef, aotSummaries?: () => any[]): void {\n    if (this.platform || this.ngModule) {\n      throw new Error('Cannot set base providers because it has already been called');\n    }\n    this.platform = platform;\n    this.ngModule = ngModule;\n    this._compiler = new R3TestBedCompiler(this.platform, this.ngModule);\n  }\n\n  /**\n   * Reset the providers for the test injector.\n   *\n   * @publicApi\n   */\n  resetTestEnvironment(): void {\n    this.resetTestingModule();\n    this._compiler = null;\n    this.platform = null!;\n    this.ngModule = null!;\n  }\n\n  resetTestingModule(): void {\n    this.checkGlobalCompilationFinished();\n    resetCompiledComponents();\n    if (this._compiler !== null) {\n      this.compiler.restoreOriginalState();\n    }\n    this._compiler = new R3TestBedCompiler(this.platform, this.ngModule);\n    this._testModuleRef = null;\n    this.destroyActiveFixtures();\n  }\n\n  configureCompiler(config: {providers?: any[]; useJit?: boolean;}): void {\n    if (config.useJit != null) {\n      throw new Error('the Render3 compiler JiT mode is not configurable !');\n    }\n\n    if (config.providers !== undefined) {\n      this.compiler.setCompilerProviders(config.providers);\n    }\n  }\n\n  configureTestingModule(moduleDef: TestModuleMetadata): void {\n    this.assertNotInstantiated('R3TestBed.configureTestingModule', 'configure the test module');\n    this.compiler.configureTestingModule(moduleDef);\n  }\n\n  compileComponents(): Promise<any> {\n    return this.compiler.compileComponents();\n  }\n\n  inject<T>(\n      token: Type<T>|InjectionToken<T>|AbstractType<T>, notFoundValue?: T, flags?: InjectFlags): T;\n  inject<T>(\n      token: Type<T>|InjectionToken<T>|AbstractType<T>, notFoundValue: null, flags?: InjectFlags): T\n      |null;\n  inject<T>(\n      token: Type<T>|InjectionToken<T>|AbstractType<T>, notFoundValue?: T|null,\n      flags?: InjectFlags): T|null {\n    if (token as unknown === TestBedRender3) {\n      return this as any;\n    }\n    const UNDEFINED = {};\n    const result = this.testModuleRef.injector.get(token, UNDEFINED, flags);\n    return result === UNDEFINED ? this.compiler.injector.get(token, notFoundValue, flags) as any :\n                                  result;\n  }\n\n  /** @deprecated from v9.0.0 use TestBed.inject */\n  get<T>(token: Type<T>|InjectionToken<T>, notFoundValue?: T, flags?: InjectFlags): any;\n  /** @deprecated from v9.0.0 use TestBed.inject */\n  get(token: any, notFoundValue?: any): any;\n  /** @deprecated from v9.0.0 use TestBed.inject */\n  get(token: any, notFoundValue: any = Injector.THROW_IF_NOT_FOUND,\n      flags: InjectFlags = InjectFlags.Default): any {\n    return this.inject(token, notFoundValue, flags);\n  }\n\n  execute(tokens: any[], fn: Function, context?: any): any {\n    const params = tokens.map(t => this.inject(t));\n    return fn.apply(context, params);\n  }\n\n  overrideModule(ngModule: Type<any>, override: MetadataOverride<NgModule>): void {\n    this.assertNotInstantiated('overrideModule', 'override module metadata');\n    this.compiler.overrideModule(ngModule, override);\n  }\n\n  overrideComponent(component: Type<any>, override: MetadataOverride<Component>): void {\n    this.assertNotInstantiated('overrideComponent', 'override component metadata');\n    this.compiler.overrideComponent(component, override);\n  }\n\n  overrideTemplateUsingTestingModule(component: Type<any>, template: string): void {\n    this.assertNotInstantiated(\n        'R3TestBed.overrideTemplateUsingTestingModule',\n        'Cannot override template when the test module has already been instantiated');\n    this.compiler.overrideTemplateUsingTestingModule(component, template);\n  }\n\n  overrideDirective(directive: Type<any>, override: MetadataOverride<Directive>): void {\n    this.assertNotInstantiated('overrideDirective', 'override directive metadata');\n    this.compiler.overrideDirective(directive, override);\n  }\n\n  overridePipe(pipe: Type<any>, override: MetadataOverride<Pipe>): void {\n    this.assertNotInstantiated('overridePipe', 'override pipe metadata');\n    this.compiler.overridePipe(pipe, override);\n  }\n\n  /**\n   * Overwrites all providers for the given token with the given provider definition.\n   */\n  overrideProvider(token: any, provider: {useFactory?: Function, useValue?: any, deps?: any[]}):\n      void {\n    this.compiler.overrideProvider(token, provider);\n  }\n\n  createComponent<T>(type: Type<T>): ComponentFixture<T> {\n    const testComponentRenderer = this.inject(TestComponentRenderer);\n    const rootElId = `root${_nextRootElementId++}`;\n    testComponentRenderer.insertRootElement(rootElId);\n\n    const componentDef = (type as any).ɵcmp;\n\n    if (!componentDef) {\n      throw new Error(\n          `It looks like '${stringify(type)}' has not been IVY compiled - it has no 'ɵcmp' field`);\n    }\n\n    // TODO: Don't cast as `InjectionToken<boolean>`, proper type is boolean[]\n    const noNgZone = this.inject(ComponentFixtureNoNgZone as InjectionToken<boolean>, false);\n    // TODO: Don't cast as `InjectionToken<boolean>`, proper type is boolean[]\n    const autoDetect: boolean =\n        this.inject(ComponentFixtureAutoDetect as InjectionToken<boolean>, false);\n    const ngZone: NgZone|null = noNgZone ? null : this.inject(NgZone, null);\n    const componentFactory = new ComponentFactory(componentDef);\n    const initComponent = () => {\n      const componentRef =\n          componentFactory.create(Injector.NULL, [], `#${rootElId}`, this.testModuleRef);\n      return new ComponentFixture<any>(componentRef, ngZone, autoDetect);\n    };\n    const fixture = ngZone ? ngZone.run(initComponent) : initComponent();\n    this._activeFixtures.push(fixture);\n    return fixture;\n  }\n\n  /**\n   * @internal strip this from published d.ts files due to\n   * https://github.com/microsoft/TypeScript/issues/36216\n   */\n  private get compiler(): R3TestBedCompiler {\n    if (this._compiler === null) {\n      throw new Error(`Need to call TestBed.initTestEnvironment() first`);\n    }\n    return this._compiler;\n  }\n\n  /**\n   * @internal strip this from published d.ts files due to\n   * https://github.com/microsoft/TypeScript/issues/36216\n   */\n  private get testModuleRef(): NgModuleRef<any> {\n    if (this._testModuleRef === null) {\n      this._testModuleRef = this.compiler.finalize();\n    }\n    return this._testModuleRef;\n  }\n\n  private assertNotInstantiated(methodName: string, methodDescription: string) {\n    if (this._testModuleRef !== null) {\n      throw new Error(\n          `Cannot ${methodDescription} when the test module has already been instantiated. ` +\n          `Make sure you are not using \\`inject\\` before \\`${methodName}\\`.`);\n    }\n  }\n\n  /**\n   * Check whether the module scoping queue should be flushed, and flush it if needed.\n   *\n   * When the TestBed is reset, it clears the JIT module compilation queue, cancelling any\n   * in-progress module compilation. This creates a potential hazard - the very first time the\n   * TestBed is initialized (or if it's reset without being initialized), there may be pending\n   * compilations of modules declared in global scope. These compilations should be finished.\n   *\n   * To ensure that globally declared modules have their components scoped properly, this function\n   * is called whenever TestBed is initialized or reset. The _first_ time that this happens, prior\n   * to any other operations, the scoping queue is flushed.\n   */\n  private checkGlobalCompilationFinished(): void {\n    // Checking _testNgModuleRef is null should not be necessary, but is left in as an additional\n    // guard that compilations queued in tests (after instantiation) are never flushed accidentally.\n    if (!this._globalCompilationChecked && this._testModuleRef === null) {\n      flushModuleScopingQueueAsMuchAsPossible();\n    }\n    this._globalCompilationChecked = true;\n  }\n\n  private destroyActiveFixtures(): void {\n    this._activeFixtures.forEach((fixture) => {\n      try {\n        fixture.destroy();\n      } catch (e) {\n        console.error('Error during cleanup of component', {\n          component: fixture.componentInstance,\n          stacktrace: e,\n        });\n      }\n    });\n    this._activeFixtures = [];\n  }\n}\n\nlet testBed: TestBedRender3;\n\nexport function _getTestBedRender3(): TestBedRender3 {\n  return testBed = testBed || new TestBedRender3();\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Compiler, CompilerOptions, Component, ComponentFactory, Directive, Injectable, Injector, NgModule, Pipe, Type} from '@angular/core';\n\nimport {MetadataOverride} from './metadata_override';\n\nfunction unimplemented(): any {\n  throw Error('unimplemented');\n}\n\n/**\n * Special interface to the compiler only used by testing\n *\n * @publicApi\n */\n@Injectable()\nexport class TestingCompiler extends Compiler {\n  get injector(): Injector {\n    throw unimplemented();\n  }\n  overrideModule(module: Type<any>, overrides: MetadataOverride<NgModule>): void {\n    throw unimplemented();\n  }\n  overrideDirective(directive: Type<any>, overrides: MetadataOverride<Directive>): void {\n    throw unimplemented();\n  }\n  overrideComponent(component: Type<any>, overrides: MetadataOverride<Component>): void {\n    throw unimplemented();\n  }\n  overridePipe(directive: Type<any>, overrides: MetadataOverride<Pipe>): void {\n    throw unimplemented();\n  }\n  /**\n   * Allows to pass the compile summary from AOT compilation to the JIT compiler,\n   * so that it can use the code generated by AOT.\n   */\n  loadAotSummaries(summaries: () => any[]) {\n    throw unimplemented();\n  }\n\n  /**\n   * Gets the component factory for the given component.\n   * This assumes that the component has been compiled before calling this call using\n   * `compileModuleAndAllComponents*`.\n   */\n  getComponentFactory<T>(component: Type<T>): ComponentFactory<T> {\n    throw unimplemented();\n  }\n\n  /**\n   * Returns the component type that is stored in the given error.\n   * This can be used for errors created by compileModule...\n   */\n  getComponentFromError(error: Error): Type<any>|null {\n    throw unimplemented();\n  }\n}\n\n/**\n * A factory for creating a Compiler\n *\n * @publicApi\n */\nexport abstract class TestingCompilerFactory {\n  abstract createTestingCompiler(options?: CompilerOptions[]): TestingCompiler;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {AbstractType, ApplicationInitStatus, CompilerOptions, Component, Directive, InjectFlags, InjectionToken, Injector, NgModule, NgModuleFactory, NgModuleRef, NgZone, Optional, Pipe, PlatformRef, Provider, SchemaMetadata, SkipSelf, StaticProvider, Type, ɵclearOverrides as clearOverrides, ɵDepFlags as DepFlags, ɵgetInjectableDef as getInjectableDef, ɵINJECTOR_SCOPE as INJECTOR_SCOPE, ɵivyEnabled as ivyEnabled, ɵNodeFlags as NodeFlags, ɵoverrideComponentView as overrideComponentView, ɵoverrideProvider as overrideProvider, ɵstringify as stringify, ɵɵInjectableDef} from '@angular/core';\n\nimport {AsyncTestCompleter} from './async_test_completer';\nimport {ComponentFixture} from './component_fixture';\nimport {MetadataOverride} from './metadata_override';\nimport {_getTestBedRender3, TestBedRender3} from './r3_test_bed';\nimport {ComponentFixtureAutoDetect, ComponentFixtureNoNgZone, TestBedStatic, TestComponentRenderer, TestModuleMetadata} from './test_bed_common';\nimport {TestingCompiler, TestingCompilerFactory} from './test_compiler';\n\n\nlet _nextRootElementId = 0;\n\n/**\n * @publicApi\n */\nexport interface TestBed {\n  platform: PlatformRef;\n\n  ngModule: Type<any>|Type<any>[];\n\n  /**\n   * Initialize the environment for testing with a compiler factory, a PlatformRef, and an\n   * angular module. These are common to every test in the suite.\n   *\n   * This may only be called once, to set up the common providers for the current test\n   * suite on the current platform. If you absolutely need to change the providers,\n   * first use `resetTestEnvironment`.\n   *\n   * Test modules and platforms for individual platforms are available from\n   * '@angular/<platform_name>/testing'.\n   */\n  initTestEnvironment(\n      ngModule: Type<any>|Type<any>[], platform: PlatformRef, aotSummaries?: () => any[]): void;\n\n  /**\n   * Reset the providers for the test injector.\n   */\n  resetTestEnvironment(): void;\n\n  resetTestingModule(): void;\n\n  configureCompiler(config: {providers?: any[], useJit?: boolean}): void;\n\n  configureTestingModule(moduleDef: TestModuleMetadata): void;\n\n  compileComponents(): Promise<any>;\n\n  inject<T>(\n      token: Type<T>|InjectionToken<T>|AbstractType<T>, notFoundValue?: T, flags?: InjectFlags): T;\n  inject<T>(\n      token: Type<T>|InjectionToken<T>|AbstractType<T>, notFoundValue: null, flags?: InjectFlags): T\n      |null;\n\n  /** @deprecated from v9.0.0 use TestBed.inject */\n  get<T>(token: Type<T>|InjectionToken<T>, notFoundValue?: T, flags?: InjectFlags): any;\n  /** @deprecated from v9.0.0 use TestBed.inject */\n  get(token: any, notFoundValue?: any): any;\n\n  execute(tokens: any[], fn: Function, context?: any): any;\n\n  overrideModule(ngModule: Type<any>, override: MetadataOverride<NgModule>): void;\n\n  overrideComponent(component: Type<any>, override: MetadataOverride<Component>): void;\n\n  overrideDirective(directive: Type<any>, override: MetadataOverride<Directive>): void;\n\n  overridePipe(pipe: Type<any>, override: MetadataOverride<Pipe>): void;\n\n  /**\n   * Overwrites all providers for the given token with the given provider definition.\n   */\n  overrideProvider(token: any, provider: {\n    useFactory: Function,\n    deps: any[],\n  }): void;\n  overrideProvider(token: any, provider: {useValue: any;}): void;\n  overrideProvider(token: any, provider: {useFactory?: Function, useValue?: any, deps?: any[]}):\n      void;\n\n  overrideTemplateUsingTestingModule(component: Type<any>, template: string): void;\n\n  createComponent<T>(component: Type<T>): ComponentFixture<T>;\n}\n\n/**\n * @description\n * Configures and initializes environment for unit testing and provides methods for\n * creating components and services in unit tests.\n *\n * `TestBed` is the primary api for writing unit tests for Angular applications and libraries.\n *\n * Note: Use `TestBed` in tests. It will be set to either `TestBedViewEngine` or `TestBedRender3`\n * according to the compiler used.\n */\nexport class TestBedViewEngine implements TestBed {\n  /**\n   * Initialize the environment for testing with a compiler factory, a PlatformRef, and an\n   * angular module. These are common to every test in the suite.\n   *\n   * This may only be called once, to set up the common providers for the current test\n   * suite on the current platform. If you absolutely need to change the providers,\n   * first use `resetTestEnvironment`.\n   *\n   * Test modules and platforms for individual platforms are available from\n   * '@angular/<platform_name>/testing'.\n   */\n  static initTestEnvironment(\n      ngModule: Type<any>|Type<any>[], platform: PlatformRef,\n      aotSummaries?: () => any[]): TestBedViewEngine {\n    const testBed = _getTestBedViewEngine();\n    testBed.initTestEnvironment(ngModule, platform, aotSummaries);\n    return testBed;\n  }\n\n  /**\n   * Reset the providers for the test injector.\n   */\n  static resetTestEnvironment(): void {\n    _getTestBedViewEngine().resetTestEnvironment();\n  }\n\n  static resetTestingModule(): TestBedStatic {\n    _getTestBedViewEngine().resetTestingModule();\n    return TestBedViewEngine as any as TestBedStatic;\n  }\n\n  /**\n   * Allows overriding default compiler providers and settings\n   * which are defined in test_injector.js\n   */\n  static configureCompiler(config: {providers?: any[]; useJit?: boolean;}): TestBedStatic {\n    _getTestBedViewEngine().configureCompiler(config);\n    return TestBedViewEngine as any as TestBedStatic;\n  }\n\n  /**\n   * Allows overriding default providers, directives, pipes, modules of the test injector,\n   * which are defined in test_injector.js\n   */\n  static configureTestingModule(moduleDef: TestModuleMetadata): TestBedStatic {\n    _getTestBedViewEngine().configureTestingModule(moduleDef);\n    return TestBedViewEngine as any as TestBedStatic;\n  }\n\n  /**\n   * Compile components with a `templateUrl` for the test's NgModule.\n   * It is necessary to call this function\n   * as fetching urls is asynchronous.\n   */\n  static compileComponents(): Promise<any> {\n    return getTestBed().compileComponents();\n  }\n\n  static overrideModule(ngModule: Type<any>, override: MetadataOverride<NgModule>): TestBedStatic {\n    _getTestBedViewEngine().overrideModule(ngModule, override);\n    return TestBedViewEngine as any as TestBedStatic;\n  }\n\n  static overrideComponent(component: Type<any>, override: MetadataOverride<Component>):\n      TestBedStatic {\n    _getTestBedViewEngine().overrideComponent(component, override);\n    return TestBedViewEngine as any as TestBedStatic;\n  }\n\n  static overrideDirective(directive: Type<any>, override: MetadataOverride<Directive>):\n      TestBedStatic {\n    _getTestBedViewEngine().overrideDirective(directive, override);\n    return TestBedViewEngine as any as TestBedStatic;\n  }\n\n  static overridePipe(pipe: Type<any>, override: MetadataOverride<Pipe>): TestBedStatic {\n    _getTestBedViewEngine().overridePipe(pipe, override);\n    return TestBedViewEngine as any as TestBedStatic;\n  }\n\n  static overrideTemplate(component: Type<any>, template: string): TestBedStatic {\n    _getTestBedViewEngine().overrideComponent(component, {set: {template, templateUrl: null!}});\n    return TestBedViewEngine as any as TestBedStatic;\n  }\n\n  /**\n   * Overrides the template of the given component, compiling the template\n   * in the context of the TestingModule.\n   *\n   * Note: This works for JIT and AOTed components as well.\n   */\n  static overrideTemplateUsingTestingModule(component: Type<any>, template: string): TestBedStatic {\n    _getTestBedViewEngine().overrideTemplateUsingTestingModule(component, template);\n    return TestBedViewEngine as any as TestBedStatic;\n  }\n\n  /**\n   * Overwrites all providers for the given token with the given provider definition.\n   *\n   * Note: This works for JIT and AOTed components as well.\n   */\n  static overrideProvider(token: any, provider: {\n    useFactory: Function,\n    deps: any[],\n  }): TestBedStatic;\n  static overrideProvider(token: any, provider: {useValue: any;}): TestBedStatic;\n  static overrideProvider(token: any, provider: {\n    useFactory?: Function,\n    useValue?: any,\n    deps?: any[],\n  }): TestBedStatic {\n    _getTestBedViewEngine().overrideProvider(token, provider as any);\n    return TestBedViewEngine as any as TestBedStatic;\n  }\n\n  static inject<T>(\n      token: Type<T>|InjectionToken<T>|AbstractType<T>, notFoundValue?: T, flags?: InjectFlags): T;\n  static inject<T>(\n      token: Type<T>|InjectionToken<T>|AbstractType<T>, notFoundValue: null, flags?: InjectFlags): T\n      |null;\n  static inject<T>(\n      token: Type<T>|InjectionToken<T>|AbstractType<T>, notFoundValue?: T|null,\n      flags?: InjectFlags): T|null {\n    return _getTestBedViewEngine().inject(token, notFoundValue, flags);\n  }\n\n  /** @deprecated from v9.0.0 use TestBed.inject */\n  static get<T>(token: Type<T>|InjectionToken<T>, notFoundValue?: T, flags?: InjectFlags): any;\n  /**\n   * @deprecated from v9.0.0 use TestBed.inject\n   * @suppress {duplicate}\n   */\n  static get(token: any, notFoundValue?: any): any;\n  /** @deprecated from v9.0.0 use TestBed.inject */\n  static get(\n      token: any, notFoundValue: any = Injector.THROW_IF_NOT_FOUND,\n      flags: InjectFlags = InjectFlags.Default): any {\n    return _getTestBedViewEngine().inject(token, notFoundValue, flags);\n  }\n\n  static createComponent<T>(component: Type<T>): ComponentFixture<T> {\n    return _getTestBedViewEngine().createComponent(component);\n  }\n\n  private _instantiated: boolean = false;\n\n  private _compiler: TestingCompiler = null!;\n  private _moduleRef: NgModuleRef<any> = null!;\n  private _moduleFactory: NgModuleFactory<any> = null!;\n\n  private _compilerOptions: CompilerOptions[] = [];\n\n  private _moduleOverrides: [Type<any>, MetadataOverride<NgModule>][] = [];\n  private _componentOverrides: [Type<any>, MetadataOverride<Component>][] = [];\n  private _directiveOverrides: [Type<any>, MetadataOverride<Directive>][] = [];\n  private _pipeOverrides: [Type<any>, MetadataOverride<Pipe>][] = [];\n\n  private _providers: Provider[] = [];\n  private _declarations: Array<Type<any>|any[]|any> = [];\n  private _imports: Array<Type<any>|any[]|any> = [];\n  private _schemas: Array<SchemaMetadata|any[]> = [];\n  private _activeFixtures: ComponentFixture<any>[] = [];\n\n  private _testEnvAotSummaries: () => any[] = () => [];\n  private _aotSummaries: Array<() => any[]> = [];\n  private _templateOverrides: Array<{component: Type<any>, templateOf: Type<any>}> = [];\n\n  private _isRoot: boolean = true;\n  private _rootProviderOverrides: Provider[] = [];\n\n  platform: PlatformRef = null!;\n\n  ngModule: Type<any>|Type<any>[] = null!;\n\n  /**\n   * Initialize the environment for testing with a compiler factory, a PlatformRef, and an\n   * angular module. These are common to every test in the suite.\n   *\n   * This may only be called once, to set up the common providers for the current test\n   * suite on the current platform. If you absolutely need to change the providers,\n   * first use `resetTestEnvironment`.\n   *\n   * Test modules and platforms for individual platforms are available from\n   * '@angular/<platform_name>/testing'.\n   */\n  initTestEnvironment(\n      ngModule: Type<any>|Type<any>[], platform: PlatformRef, aotSummaries?: () => any[]): void {\n    if (this.platform || this.ngModule) {\n      throw new Error('Cannot set base providers because it has already been called');\n    }\n    this.platform = platform;\n    this.ngModule = ngModule;\n    if (aotSummaries) {\n      this._testEnvAotSummaries = aotSummaries;\n    }\n  }\n\n  /**\n   * Reset the providers for the test injector.\n   */\n  resetTestEnvironment(): void {\n    this.resetTestingModule();\n    this.platform = null!;\n    this.ngModule = null!;\n    this._testEnvAotSummaries = () => [];\n  }\n\n  resetTestingModule(): void {\n    clearOverrides();\n    this._aotSummaries = [];\n    this._templateOverrides = [];\n    this._compiler = null!;\n    this._moduleOverrides = [];\n    this._componentOverrides = [];\n    this._directiveOverrides = [];\n    this._pipeOverrides = [];\n\n    this._isRoot = true;\n    this._rootProviderOverrides = [];\n\n    this._moduleRef = null!;\n    this._moduleFactory = null!;\n    this._compilerOptions = [];\n    this._providers = [];\n    this._declarations = [];\n    this._imports = [];\n    this._schemas = [];\n    this._instantiated = false;\n    this._activeFixtures.forEach((fixture) => {\n      try {\n        fixture.destroy();\n      } catch (e) {\n        console.error('Error during cleanup of component', {\n          component: fixture.componentInstance,\n          stacktrace: e,\n        });\n      }\n    });\n    this._activeFixtures = [];\n  }\n\n  configureCompiler(config: {providers?: any[], useJit?: boolean}): void {\n    this._assertNotInstantiated('TestBed.configureCompiler', 'configure the compiler');\n    this._compilerOptions.push(config);\n  }\n\n  configureTestingModule(moduleDef: TestModuleMetadata): void {\n    this._assertNotInstantiated('TestBed.configureTestingModule', 'configure the test module');\n    if (moduleDef.providers) {\n      this._providers.push(...moduleDef.providers);\n    }\n    if (moduleDef.declarations) {\n      this._declarations.push(...moduleDef.declarations);\n    }\n    if (moduleDef.imports) {\n      this._imports.push(...moduleDef.imports);\n    }\n    if (moduleDef.schemas) {\n      this._schemas.push(...moduleDef.schemas);\n    }\n    if (moduleDef.aotSummaries) {\n      this._aotSummaries.push(moduleDef.aotSummaries);\n    }\n  }\n\n  compileComponents(): Promise<any> {\n    if (this._moduleFactory || this._instantiated) {\n      return Promise.resolve(null);\n    }\n\n    const moduleType = this._createCompilerAndModule();\n    return this._compiler.compileModuleAndAllComponentsAsync(moduleType)\n        .then((moduleAndComponentFactories) => {\n          this._moduleFactory = moduleAndComponentFactories.ngModuleFactory;\n        });\n  }\n\n  private _initIfNeeded(): void {\n    if (this._instantiated) {\n      return;\n    }\n    if (!this._moduleFactory) {\n      try {\n        const moduleType = this._createCompilerAndModule();\n        this._moduleFactory =\n            this._compiler.compileModuleAndAllComponentsSync(moduleType).ngModuleFactory;\n      } catch (e) {\n        const errorCompType = this._compiler.getComponentFromError(e);\n        if (errorCompType) {\n          throw new Error(\n              `This test module uses the component ${\n                  stringify(\n                      errorCompType)} which is using a \"templateUrl\" or \"styleUrls\", but they were never compiled. ` +\n              `Please call \"TestBed.compileComponents\" before your test.`);\n        } else {\n          throw e;\n        }\n      }\n    }\n    for (const {component, templateOf} of this._templateOverrides) {\n      const compFactory = this._compiler.getComponentFactory(templateOf);\n      overrideComponentView(component, compFactory);\n    }\n\n    const ngZone =\n        new NgZone({enableLongStackTrace: true, shouldCoalesceEventChangeDetection: false});\n    const providers: StaticProvider[] = [{provide: NgZone, useValue: ngZone}];\n    const ngZoneInjector = Injector.create({\n      providers: providers,\n      parent: this.platform.injector,\n      name: this._moduleFactory.moduleType.name\n    });\n    this._moduleRef = this._moduleFactory.create(ngZoneInjector);\n    // ApplicationInitStatus.runInitializers() is marked @internal to core. So casting to any\n    // before accessing it.\n    (this._moduleRef.injector.get(ApplicationInitStatus) as any).runInitializers();\n    this._instantiated = true;\n  }\n\n  private _createCompilerAndModule(): Type<any> {\n    const providers = this._providers.concat([{provide: TestBed, useValue: this}]);\n    const declarations =\n        [...this._declarations, ...this._templateOverrides.map(entry => entry.templateOf)];\n\n    const rootScopeImports = [];\n    const rootProviderOverrides = this._rootProviderOverrides;\n    if (this._isRoot) {\n      @NgModule({\n        providers: [\n          ...rootProviderOverrides,\n        ],\n        jit: true,\n      })\n      class RootScopeModule {\n      }\n      rootScopeImports.push(RootScopeModule);\n    }\n    providers.push({provide: INJECTOR_SCOPE, useValue: this._isRoot ? 'root' : null});\n\n    const imports = [rootScopeImports, this.ngModule, this._imports];\n    const schemas = this._schemas;\n\n    @NgModule({providers, declarations, imports, schemas, jit: true})\n    class DynamicTestModule {\n    }\n\n    const compilerFactory = this.platform.injector.get(TestingCompilerFactory);\n    this._compiler = compilerFactory.createTestingCompiler(this._compilerOptions);\n    for (const summary of [this._testEnvAotSummaries, ...this._aotSummaries]) {\n      this._compiler.loadAotSummaries(summary);\n    }\n    this._moduleOverrides.forEach((entry) => this._compiler.overrideModule(entry[0], entry[1]));\n    this._componentOverrides.forEach(\n        (entry) => this._compiler.overrideComponent(entry[0], entry[1]));\n    this._directiveOverrides.forEach(\n        (entry) => this._compiler.overrideDirective(entry[0], entry[1]));\n    this._pipeOverrides.forEach((entry) => this._compiler.overridePipe(entry[0], entry[1]));\n    return DynamicTestModule;\n  }\n\n  private _assertNotInstantiated(methodName: string, methodDescription: string) {\n    if (this._instantiated) {\n      throw new Error(\n          `Cannot ${methodDescription} when the test module has already been instantiated. ` +\n          `Make sure you are not using \\`inject\\` before \\`${methodName}\\`.`);\n    }\n  }\n\n  inject<T>(\n      token: Type<T>|InjectionToken<T>|AbstractType<T>, notFoundValue?: T, flags?: InjectFlags): T;\n  inject<T>(\n      token: Type<T>|InjectionToken<T>|AbstractType<T>, notFoundValue: null, flags?: InjectFlags): T\n      |null;\n  inject<T>(\n      token: Type<T>|InjectionToken<T>|AbstractType<T>, notFoundValue?: T|null,\n      flags?: InjectFlags): T|null {\n    this._initIfNeeded();\n    if (token as unknown === TestBed) {\n      return this as any;\n    }\n    // Tests can inject things from the ng module and from the compiler,\n    // but the ng module can't inject things from the compiler and vice versa.\n    const UNDEFINED = {};\n    const result = this._moduleRef.injector.get(token, UNDEFINED, flags);\n    return result === UNDEFINED ? this._compiler.injector.get(token, notFoundValue, flags) as any :\n                                  result;\n  }\n\n  /** @deprecated from v9.0.0 use TestBed.inject */\n  get<T>(token: Type<T>|InjectionToken<T>, notFoundValue?: T, flags?: InjectFlags): any;\n  /** @deprecated from v9.0.0 use TestBed.inject */\n  get(token: any, notFoundValue?: any): any;\n  /** @deprecated from v9.0.0 use TestBed.inject */\n  get(token: any, notFoundValue: any = Injector.THROW_IF_NOT_FOUND,\n      flags: InjectFlags = InjectFlags.Default): any {\n    return this.inject(token, notFoundValue, flags);\n  }\n\n  execute(tokens: any[], fn: Function, context?: any): any {\n    this._initIfNeeded();\n    const params = tokens.map(t => this.inject(t));\n    return fn.apply(context, params);\n  }\n\n  overrideModule(ngModule: Type<any>, override: MetadataOverride<NgModule>): void {\n    this._assertNotInstantiated('overrideModule', 'override module metadata');\n    this._moduleOverrides.push([ngModule, override]);\n  }\n\n  overrideComponent(component: Type<any>, override: MetadataOverride<Component>): void {\n    this._assertNotInstantiated('overrideComponent', 'override component metadata');\n    this._componentOverrides.push([component, override]);\n  }\n\n  overrideDirective(directive: Type<any>, override: MetadataOverride<Directive>): void {\n    this._assertNotInstantiated('overrideDirective', 'override directive metadata');\n    this._directiveOverrides.push([directive, override]);\n  }\n\n  overridePipe(pipe: Type<any>, override: MetadataOverride<Pipe>): void {\n    this._assertNotInstantiated('overridePipe', 'override pipe metadata');\n    this._pipeOverrides.push([pipe, override]);\n  }\n\n  /**\n   * Overwrites all providers for the given token with the given provider definition.\n   */\n  overrideProvider(token: any, provider: {\n    useFactory: Function,\n    deps: any[],\n  }): void;\n  overrideProvider(token: any, provider: {useValue: any;}): void;\n  overrideProvider(token: any, provider: {useFactory?: Function, useValue?: any, deps?: any[]}):\n      void {\n    this.overrideProviderImpl(token, provider);\n  }\n\n  private overrideProviderImpl(\n      token: any, provider: {\n        useFactory?: Function,\n        useValue?: any,\n        deps?: any[],\n      },\n      deprecated = false): void {\n    let def: ɵɵInjectableDef<any>|null = null;\n    if (typeof token !== 'string' && (def = getInjectableDef(token)) && def.providedIn === 'root') {\n      if (provider.useFactory) {\n        this._rootProviderOverrides.push(\n            {provide: token, useFactory: provider.useFactory, deps: provider.deps || []});\n      } else {\n        this._rootProviderOverrides.push({provide: token, useValue: provider.useValue});\n      }\n    }\n    let flags: NodeFlags = 0;\n    let value: any;\n    if (provider.useFactory) {\n      flags |= NodeFlags.TypeFactoryProvider;\n      value = provider.useFactory;\n    } else {\n      flags |= NodeFlags.TypeValueProvider;\n      value = provider.useValue;\n    }\n    const deps = (provider.deps || []).map((dep) => {\n      let depFlags: DepFlags = DepFlags.None;\n      let depToken: any;\n      if (Array.isArray(dep)) {\n        dep.forEach((entry: any) => {\n          if (entry instanceof Optional) {\n            depFlags |= DepFlags.Optional;\n          } else if (entry instanceof SkipSelf) {\n            depFlags |= DepFlags.SkipSelf;\n          } else {\n            depToken = entry;\n          }\n        });\n      } else {\n        depToken = dep;\n      }\n      return [depFlags, depToken];\n    });\n    overrideProvider({token, flags, deps, value, deprecatedBehavior: deprecated});\n  }\n\n  overrideTemplateUsingTestingModule(component: Type<any>, template: string) {\n    this._assertNotInstantiated('overrideTemplateUsingTestingModule', 'override template');\n\n    @Component({selector: 'empty', template, jit: true})\n    class OverrideComponent {\n    }\n\n    this._templateOverrides.push({component, templateOf: OverrideComponent});\n  }\n\n  createComponent<T>(component: Type<T>): ComponentFixture<T> {\n    this._initIfNeeded();\n    const componentFactory = this._compiler.getComponentFactory(component);\n\n    if (!componentFactory) {\n      throw new Error(`Cannot create the component ${\n          stringify(component)} as it was not imported into the testing module!`);\n    }\n\n    // TODO: Don't cast as `InjectionToken<boolean>`, declared type is boolean[]\n    const noNgZone = this.inject(ComponentFixtureNoNgZone as InjectionToken<boolean>, false);\n    // TODO: Don't cast as `InjectionToken<boolean>`, declared type is boolean[]\n    const autoDetect: boolean =\n        this.inject(ComponentFixtureAutoDetect as InjectionToken<boolean>, false);\n    const ngZone: NgZone|null = noNgZone ? null : this.inject(NgZone, null);\n    const testComponentRenderer: TestComponentRenderer = this.inject(TestComponentRenderer);\n    const rootElId = `root${_nextRootElementId++}`;\n    testComponentRenderer.insertRootElement(rootElId);\n\n    const initComponent = () => {\n      const componentRef =\n          componentFactory.create(Injector.NULL, [], `#${rootElId}`, this._moduleRef);\n      return new ComponentFixture<T>(componentRef, ngZone, autoDetect);\n    };\n\n    const fixture = !ngZone ? initComponent() : ngZone.run(initComponent);\n    this._activeFixtures.push(fixture);\n    return fixture;\n  }\n}\n\n/**\n * @description\n * Configures and initializes environment for unit testing and provides methods for\n * creating components and services in unit tests.\n *\n * `TestBed` is the primary api for writing unit tests for Angular applications and libraries.\n *\n * Note: Use `TestBed` in tests. It will be set to either `TestBedViewEngine` or `TestBedRender3`\n * according to the compiler used.\n *\n * @publicApi\n */\nexport const TestBed: TestBedStatic =\n    ivyEnabled ? TestBedRender3 as any as TestBedStatic : TestBedViewEngine as any as TestBedStatic;\n\n/**\n * Returns a singleton of the applicable `TestBed`.\n *\n * It will be either an instance of `TestBedViewEngine` or `TestBedRender3`.\n *\n * @publicApi\n */\nexport const getTestBed: () => TestBed = ivyEnabled ? _getTestBedRender3 : _getTestBedViewEngine;\n\nlet testBed: TestBedViewEngine;\n\nfunction _getTestBedViewEngine(): TestBedViewEngine {\n  return testBed = testBed || new TestBedViewEngine();\n}\n\n/**\n * Allows injecting dependencies in `beforeEach()` and `it()`.\n *\n * Example:\n *\n * ```\n * beforeEach(inject([Dependency, AClass], (dep, object) => {\n *   // some code that uses `dep` and `object`\n *   // ...\n * }));\n *\n * it('...', inject([AClass], (object) => {\n *   object.doSomething();\n *   expect(...);\n * })\n * ```\n *\n * Notes:\n * - inject is currently a function because of some Traceur limitation the syntax should\n * eventually\n *   becomes `it('...', @Inject (object: AClass, async: AsyncTestCompleter) => { ... });`\n *\n * @publicApi\n */\nexport function inject(tokens: any[], fn: Function): () => any {\n  const testBed = getTestBed();\n  if (tokens.indexOf(AsyncTestCompleter) >= 0) {\n    // Not using an arrow function to preserve context passed from call site\n    return function(this: unknown) {\n      // Return an async test method that returns a Promise if AsyncTestCompleter is one of\n      // the injected tokens.\n      return testBed.compileComponents().then(() => {\n        const completer = testBed.inject(AsyncTestCompleter);\n        testBed.execute(tokens, fn, this);\n        return completer.promise;\n      });\n    };\n  } else {\n    // Not using an arrow function to preserve context passed from call site\n    return function(this: unknown) {\n      return testBed.execute(tokens, fn, this);\n    };\n  }\n}\n\n/**\n * @publicApi\n */\nexport class InjectSetupWrapper {\n  constructor(private _moduleDef: () => TestModuleMetadata) {}\n\n  private _addModule() {\n    const moduleDef = this._moduleDef();\n    if (moduleDef) {\n      getTestBed().configureTestingModule(moduleDef);\n    }\n  }\n\n  inject(tokens: any[], fn: Function): () => any {\n    const self = this;\n    // Not using an arrow function to preserve context passed from call site\n    return function(this: unknown) {\n      self._addModule();\n      return inject(tokens, fn).call(this);\n    };\n  }\n}\n\n/**\n * @publicApi\n */\nexport function withModule(moduleDef: TestModuleMetadata): InjectSetupWrapper;\nexport function withModule(moduleDef: TestModuleMetadata, fn: Function): () => any;\nexport function withModule(moduleDef: TestModuleMetadata, fn?: Function|null): (() => any)|\n    InjectSetupWrapper {\n  if (fn) {\n    // Not using an arrow function to preserve context passed from call site\n    return function(this: unknown) {\n      const testBed = getTestBed();\n      if (moduleDef) {\n        testBed.configureTestingModule(moduleDef);\n      }\n      return fn.apply(this);\n    };\n  }\n  return new InjectSetupWrapper(() => moduleDef);\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Public Test Library for unit testing Angular applications. Assumes that you are running\n * with Jasmine, Mocha, or a similar framework which exports a beforeEach function and\n * allows tests to be asynchronous by either returning a promise or using a 'done' parameter.\n */\n\nimport {resetFakeAsyncZone} from './fake_async';\nimport {TestBed} from './test_bed';\n\ndeclare var global: any;\n\nconst _global = <any>(typeof window === 'undefined' ? global : window);\n\n// Reset the test providers and the fake async zone before each test.\nif (_global.beforeEach) {\n  _global.beforeEach(() => {\n    TestBed.resetTestingModule();\n    resetFakeAsyncZone();\n  });\n}\n\n/**\n * This API should be removed. But doing so seems to break `google3` and so it requires a bit of\n * investigation.\n *\n * A work around is to mark it as `@codeGenApi` for now and investigate later.\n *\n * @codeGenApi\n */\n// TODO(iminar): Remove this code in a safe way.\nexport const __core_private_testing_placeholder__ = '';\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Type used for modifications to metadata\n *\n * @publicApi\n */\nexport type MetadataOverride<T> = {\n  add?: Partial<T>,\n  remove?: Partial<T>,\n  set?: Partial<T>\n};\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nexport {TestingCompiler as ɵTestingCompiler, TestingCompilerFactory as ɵTestingCompilerFactory} from './test_compiler';\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @module\n * @description\n * Entry point for all public APIs of the core/testing package.\n */\n\nexport * from './async';\nexport * from './component_fixture';\nexport * from './fake_async';\nexport {TestBed, getTestBed, inject, InjectSetupWrapper, withModule} from './test_bed';\nexport * from './test_bed_common';\nexport * from './before_each';\nexport * from './metadata_override';\nexport {MetadataOverrider as ɵMetadataOverrider} from './metadata_overrider';\nexport * from './private_export_testing';\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/// <reference types=\"jasmine\" />\n\n/**\n * @module\n * @description\n * Entry point for all public APIs of this package.\n */\nexport * from './src/testing';\n\n// This file only reexports content of the `src` folder. Keep it that way.\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n// This file is not used to build this module. It is only used during editing\n// by the TypeScript language service and during build for verification. `ngc`\n// replaces this file with production index.ts when it rewrites private symbol\n// names.\n\nexport * from './public_api';\n","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './index';\n\nexport {TestBedRender3 as ɵangular_packages_core_testing_testing_b,_getTestBedRender3 as ɵangular_packages_core_testing_testing_c} from './src/r3_test_bed';\nexport {TestBedViewEngine as ɵangular_packages_core_testing_testing_a} from './src/test_bed';"]},"metadata":{},"sourceType":"module"}